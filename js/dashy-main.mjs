const appName = "dashy";
const appVersion = "2.0.0";
const global$1 = globalThis || void 0 || self;
var define_global_process_env_default = {};
/*!
 * Vue.js v2.7.16
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
var emptyObject = Object.freeze({});
var isArray$1 = Array.isArray;
function isUndef(v) {
  return v === void 0 || v === null;
}
function isDef(v) {
  return v !== void 0 && v !== null;
}
function isTrue(v) {
  return v === true;
}
function isFalse(v) {
  return v === false;
}
function isPrimitive(value) {
  return typeof value === "string" || typeof value === "number" || // $flow-disable-line
  typeof value === "symbol" || typeof value === "boolean";
}
function isFunction$1(value) {
  return typeof value === "function";
}
function isObject$2(obj) {
  return obj !== null && typeof obj === "object";
}
var _toString = Object.prototype.toString;
function isPlainObject$1(obj) {
  return _toString.call(obj) === "[object Object]";
}
function isRegExp$1(v) {
  return _toString.call(v) === "[object RegExp]";
}
function isValidArrayIndex(val) {
  var n2 = parseFloat(String(val));
  return n2 >= 0 && Math.floor(n2) === n2 && isFinite(val);
}
function isPromise(val) {
  return isDef(val) && typeof val.then === "function" && typeof val.catch === "function";
}
function toString$2(val) {
  return val == null ? "" : Array.isArray(val) || isPlainObject$1(val) && val.toString === _toString ? JSON.stringify(val, replacer, 2) : String(val);
}
function replacer(_key, val) {
  if (val && val.__v_isRef) {
    return val.value;
  }
  return val;
}
function toNumber(val) {
  var n2 = parseFloat(val);
  return isNaN(n2) ? val : n2;
}
function makeMap(str, expectsLowerCase) {
  var map = /* @__PURE__ */ Object.create(null);
  var list = str.split(",");
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? function(val) {
    return map[val.toLowerCase()];
  } : function(val) {
    return map[val];
  };
}
makeMap("slot,component", true);
var isReservedAttribute = makeMap("key,ref,slot,slot-scope,is");
function remove$2(arr, item) {
  var len = arr.length;
  if (len) {
    if (item === arr[len - 1]) {
      arr.length = len - 1;
      return;
    }
    var index2 = arr.indexOf(item);
    if (index2 > -1) {
      return arr.splice(index2, 1);
    }
  }
}
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty$1.call(obj, key);
}
function cached(fn) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
var camelizeRE = /-(\w)/g;
var camelize = cached(function(str) {
  return str.replace(camelizeRE, function(_2, c) {
    return c ? c.toUpperCase() : "";
  });
});
var capitalize = cached(function(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function(str) {
  return str.replace(hyphenateRE, "-$1").toLowerCase();
});
function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }
  boundFn._length = fn.length;
  return boundFn;
}
function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}
var bind$2 = Function.prototype.bind ? nativeBind : polyfillBind;
function toArray$1(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret;
}
function extend$1(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
}
function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend$1(res, arr[i]);
    }
  }
  return res;
}
function noop$3(a, b, c) {
}
var no = function(a, b, c) {
  return false;
};
var identity = function(_2) {
  return _2;
};
function looseEqual(a, b) {
  if (a === b)
    return true;
  var isObjectA = isObject$2(a);
  var isObjectB = isObject$2(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function(e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function(key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        return false;
      }
    } catch (e) {
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}
function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val))
      return i;
  }
  return -1;
}
function once(fn) {
  var called = false;
  return function() {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}
function hasChanged(x, y) {
  if (x === y) {
    return x === 0 && 1 / x !== 1 / y;
  } else {
    return x === x || y === y;
  }
}
var SSR_ATTR = "data-server-rendered";
var ASSET_TYPES = ["component", "directive", "filter"];
var LIFECYCLE_HOOKS = [
  "beforeCreate",
  "created",
  "beforeMount",
  "mounted",
  "beforeUpdate",
  "updated",
  "beforeDestroy",
  "destroyed",
  "activated",
  "deactivated",
  "errorCaptured",
  "serverPrefetch",
  "renderTracked",
  "renderTriggered"
];
var config$1 = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: /* @__PURE__ */ Object.create(null),
  /**
   * Whether to suppress warnings.
   */
  silent: false,
  /**
   * Show production mode tip message on boot?
   */
  productionTip: false,
  /**
   * Whether to enable devtools
   */
  devtools: false,
  /**
   * Whether to record perf
   */
  performance: false,
  /**
   * Error handler for watcher errors
   */
  errorHandler: null,
  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,
  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],
  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: /* @__PURE__ */ Object.create(null),
  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,
  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,
  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,
  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop$3,
  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,
  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,
  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,
  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};
var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
function isReserved(str) {
  var c = (str + "").charCodeAt(0);
  return c === 36 || c === 95;
}
function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: false,
    writable: true,
    configurable: true
  });
}
var bailRE = new RegExp("[^".concat(unicodeRegExp.source, ".$_\\d]"));
function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }
  var segments = path.split(".");
  return function(obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj)
        return;
      obj = obj[segments[i]];
    }
    return obj;
  };
}
var hasProto = "__proto__" in {};
var inBrowser = typeof window !== "undefined";
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE$1 = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf("msie 9.0") > 0;
var isEdge = UA && UA.indexOf("edge/") > 0;
UA && UA.indexOf("android") > 0;
var isIOS$1 = UA && /iphone|ipad|ipod|ios/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/);
var nativeWatch = {}.watch;
var supportsPassive$1 = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, "passive", {
      get: function() {
        supportsPassive$1 = true;
      }
    });
    window.addEventListener("test-passive", null, opts);
  } catch (e) {
  }
}
var _isServer;
var isServerRendering = function() {
  if (_isServer === void 0) {
    if (!inBrowser && typeof global$1 !== "undefined") {
      _isServer = global$1["process"] && define_global_process_env_default.VUE_ENV === "server";
    } else {
      _isServer = false;
    }
  }
  return _isServer;
};
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
function isNative(Ctor) {
  return typeof Ctor === "function" && /native code/.test(Ctor.toString());
}
var hasSymbol = typeof Symbol !== "undefined" && isNative(Symbol) && typeof Reflect !== "undefined" && isNative(Reflect.ownKeys);
var _Set;
if (typeof Set !== "undefined" && isNative(Set)) {
  _Set = Set;
} else {
  _Set = /** @class */
  function() {
    function Set2() {
      this.set = /* @__PURE__ */ Object.create(null);
    }
    Set2.prototype.has = function(key) {
      return this.set[key] === true;
    };
    Set2.prototype.add = function(key) {
      this.set[key] = true;
    };
    Set2.prototype.clear = function() {
      this.set = /* @__PURE__ */ Object.create(null);
    };
    return Set2;
  }();
}
var currentInstance = null;
function getCurrentInstance() {
  return currentInstance && { proxy: currentInstance };
}
function setCurrentInstance(vm) {
  if (vm === void 0) {
    vm = null;
  }
  if (!vm)
    currentInstance && currentInstance._scope.off();
  currentInstance = vm;
  vm && vm._scope.on();
}
var VNode = (
  /** @class */
  function() {
    function VNode2(tag, data, children, text2, elm, context, componentOptions, asyncFactory) {
      this.tag = tag;
      this.data = data;
      this.children = children;
      this.text = text2;
      this.elm = elm;
      this.ns = void 0;
      this.context = context;
      this.fnContext = void 0;
      this.fnOptions = void 0;
      this.fnScopeId = void 0;
      this.key = data && data.key;
      this.componentOptions = componentOptions;
      this.componentInstance = void 0;
      this.parent = void 0;
      this.raw = false;
      this.isStatic = false;
      this.isRootInsert = true;
      this.isComment = false;
      this.isCloned = false;
      this.isOnce = false;
      this.asyncFactory = asyncFactory;
      this.asyncMeta = void 0;
      this.isAsyncPlaceholder = false;
    }
    Object.defineProperty(VNode2.prototype, "child", {
      // DEPRECATED: alias for componentInstance for backwards compat.
      /* istanbul ignore next */
      get: function() {
        return this.componentInstance;
      },
      enumerable: false,
      configurable: true
    });
    return VNode2;
  }()
);
var createEmptyVNode = function(text2) {
  if (text2 === void 0) {
    text2 = "";
  }
  var node = new VNode();
  node.text = text2;
  node.isComment = true;
  return node;
};
function createTextVNode(val) {
  return new VNode(void 0, void 0, void 0, String(val));
}
function cloneVNode(vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    vnode.children && vnode.children.slice(),
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var uid$2 = 0;
var pendingCleanupDeps = [];
var cleanupDeps = function() {
  for (var i = 0; i < pendingCleanupDeps.length; i++) {
    var dep = pendingCleanupDeps[i];
    dep.subs = dep.subs.filter(function(s) {
      return s;
    });
    dep._pending = false;
  }
  pendingCleanupDeps.length = 0;
};
var Dep = (
  /** @class */
  function() {
    function Dep2() {
      this._pending = false;
      this.id = uid$2++;
      this.subs = [];
    }
    Dep2.prototype.addSub = function(sub) {
      this.subs.push(sub);
    };
    Dep2.prototype.removeSub = function(sub) {
      this.subs[this.subs.indexOf(sub)] = null;
      if (!this._pending) {
        this._pending = true;
        pendingCleanupDeps.push(this);
      }
    };
    Dep2.prototype.depend = function(info) {
      if (Dep2.target) {
        Dep2.target.addDep(this);
      }
    };
    Dep2.prototype.notify = function(info) {
      var subs = this.subs.filter(function(s) {
        return s;
      });
      for (var i = 0, l = subs.length; i < l; i++) {
        var sub = subs[i];
        sub.update();
      }
    };
    return Dep2;
  }()
);
Dep.target = null;
var targetStack = [];
function pushTarget(target2) {
  targetStack.push(target2);
  Dep.target = target2;
}
function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}
var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);
var methodsToPatch = [
  "push",
  "pop",
  "shift",
  "unshift",
  "splice",
  "sort",
  "reverse"
];
methodsToPatch.forEach(function(method) {
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case "push":
      case "unshift":
        inserted = args;
        break;
      case "splice":
        inserted = args.slice(2);
        break;
    }
    if (inserted)
      ob.observeArray(inserted);
    {
      ob.dep.notify();
    }
    return result;
  });
});
var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
var NO_INITIAL_VALUE = {};
var shouldObserve = true;
function toggleObserving(value) {
  shouldObserve = value;
}
var mockDep = {
  notify: noop$3,
  depend: noop$3,
  addSub: noop$3,
  removeSub: noop$3
};
var Observer = (
  /** @class */
  function() {
    function Observer2(value, shallow, mock) {
      if (shallow === void 0) {
        shallow = false;
      }
      if (mock === void 0) {
        mock = false;
      }
      this.value = value;
      this.shallow = shallow;
      this.mock = mock;
      this.dep = mock ? mockDep : new Dep();
      this.vmCount = 0;
      def(value, "__ob__", this);
      if (isArray$1(value)) {
        if (!mock) {
          if (hasProto) {
            value.__proto__ = arrayMethods;
          } else {
            for (var i = 0, l = arrayKeys.length; i < l; i++) {
              var key = arrayKeys[i];
              def(value, key, arrayMethods[key]);
            }
          }
        }
        if (!shallow) {
          this.observeArray(value);
        }
      } else {
        var keys = Object.keys(value);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          defineReactive(value, key, NO_INITIAL_VALUE, void 0, shallow, mock);
        }
      }
    }
    Observer2.prototype.observeArray = function(value) {
      for (var i = 0, l = value.length; i < l; i++) {
        observe(value[i], false, this.mock);
      }
    };
    return Observer2;
  }()
);
function observe(value, shallow, ssrMockReactivity) {
  if (value && hasOwn(value, "__ob__") && value.__ob__ instanceof Observer) {
    return value.__ob__;
  }
  if (shouldObserve && (ssrMockReactivity || !isServerRendering()) && (isArray$1(value) || isPlainObject$1(value)) && Object.isExtensible(value) && !value.__v_skip && !isRef(value) && !(value instanceof VNode)) {
    return new Observer(value, shallow, ssrMockReactivity);
  }
}
function defineReactive(obj, key, val, customSetter, shallow, mock, observeEvenIfShallow) {
  if (observeEvenIfShallow === void 0) {
    observeEvenIfShallow = false;
  }
  var dep = new Dep();
  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return;
  }
  var getter = property && property.get;
  var setter = property && property.set;
  if ((!getter || setter) && (val === NO_INITIAL_VALUE || arguments.length === 2)) {
    val = obj[key];
  }
  var childOb = shallow ? val && val.__ob__ : observe(val, false, mock);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        {
          dep.depend();
        }
        if (childOb) {
          childOb.dep.depend();
          if (isArray$1(value)) {
            dependArray(value);
          }
        }
      }
      return isRef(value) && !shallow ? value.value : value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      if (!hasChanged(value, newVal)) {
        return;
      }
      if (setter) {
        setter.call(obj, newVal);
      } else if (getter) {
        return;
      } else if (!shallow && isRef(value) && !isRef(newVal)) {
        value.value = newVal;
        return;
      } else {
        val = newVal;
      }
      childOb = shallow ? newVal && newVal.__ob__ : observe(newVal, false, mock);
      {
        dep.notify();
      }
    }
  });
  return dep;
}
function set(target2, key, val) {
  if (isReadonly(target2)) {
    return;
  }
  var ob = target2.__ob__;
  if (isArray$1(target2) && isValidArrayIndex(key)) {
    target2.length = Math.max(target2.length, key);
    target2.splice(key, 1, val);
    if (ob && !ob.shallow && ob.mock) {
      observe(val, false, true);
    }
    return val;
  }
  if (key in target2 && !(key in Object.prototype)) {
    target2[key] = val;
    return val;
  }
  if (target2._isVue || ob && ob.vmCount) {
    return val;
  }
  if (!ob) {
    target2[key] = val;
    return val;
  }
  defineReactive(ob.value, key, val, void 0, ob.shallow, ob.mock);
  {
    ob.dep.notify();
  }
  return val;
}
function del(target2, key) {
  if (isArray$1(target2) && isValidArrayIndex(key)) {
    target2.splice(key, 1);
    return;
  }
  var ob = target2.__ob__;
  if (target2._isVue || ob && ob.vmCount) {
    return;
  }
  if (isReadonly(target2)) {
    return;
  }
  if (!hasOwn(target2, key)) {
    return;
  }
  delete target2[key];
  if (!ob) {
    return;
  }
  {
    ob.dep.notify();
  }
}
function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    if (e && e.__ob__) {
      e.__ob__.dep.depend();
    }
    if (isArray$1(e)) {
      dependArray(e);
    }
  }
}
function reactive(target2) {
  makeReactive(target2, false);
  return target2;
}
function shallowReactive(target2) {
  makeReactive(target2, true);
  def(target2, "__v_isShallow", true);
  return target2;
}
function makeReactive(target2, shallow) {
  if (!isReadonly(target2)) {
    observe(
      target2,
      shallow,
      isServerRendering()
      /* ssr mock reactivity */
    );
  }
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value[
      "__v_raw"
      /* ReactiveFlags.RAW */
    ]);
  }
  return !!(value && value.__ob__);
}
function isShallow(value) {
  return !!(value && value.__v_isShallow);
}
function isReadonly(value) {
  return !!(value && value.__v_isReadonly);
}
var RefFlag = "__v_isRef";
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref$1(value) {
  return createRef(value, false);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  var ref2 = {};
  def(ref2, RefFlag, true);
  def(ref2, "__v_isShallow", shallow);
  def(ref2, "dep", defineReactive(ref2, "value", rawValue, null, shallow, isServerRendering()));
  return ref2;
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
function proxyWithRefUnwrap(target2, source, key) {
  Object.defineProperty(target2, key, {
    enumerable: true,
    configurable: true,
    get: function() {
      var val = source[key];
      if (isRef(val)) {
        return val.value;
      } else {
        var ob = val && val.__ob__;
        if (ob)
          ob.dep.depend();
        return val;
      }
    },
    set: function(value) {
      var oldValue = source[key];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
      } else {
        source[key] = value;
      }
    }
  });
}
function toRef(object, key, defaultValue) {
  var val = object[key];
  if (isRef(val)) {
    return val;
  }
  var ref2 = {
    get value() {
      var val2 = object[key];
      return val2 === void 0 ? defaultValue : val2;
    },
    set value(newVal) {
      object[key] = newVal;
    }
  };
  def(ref2, RefFlag, true);
  return ref2;
}
var rawToReadonlyFlag = "__v_rawToReadonly";
function readonly(target2) {
  return createReadonly(target2);
}
function createReadonly(target2, shallow) {
  if (!isPlainObject$1(target2)) {
    return target2;
  }
  if (isReadonly(target2)) {
    return target2;
  }
  var existingFlag = rawToReadonlyFlag;
  var existingProxy = target2[existingFlag];
  if (existingProxy) {
    return existingProxy;
  }
  var proxy2 = Object.create(Object.getPrototypeOf(target2));
  def(target2, existingFlag, proxy2);
  def(proxy2, "__v_isReadonly", true);
  def(proxy2, "__v_raw", target2);
  if (isRef(target2)) {
    def(proxy2, RefFlag, true);
  }
  if (isShallow(target2)) {
    def(proxy2, "__v_isShallow", true);
  }
  var keys = Object.keys(target2);
  for (var i = 0; i < keys.length; i++) {
    defineReadonlyProperty(proxy2, target2, keys[i]);
  }
  return proxy2;
}
function defineReadonlyProperty(proxy2, target2, key, shallow) {
  Object.defineProperty(proxy2, key, {
    enumerable: true,
    configurable: true,
    get: function() {
      var val = target2[key];
      return !isPlainObject$1(val) ? val : readonly(val);
    },
    set: function() {
    }
  });
}
function computed(getterOrOptions, debugOptions) {
  var getter;
  var setter;
  var onlyGetter = isFunction$1(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = noop$3;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  var watcher = isServerRendering() ? null : new Watcher(currentInstance, getter, noop$3, { lazy: true });
  var ref2 = {
    // some libs rely on the presence effect for checking computed refs
    // from normal refs, but the implementation doesn't matter
    effect: watcher,
    get value() {
      if (watcher) {
        if (watcher.dirty) {
          watcher.evaluate();
        }
        if (Dep.target) {
          watcher.depend();
        }
        return watcher.value;
      } else {
        return getter();
      }
    },
    set value(newVal) {
      setter(newVal);
    }
  };
  def(ref2, RefFlag, true);
  def(ref2, "__v_isReadonly", onlyGetter);
  return ref2;
}
var WATCHER = "watcher";
var WATCHER_CB = "".concat(WATCHER, " callback");
var WATCHER_GETTER = "".concat(WATCHER, " getter");
var WATCHER_CLEANUP = "".concat(WATCHER, " cleanup");
function watchEffect(effect, options) {
  return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
  return doWatch(effect, null, { flush: "post" });
}
var INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, _a2) {
  var _b = _a2 === void 0 ? emptyObject : _a2, immediate = _b.immediate, deep = _b.deep, _c = _b.flush, flush = _c === void 0 ? "pre" : _c;
  _b.onTrack;
  _b.onTrigger;
  var instance = currentInstance;
  var call = function(fn, type, args) {
    if (args === void 0) {
      args = null;
    }
    var res = invokeWithErrorHandling(fn, null, args, instance, type);
    if (deep && res && res.__ob__)
      res.__ob__.dep.depend();
    return res;
  };
  var getter;
  var forceTrigger = false;
  var isMultiSource = false;
  if (isRef(source)) {
    getter = function() {
      return source.value;
    };
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = function() {
      source.__ob__.dep.depend();
      return source;
    };
    deep = true;
  } else if (isArray$1(source)) {
    isMultiSource = true;
    forceTrigger = source.some(function(s) {
      return isReactive(s) || isShallow(s);
    });
    getter = function() {
      return source.map(function(s) {
        if (isRef(s)) {
          return s.value;
        } else if (isReactive(s)) {
          s.__ob__.dep.depend();
          return traverse(s);
        } else if (isFunction$1(s)) {
          return call(s, WATCHER_GETTER);
        } else ;
      });
    };
  } else if (isFunction$1(source)) {
    if (cb) {
      getter = function() {
        return call(source, WATCHER_GETTER);
      };
    } else {
      getter = function() {
        if (instance && instance._isDestroyed) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return call(source, WATCHER, [onCleanup]);
      };
    }
  } else {
    getter = noop$3;
  }
  if (cb && deep) {
    var baseGetter_1 = getter;
    getter = function() {
      return traverse(baseGetter_1());
    };
  }
  var cleanup;
  var onCleanup = function(fn) {
    cleanup = watcher.onStop = function() {
      call(fn, WATCHER_CLEANUP);
    };
  };
  if (isServerRendering()) {
    onCleanup = noop$3;
    if (!cb) {
      getter();
    } else if (immediate) {
      call(cb, WATCHER_CB, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    return noop$3;
  }
  var watcher = new Watcher(currentInstance, getter, noop$3, {
    lazy: true
  });
  watcher.noRecurse = !cb;
  var oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
  watcher.run = function() {
    if (!watcher.active) {
      return;
    }
    if (cb) {
      var newValue = watcher.get();
      if (deep || forceTrigger || (isMultiSource ? newValue.some(function(v, i) {
        return hasChanged(v, oldValue[i]);
      }) : hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        call(cb, WATCHER_CB, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      watcher.get();
    }
  };
  if (flush === "sync") {
    watcher.update = watcher.run;
  } else if (flush === "post") {
    watcher.post = true;
    watcher.update = function() {
      return queueWatcher(watcher);
    };
  } else {
    watcher.update = function() {
      if (instance && instance === currentInstance && !instance._isMounted) {
        var buffer2 = instance._preWatchers || (instance._preWatchers = []);
        if (buffer2.indexOf(watcher) < 0)
          buffer2.push(watcher);
      } else {
        queueWatcher(watcher);
      }
    };
  }
  if (cb) {
    if (immediate) {
      watcher.run();
    } else {
      oldValue = watcher.get();
    }
  } else if (flush === "post" && instance) {
    instance.$once("hook:mounted", function() {
      return watcher.get();
    });
  } else {
    watcher.get();
  }
  return function() {
    watcher.teardown();
  };
}
var activeEffectScope;
var EffectScope = (
  /** @class */
  function() {
    function EffectScope2(detached) {
      if (detached === void 0) {
        detached = false;
      }
      this.detached = detached;
      this.active = true;
      this.effects = [];
      this.cleanups = [];
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
      }
    }
    EffectScope2.prototype.run = function(fn) {
      if (this.active) {
        var currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      }
    };
    EffectScope2.prototype.on = function() {
      activeEffectScope = this;
    };
    EffectScope2.prototype.off = function() {
      activeEffectScope = this.parent;
    };
    EffectScope2.prototype.stop = function(fromParent) {
      if (this.active) {
        var i = void 0, l = void 0;
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].teardown();
        }
        for (i = 0, l = this.cleanups.length; i < l; i++) {
          this.cleanups[i]();
        }
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].stop(true);
          }
        }
        if (!this.detached && this.parent && !fromParent) {
          var last = this.parent.scopes.pop();
          if (last && last !== this) {
            this.parent.scopes[this.index] = last;
            last.index = this.index;
          }
        }
        this.parent = void 0;
        this.active = false;
      }
    };
    return EffectScope2;
  }()
);
function recordEffectScope(effect, scope) {
  if (scope === void 0) {
    scope = activeEffectScope;
  }
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
function resolveProvided(vm) {
  var existing = vm._provided;
  var parentProvides = vm.$parent && vm.$parent._provided;
  if (parentProvides === existing) {
    return vm._provided = Object.create(parentProvides);
  } else {
    return existing;
  }
}
var normalizeEvent = cached(function(name) {
  var passive = name.charAt(0) === "&";
  name = passive ? name.slice(1) : name;
  var once2 = name.charAt(0) === "~";
  name = once2 ? name.slice(1) : name;
  var capture = name.charAt(0) === "!";
  name = capture ? name.slice(1) : name;
  return {
    name,
    once: once2,
    capture,
    passive
  };
});
function createFnInvoker(fns, vm) {
  function invoker() {
    var fns2 = invoker.fns;
    if (isArray$1(fns2)) {
      var cloned = fns2.slice();
      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments, vm, "v-on handler");
      }
    } else {
      return invokeWithErrorHandling(fns2, null, arguments, vm, "v-on handler");
    }
  }
  invoker.fns = fns;
  return invoker;
}
function updateListeners(on, oldOn, add2, remove2, createOnceHandler2, vm) {
  var name, cur, old, event;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) ;
    else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }
      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler2(event.name, cur, event.capture);
      }
      add2(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove2(event.name, oldOn[name], event.capture);
    }
  }
}
function mergeVNodeHook(def2, hookKey, hook) {
  if (def2 instanceof VNode) {
    def2 = def2.data.hook || (def2.data.hook = {});
  }
  var invoker;
  var oldHook = def2[hookKey];
  function wrappedHook() {
    hook.apply(this, arguments);
    remove$2(invoker.fns, wrappedHook);
  }
  if (isUndef(oldHook)) {
    invoker = createFnInvoker([wrappedHook]);
  } else {
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }
  invoker.merged = true;
  def2[hookKey] = invoker;
}
function extractPropsFromVNodeData(data, Ctor, tag) {
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return;
  }
  var res = {};
  var attrs2 = data.attrs, props2 = data.props;
  if (isDef(attrs2) || isDef(props2)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      checkProp(res, props2, key, altKey, true) || checkProp(res, attrs2, key, altKey, false);
    }
  }
  return res;
}
function checkProp(res, hash2, key, altKey, preserve) {
  if (isDef(hash2)) {
    if (hasOwn(hash2, key)) {
      res[key] = hash2[key];
      if (!preserve) {
        delete hash2[key];
      }
      return true;
    } else if (hasOwn(hash2, altKey)) {
      res[key] = hash2[altKey];
      if (!preserve) {
        delete hash2[altKey];
      }
      return true;
    }
  }
  return false;
}
function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (isArray$1(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }
  return children;
}
function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : isArray$1(children) ? normalizeArrayChildren(children) : void 0;
}
function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}
function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === "boolean")
      continue;
    lastIndex = res.length - 1;
    last = res[lastIndex];
    if (isArray$1(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, "".concat(nestedIndex || "", "_").concat(i));
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== "") {
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist".concat(nestedIndex, "_").concat(i, "__");
        }
        res.push(c);
      }
    }
  }
  return res;
}
function renderList(val, render66) {
  var ret = null, i, l, keys, key;
  if (isArray$1(val) || typeof val === "string") {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render66(val[i], i);
    }
  } else if (typeof val === "number") {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render66(i + 1, i);
    }
  } else if (isObject$2(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator2 = val[Symbol.iterator]();
      var result = iterator2.next();
      while (!result.done) {
        ret.push(render66(result.value, ret.length));
        result = iterator2.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render66(val[key], key, i);
      }
    }
  }
  if (!isDef(ret)) {
    ret = [];
  }
  ret._isVList = true;
  return ret;
}
function renderSlot(name, fallbackRender, props2, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) {
    props2 = props2 || {};
    if (bindObject) {
      props2 = extend$1(extend$1({}, bindObject), props2);
    }
    nodes = scopedSlotFn(props2) || (isFunction$1(fallbackRender) ? fallbackRender() : fallbackRender);
  } else {
    nodes = this.$slots[name] || (isFunction$1(fallbackRender) ? fallbackRender() : fallbackRender);
  }
  var target2 = props2 && props2.slot;
  if (target2) {
    return this.$createElement("template", { slot: target2 }, nodes);
  } else {
    return nodes;
  }
}
function resolveFilter(id) {
  return resolveAsset(this.$options, "filters", id) || identity;
}
function isKeyNotMatch(expect, actual) {
  if (isArray$1(expect)) {
    return expect.indexOf(actual) === -1;
  } else {
    return expect !== actual;
  }
}
function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
  var mappedKeyCode = config$1.keyCodes[key] || builtInKeyCode;
  if (builtInKeyName && eventKeyName && !config$1.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName);
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode);
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
  return eventKeyCode === void 0;
}
function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject$2(value)) ;
    else {
      if (isArray$1(value)) {
        value = toObject(value);
      }
      var hash2 = void 0;
      var _loop_1 = function(key2) {
        if (key2 === "class" || key2 === "style" || isReservedAttribute(key2)) {
          hash2 = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash2 = asProp || config$1.mustUseProp(tag, type, key2) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }
        var camelizedKey = camelize(key2);
        var hyphenatedKey = hyphenate(key2);
        if (!(camelizedKey in hash2) && !(hyphenatedKey in hash2)) {
          hash2[key2] = value[key2];
          if (isSync) {
            var on = data.on || (data.on = {});
            on["update:".concat(key2)] = function($event) {
              value[key2] = $event;
            };
          }
        }
      };
      for (var key in value) {
        _loop_1(key);
      }
    }
  }
  return data;
}
function renderStatic(index2, isInFor) {
  var cached2 = this._staticTrees || (this._staticTrees = []);
  var tree = cached2[index2];
  if (tree && !isInFor) {
    return tree;
  }
  tree = cached2[index2] = this.$options.staticRenderFns[index2].call(
    this._renderProxy,
    this._c,
    this
    // for render fns generated for functional component templates
  );
  markStatic(tree, "__static__".concat(index2), false);
  return tree;
}
function markOnce(tree, index2, key) {
  markStatic(tree, "__once__".concat(index2).concat(key ? "_".concat(key) : ""), true);
  return tree;
}
function markStatic(tree, key, isOnce) {
  if (isArray$1(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== "string") {
        markStaticNode(tree[i], "".concat(key, "_").concat(i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}
function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}
function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject$1(value)) ;
    else {
      var on = data.on = data.on ? extend$1({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data;
}
function resolveScopedSlots(fns, res, hasDynamicKeys, contentHashKey) {
  res = res || { $stable: !hasDynamicKeys };
  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];
    if (isArray$1(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      if (slot.proxy) {
        slot.fn.proxy = true;
      }
      res[slot.key] = slot.fn;
    }
  }
  if (contentHashKey) {
    res.$key = contentHashKey;
  }
  return res;
}
function bindDynamicKeys(baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];
    if (typeof key === "string" && key) {
      baseObj[values[i]] = values[i + 1];
    }
  }
  return baseObj;
}
function prependModifier(value, symbol) {
  return typeof value === "string" ? symbol + value : value;
}
function installRenderHelpers(target2) {
  target2._o = markOnce;
  target2._n = toNumber;
  target2._s = toString$2;
  target2._l = renderList;
  target2._t = renderSlot;
  target2._q = looseEqual;
  target2._i = looseIndexOf;
  target2._m = renderStatic;
  target2._f = resolveFilter;
  target2._k = checkKeyCodes;
  target2._b = bindObjectProps;
  target2._v = createTextVNode;
  target2._e = createEmptyVNode;
  target2._u = resolveScopedSlots;
  target2._g = bindObjectListeners;
  target2._d = bindDynamicKeys;
  target2._p = prependModifier;
}
function resolveSlots(children, context) {
  if (!children || !children.length) {
    return {};
  }
  var slots = {};
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name_1 = data.slot;
      var slot = slots[name_1] || (slots[name_1] = []);
      if (child.tag === "template") {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  for (var name_2 in slots) {
    if (slots[name_2].every(isWhitespace)) {
      delete slots[name_2];
    }
  }
  return slots;
}
function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === " ";
}
function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}
function normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;
  var key = scopedSlots && scopedSlots.$key;
  if (!scopedSlots) {
    res = {};
  } else if (scopedSlots._normalized) {
    return scopedSlots._normalized;
  } else if (isStable && prevScopedSlots && prevScopedSlots !== emptyObject && key === prevScopedSlots.$key && !hasNormalSlots && !prevScopedSlots.$hasNormal) {
    return prevScopedSlots;
  } else {
    res = {};
    for (var key_1 in scopedSlots) {
      if (scopedSlots[key_1] && key_1[0] !== "$") {
        res[key_1] = normalizeScopedSlot(ownerVm, normalSlots, key_1, scopedSlots[key_1]);
      }
    }
  }
  for (var key_2 in normalSlots) {
    if (!(key_2 in res)) {
      res[key_2] = proxyNormalSlot(normalSlots, key_2);
    }
  }
  if (scopedSlots && Object.isExtensible(scopedSlots)) {
    scopedSlots._normalized = res;
  }
  def(res, "$stable", isStable);
  def(res, "$key", key);
  def(res, "$hasNormal", hasNormalSlots);
  return res;
}
function normalizeScopedSlot(vm, normalSlots, key, fn) {
  var normalized = function() {
    var cur = currentInstance;
    setCurrentInstance(vm);
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === "object" && !isArray$1(res) ? [res] : normalizeChildren(res);
    var vnode = res && res[0];
    setCurrentInstance(cur);
    return res && (!vnode || res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode)) ? void 0 : res;
  };
  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }
  return normalized;
}
function proxyNormalSlot(slots, key) {
  return function() {
    return slots[key];
  };
}
function initSetup(vm) {
  var options = vm.$options;
  var setup = options.setup;
  if (setup) {
    var ctx = vm._setupContext = createSetupContext(vm);
    setCurrentInstance(vm);
    pushTarget();
    var setupResult = invokeWithErrorHandling(setup, null, [vm._props || shallowReactive({}), ctx], vm, "setup");
    popTarget();
    setCurrentInstance();
    if (isFunction$1(setupResult)) {
      options.render = setupResult;
    } else if (isObject$2(setupResult)) {
      vm._setupState = setupResult;
      if (!setupResult.__sfc) {
        for (var key in setupResult) {
          if (!isReserved(key)) {
            proxyWithRefUnwrap(vm, setupResult, key);
          }
        }
      } else {
        var proxy2 = vm._setupProxy = {};
        for (var key in setupResult) {
          if (key !== "__sfc") {
            proxyWithRefUnwrap(proxy2, setupResult, key);
          }
        }
      }
    } else ;
  }
}
function createSetupContext(vm) {
  return {
    get attrs() {
      if (!vm._attrsProxy) {
        var proxy2 = vm._attrsProxy = {};
        def(proxy2, "_v_attr_proxy", true);
        syncSetupProxy(proxy2, vm.$attrs, emptyObject, vm, "$attrs");
      }
      return vm._attrsProxy;
    },
    get listeners() {
      if (!vm._listenersProxy) {
        var proxy2 = vm._listenersProxy = {};
        syncSetupProxy(proxy2, vm.$listeners, emptyObject, vm, "$listeners");
      }
      return vm._listenersProxy;
    },
    get slots() {
      return initSlotsProxy(vm);
    },
    emit: bind$2(vm.$emit, vm),
    expose: function(exposed) {
      if (exposed) {
        Object.keys(exposed).forEach(function(key) {
          return proxyWithRefUnwrap(vm, exposed, key);
        });
      }
    }
  };
}
function syncSetupProxy(to, from, prev, instance, type) {
  var changed = false;
  for (var key in from) {
    if (!(key in to)) {
      changed = true;
      defineProxyAttr(to, key, instance, type);
    } else if (from[key] !== prev[key]) {
      changed = true;
    }
  }
  for (var key in to) {
    if (!(key in from)) {
      changed = true;
      delete to[key];
    }
  }
  return changed;
}
function defineProxyAttr(proxy2, key, instance, type) {
  Object.defineProperty(proxy2, key, {
    enumerable: true,
    configurable: true,
    get: function() {
      return instance[type][key];
    }
  });
}
function initSlotsProxy(vm) {
  if (!vm._slotsProxy) {
    syncSetupSlots(vm._slotsProxy = {}, vm.$scopedSlots);
  }
  return vm._slotsProxy;
}
function syncSetupSlots(to, from) {
  for (var key in from) {
    to[key] = from[key];
  }
  for (var key in to) {
    if (!(key in from)) {
      delete to[key];
    }
  }
}
function initRender(vm) {
  vm._vnode = null;
  vm._staticTrees = null;
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode;
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = parentVnode ? normalizeScopedSlots(vm.$parent, parentVnode.data.scopedSlots, vm.$slots) : emptyObject;
  vm._c = function(a, b, c, d) {
    return createElement$1(vm, a, b, c, d, false);
  };
  vm.$createElement = function(a, b, c, d) {
    return createElement$1(vm, a, b, c, d, true);
  };
  var parentData = parentVnode && parentVnode.data;
  {
    defineReactive(vm, "$attrs", parentData && parentData.attrs || emptyObject, null, true);
    defineReactive(vm, "$listeners", options._parentListeners || emptyObject, null, true);
  }
}
var currentRenderingInstance = null;
function renderMixin(Vue2) {
  installRenderHelpers(Vue2.prototype);
  Vue2.prototype.$nextTick = function(fn) {
    return nextTick(fn, this);
  };
  Vue2.prototype._render = function() {
    var vm = this;
    var _a2 = vm.$options, render66 = _a2.render, _parentVnode = _a2._parentVnode;
    if (_parentVnode && vm._isMounted) {
      vm.$scopedSlots = normalizeScopedSlots(vm.$parent, _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
      if (vm._slotsProxy) {
        syncSetupSlots(vm._slotsProxy, vm.$scopedSlots);
      }
    }
    vm.$vnode = _parentVnode;
    var prevInst = currentInstance;
    var prevRenderInst = currentRenderingInstance;
    var vnode;
    try {
      setCurrentInstance(vm);
      currentRenderingInstance = vm;
      vnode = render66.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = prevRenderInst;
      setCurrentInstance(prevInst);
    }
    if (isArray$1(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    }
    if (!(vnode instanceof VNode)) {
      vnode = createEmptyVNode();
    }
    vnode.parent = _parentVnode;
    return vnode;
  };
}
function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === "Module") {
    comp = comp.default;
  }
  return isObject$2(comp) ? base.extend(comp) : comp;
}
function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data, context, children, tag };
  return node;
}
function resolveAsyncComponent(factory, baseCtor) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }
  if (isDef(factory.resolved)) {
    return factory.resolved;
  }
  var owner = currentRenderingInstance;
  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    factory.owners.push(owner);
  }
  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }
  if (owner && !isDef(factory.owners)) {
    var owners_1 = factory.owners = [owner];
    var sync_1 = true;
    var timerLoading_1 = null;
    var timerTimeout_1 = null;
    owner.$on("hook:destroyed", function() {
      return remove$2(owners_1, owner);
    });
    var forceRender_1 = function(renderCompleted) {
      for (var i = 0, l = owners_1.length; i < l; i++) {
        owners_1[i].$forceUpdate();
      }
      if (renderCompleted) {
        owners_1.length = 0;
        if (timerLoading_1 !== null) {
          clearTimeout(timerLoading_1);
          timerLoading_1 = null;
        }
        if (timerTimeout_1 !== null) {
          clearTimeout(timerTimeout_1);
          timerTimeout_1 = null;
        }
      }
    };
    var resolve = once(function(res) {
      factory.resolved = ensureCtor(res, baseCtor);
      if (!sync_1) {
        forceRender_1(true);
      } else {
        owners_1.length = 0;
      }
    });
    var reject_1 = once(function(reason) {
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender_1(true);
      }
    });
    var res_1 = factory(resolve, reject_1);
    if (isObject$2(res_1)) {
      if (isPromise(res_1)) {
        if (isUndef(factory.resolved)) {
          res_1.then(resolve, reject_1);
        }
      } else if (isPromise(res_1.component)) {
        res_1.component.then(resolve, reject_1);
        if (isDef(res_1.error)) {
          factory.errorComp = ensureCtor(res_1.error, baseCtor);
        }
        if (isDef(res_1.loading)) {
          factory.loadingComp = ensureCtor(res_1.loading, baseCtor);
          if (res_1.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading_1 = setTimeout(function() {
              timerLoading_1 = null;
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender_1(false);
              }
            }, res_1.delay || 200);
          }
        }
        if (isDef(res_1.timeout)) {
          timerTimeout_1 = setTimeout(function() {
            timerTimeout_1 = null;
            if (isUndef(factory.resolved)) {
              reject_1(null);
            }
          }, res_1.timeout);
        }
      }
    }
    sync_1 = false;
    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}
function getFirstComponentChild(children) {
  if (isArray$1(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}
var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;
function createElement$1(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (isArray$1(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = void 0;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType);
}
function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
    return createEmptyVNode();
  }
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    return createEmptyVNode();
  }
  if (isArray$1(children) && isFunction$1(children[0])) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === "string") {
    var Ctor = void 0;
    ns = context.$vnode && context.$vnode.ns || config$1.getTagNamespace(tag);
    if (config$1.isReservedTag(tag)) {
      vnode = new VNode(config$1.parsePlatformTagName(tag), data, children, void 0, void 0, context);
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, "components", tag))) {
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      vnode = new VNode(tag, data, children, void 0, void 0, context);
    }
  } else {
    vnode = createComponent(tag, data, context, children);
  }
  if (isArray$1(vnode)) {
    return vnode;
  } else if (isDef(vnode)) {
    if (isDef(ns))
      applyNS(vnode, ns);
    if (isDef(data))
      registerDeepBindings(data);
    return vnode;
  } else {
    return createEmptyVNode();
  }
}
function applyNS(vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === "foreignObject") {
    ns = void 0;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== "svg")) {
        applyNS(child, ns, force);
      }
    }
  }
}
function registerDeepBindings(data) {
  if (isObject$2(data.style)) {
    traverse(data.style);
  }
  if (isObject$2(data.class)) {
    traverse(data.class);
  }
}
function handleError(err, vm, info) {
  pushTarget();
  try {
    if (vm) {
      var cur = vm;
      while (cur = cur.$parent) {
        var hooks2 = cur.$options.errorCaptured;
        if (hooks2) {
          for (var i = 0; i < hooks2.length; i++) {
            try {
              var capture = hooks2[i].call(cur, err, vm, info) === false;
              if (capture)
                return;
            } catch (e) {
              globalHandleError(e, cur, "errorCaptured hook");
            }
          }
        }
      }
    }
    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}
function invokeWithErrorHandling(handler, context, args, vm, info) {
  var res;
  try {
    res = args ? handler.apply(context, args) : handler.call(context);
    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function(e) {
        return handleError(e, vm, info + " (Promise/async)");
      });
      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }
  return res;
}
function globalHandleError(err, vm, info) {
  if (config$1.errorHandler) {
    try {
      return config$1.errorHandler.call(null, err, vm, info);
    } catch (e) {
      if (e !== err) {
        logError(e);
      }
    }
  }
  logError(err);
}
function logError(err, vm, info) {
  if (inBrowser && typeof console !== "undefined") {
    console.error(err);
  } else {
    throw err;
  }
}
var isUsingMicroTask = false;
var callbacks = [];
var pending = false;
function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}
var timerFunc;
if (typeof Promise !== "undefined" && isNative(Promise)) {
  var p_1 = Promise.resolve();
  timerFunc = function() {
    p_1.then(flushCallbacks);
    if (isIOS$1)
      setTimeout(noop$3);
  };
  isUsingMicroTask = true;
} else if (!isIE$1 && typeof MutationObserver !== "undefined" && (isNative(MutationObserver) || // PhantomJS and iOS 7.x
MutationObserver.toString() === "[object MutationObserverConstructor]")) {
  var counter_1 = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode_1 = document.createTextNode(String(counter_1));
  observer.observe(textNode_1, {
    characterData: true
  });
  timerFunc = function() {
    counter_1 = (counter_1 + 1) % 2;
    textNode_1.data = String(counter_1);
  };
  isUsingMicroTask = true;
} else if (typeof setImmediate !== "undefined" && isNative(setImmediate)) {
  timerFunc = function() {
    setImmediate(flushCallbacks);
  };
} else {
  timerFunc = function() {
    setTimeout(flushCallbacks, 0);
  };
}
function nextTick(cb, ctx) {
  var _resolve;
  callbacks.push(function() {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, "nextTick");
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    timerFunc();
  }
  if (!cb && typeof Promise !== "undefined") {
    return new Promise(function(resolve) {
      _resolve = resolve;
    });
  }
}
function useCssVars(getter) {
  if (!inBrowser && true)
    return;
  var instance = currentInstance;
  if (!instance) {
    return;
  }
  watchPostEffect(function() {
    var el = instance.$el;
    var vars = getter(instance, instance._setupProxy);
    if (el && el.nodeType === 1) {
      var style2 = el.style;
      for (var key in vars) {
        style2.setProperty("--".concat(key), vars[key]);
      }
    }
  });
}
function createLifeCycle(hookName) {
  return function(fn, target2) {
    if (target2 === void 0) {
      target2 = currentInstance;
    }
    if (!target2) {
      return;
    }
    return injectHook(target2, hookName, fn);
  };
}
function injectHook(instance, hookName, fn) {
  var options = instance.$options;
  options[hookName] = mergeLifecycleHook(options[hookName], fn);
}
var onMounted = createLifeCycle("mounted");
var onUnmounted = createLifeCycle("destroyed");
var version = "2.7.16";
function defineComponent(options) {
  return options;
}
var seenObjects = new _Set();
function traverse(val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
  return val;
}
function _traverse(val, seen) {
  var i, keys;
  var isA = isArray$1(val);
  if (!isA && !isObject$2(val) || val.__v_skip || Object.isFrozen(val) || val instanceof VNode) {
    return;
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return;
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--)
      _traverse(val[i], seen);
  } else if (isRef(val)) {
    _traverse(val.value, seen);
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--)
      _traverse(val[keys[i]], seen);
  }
}
var uid$1 = 0;
var Watcher = (
  /** @class */
  function() {
    function Watcher2(vm, expOrFn, cb, options, isRenderWatcher) {
      recordEffectScope(
        this,
        // if the active effect scope is manually created (not a component scope),
        // prioritize it
        activeEffectScope && !activeEffectScope._vm ? activeEffectScope : vm ? vm._scope : void 0
      );
      if ((this.vm = vm) && isRenderWatcher) {
        vm._watcher = this;
      }
      if (options) {
        this.deep = !!options.deep;
        this.user = !!options.user;
        this.lazy = !!options.lazy;
        this.sync = !!options.sync;
        this.before = options.before;
      } else {
        this.deep = this.user = this.lazy = this.sync = false;
      }
      this.cb = cb;
      this.id = ++uid$1;
      this.active = true;
      this.post = false;
      this.dirty = this.lazy;
      this.deps = [];
      this.newDeps = [];
      this.depIds = new _Set();
      this.newDepIds = new _Set();
      this.expression = "";
      if (isFunction$1(expOrFn)) {
        this.getter = expOrFn;
      } else {
        this.getter = parsePath(expOrFn);
        if (!this.getter) {
          this.getter = noop$3;
        }
      }
      this.value = this.lazy ? void 0 : this.get();
    }
    Watcher2.prototype.get = function() {
      pushTarget(this);
      var value;
      var vm = this.vm;
      try {
        value = this.getter.call(vm, vm);
      } catch (e) {
        if (this.user) {
          handleError(e, vm, 'getter for watcher "'.concat(this.expression, '"'));
        } else {
          throw e;
        }
      } finally {
        if (this.deep) {
          traverse(value);
        }
        popTarget();
        this.cleanupDeps();
      }
      return value;
    };
    Watcher2.prototype.addDep = function(dep) {
      var id = dep.id;
      if (!this.newDepIds.has(id)) {
        this.newDepIds.add(id);
        this.newDeps.push(dep);
        if (!this.depIds.has(id)) {
          dep.addSub(this);
        }
      }
    };
    Watcher2.prototype.cleanupDeps = function() {
      var i = this.deps.length;
      while (i--) {
        var dep = this.deps[i];
        if (!this.newDepIds.has(dep.id)) {
          dep.removeSub(this);
        }
      }
      var tmp = this.depIds;
      this.depIds = this.newDepIds;
      this.newDepIds = tmp;
      this.newDepIds.clear();
      tmp = this.deps;
      this.deps = this.newDeps;
      this.newDeps = tmp;
      this.newDeps.length = 0;
    };
    Watcher2.prototype.update = function() {
      if (this.lazy) {
        this.dirty = true;
      } else if (this.sync) {
        this.run();
      } else {
        queueWatcher(this);
      }
    };
    Watcher2.prototype.run = function() {
      if (this.active) {
        var value = this.get();
        if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        isObject$2(value) || this.deep) {
          var oldValue = this.value;
          this.value = value;
          if (this.user) {
            var info = 'callback for watcher "'.concat(this.expression, '"');
            invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
          } else {
            this.cb.call(this.vm, value, oldValue);
          }
        }
      }
    };
    Watcher2.prototype.evaluate = function() {
      this.value = this.get();
      this.dirty = false;
    };
    Watcher2.prototype.depend = function() {
      var i = this.deps.length;
      while (i--) {
        this.deps[i].depend();
      }
    };
    Watcher2.prototype.teardown = function() {
      if (this.vm && !this.vm._isBeingDestroyed) {
        remove$2(this.vm._scope.effects, this);
      }
      if (this.active) {
        var i = this.deps.length;
        while (i--) {
          this.deps[i].removeSub(this);
        }
        this.active = false;
        if (this.onStop) {
          this.onStop();
        }
      }
    };
    return Watcher2;
  }()
);
function initEvents(vm) {
  vm._events = /* @__PURE__ */ Object.create(null);
  vm._hasHookEvent = false;
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}
var target$1;
function add$1(event, fn) {
  target$1.$on(event, fn);
}
function remove$1(event, fn) {
  target$1.$off(event, fn);
}
function createOnceHandler$1(event, fn) {
  var _target = target$1;
  return function onceHandler() {
    var res = fn.apply(null, arguments);
    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  };
}
function updateComponentListeners(vm, listeners, oldListeners) {
  target$1 = vm;
  updateListeners(listeners, oldListeners || {}, add$1, remove$1, createOnceHandler$1, vm);
  target$1 = void 0;
}
function eventsMixin(Vue2) {
  var hookRE = /^hook:/;
  Vue2.prototype.$on = function(event, fn) {
    var vm = this;
    if (isArray$1(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm;
  };
  Vue2.prototype.$once = function(event, fn) {
    var vm = this;
    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };
  Vue2.prototype.$off = function(event, fn) {
    var vm = this;
    if (!arguments.length) {
      vm._events = /* @__PURE__ */ Object.create(null);
      return vm;
    }
    if (isArray$1(event)) {
      for (var i_1 = 0, l = event.length; i_1 < l; i_1++) {
        vm.$off(event[i_1], fn);
      }
      return vm;
    }
    var cbs = vm._events[event];
    if (!cbs) {
      return vm;
    }
    if (!fn) {
      vm._events[event] = null;
      return vm;
    }
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }
    return vm;
  };
  Vue2.prototype.$emit = function(event) {
    var vm = this;
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray$1(cbs) : cbs;
      var args = toArray$1(arguments, 1);
      var info = 'event handler for "'.concat(event, '"');
      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }
    return vm;
  };
}
var activeInstance = null;
function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function() {
    activeInstance = prevActiveInstance;
  };
}
function initLifecycle(vm) {
  var options = vm.$options;
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }
  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;
  vm.$children = [];
  vm.$refs = {};
  vm._provided = parent ? parent._provided : /* @__PURE__ */ Object.create(null);
  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}
function lifecycleMixin(Vue2) {
  Vue2.prototype._update = function(vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode;
    if (!prevVnode) {
      vm.$el = vm.__patch__(
        vm.$el,
        vnode,
        hydrating,
        false
        /* removeOnly */
      );
    } else {
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    restoreActiveInstance();
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    var wrapper = vm;
    while (wrapper && wrapper.$vnode && wrapper.$parent && wrapper.$vnode === wrapper.$parent._vnode) {
      wrapper.$parent.$el = wrapper.$el;
      wrapper = wrapper.$parent;
    }
  };
  Vue2.prototype.$forceUpdate = function() {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };
  Vue2.prototype.$destroy = function() {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return;
    }
    callHook$1(vm, "beforeDestroy");
    vm._isBeingDestroyed = true;
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove$2(parent.$children, vm);
    }
    vm._scope.stop();
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    vm._isDestroyed = true;
    vm.__patch__(vm._vnode, null);
    callHook$1(vm, "destroyed");
    vm.$off();
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}
function mountComponent(vm, el, hydrating) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
  }
  callHook$1(vm, "beforeMount");
  var updateComponent;
  {
    updateComponent = function() {
      vm._update(vm._render(), hydrating);
    };
  }
  var watcherOptions = {
    before: function() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook$1(vm, "beforeUpdate");
      }
    }
  };
  new Watcher(
    vm,
    updateComponent,
    noop$3,
    watcherOptions,
    true
    /* isRenderWatcher */
  );
  hydrating = false;
  var preWatchers = vm._preWatchers;
  if (preWatchers) {
    for (var i = 0; i < preWatchers.length; i++) {
      preWatchers[i].run();
    }
  }
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook$1(vm, "mounted");
  }
  return vm;
}
function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key || !newScopedSlots && vm.$scopedSlots.$key);
  var needsForceUpdate = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  hasDynamicScopedSlot);
  var prevVNode = vm.$vnode;
  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode;
  if (vm._vnode) {
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;
  var attrs2 = parentVnode.data.attrs || emptyObject;
  if (vm._attrsProxy) {
    if (syncSetupProxy(vm._attrsProxy, attrs2, prevVNode.data && prevVNode.data.attrs || emptyObject, vm, "$attrs")) {
      needsForceUpdate = true;
    }
  }
  vm.$attrs = attrs2;
  listeners = listeners || emptyObject;
  var prevListeners = vm.$options._parentListeners;
  if (vm._listenersProxy) {
    syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, "$listeners");
  }
  vm.$listeners = vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, prevListeners);
  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props2 = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props;
      props2[key] = validateProp(key, propOptions, propsData, vm);
    }
    toggleObserving(true);
    vm.$options.propsData = propsData;
  }
  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }
}
function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive)
      return true;
  }
  return false;
}
function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook$1(vm, "activated");
  }
}
function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return;
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook$1(vm, "deactivated");
  }
}
function callHook$1(vm, hook, args, setContext) {
  if (setContext === void 0) {
    setContext = true;
  }
  pushTarget();
  var prevInst = currentInstance;
  var prevScope = getCurrentScope();
  setContext && setCurrentInstance(vm);
  var handlers = vm.$options[hook];
  var info = "".concat(hook, " hook");
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit("hook:" + hook);
  }
  if (setContext) {
    setCurrentInstance(prevInst);
    prevScope && prevScope.on();
  }
  popTarget();
}
var queue$1 = [];
var activatedChildren = [];
var has = {};
var waiting = false;
var flushing = false;
var index = 0;
function resetSchedulerState() {
  index = queue$1.length = activatedChildren.length = 0;
  has = {};
  waiting = flushing = false;
}
var currentFlushTimestamp = 0;
var getNow = Date.now;
if (inBrowser && !isIE$1) {
  var performance_1 = window.performance;
  if (performance_1 && typeof performance_1.now === "function" && getNow() > document.createEvent("Event").timeStamp) {
    getNow = function() {
      return performance_1.now();
    };
  }
}
var sortCompareFn = function(a, b) {
  if (a.post) {
    if (!b.post)
      return 1;
  } else if (b.post) {
    return -1;
  }
  return a.id - b.id;
};
function flushSchedulerQueue() {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id;
  queue$1.sort(sortCompareFn);
  for (index = 0; index < queue$1.length; index++) {
    watcher = queue$1[index];
    if (watcher.before) {
      watcher.before();
    }
    id = watcher.id;
    has[id] = null;
    watcher.run();
  }
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue$1.slice();
  resetSchedulerState();
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);
  cleanupDeps();
  if (devtools && config$1.devtools) {
    devtools.emit("flush");
  }
}
function callUpdatedHooks(queue2) {
  var i = queue2.length;
  while (i--) {
    var watcher = queue2[i];
    var vm = watcher.vm;
    if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook$1(vm, "updated");
    }
  }
}
function queueActivatedComponent(vm) {
  vm._inactive = false;
  activatedChildren.push(vm);
}
function callActivatedHooks(queue2) {
  for (var i = 0; i < queue2.length; i++) {
    queue2[i]._inactive = true;
    activateChildComponent(
      queue2[i],
      true
      /* true */
    );
  }
}
function queueWatcher(watcher) {
  var id = watcher.id;
  if (has[id] != null) {
    return;
  }
  if (watcher === Dep.target && watcher.noRecurse) {
    return;
  }
  has[id] = true;
  if (!flushing) {
    queue$1.push(watcher);
  } else {
    var i = queue$1.length - 1;
    while (i > index && queue$1[i].id > watcher.id) {
      i--;
    }
    queue$1.splice(i + 1, 0, watcher);
  }
  if (!waiting) {
    waiting = true;
    nextTick(flushSchedulerQueue);
  }
}
function initProvide(vm) {
  var provideOption = vm.$options.provide;
  if (provideOption) {
    var provided = isFunction$1(provideOption) ? provideOption.call(vm) : provideOption;
    if (!isObject$2(provided)) {
      return;
    }
    var source = resolveProvided(vm);
    var keys = hasSymbol ? Reflect.ownKeys(provided) : Object.keys(provided);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      Object.defineProperty(source, key, Object.getOwnPropertyDescriptor(provided, key));
    }
  }
}
function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function(key) {
      {
        defineReactive(vm, key, result[key]);
      }
    });
    toggleObserving(true);
  }
}
function resolveInject(inject2, vm) {
  if (inject2) {
    var result = /* @__PURE__ */ Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject2) : Object.keys(inject2);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (key === "__ob__")
        continue;
      var provideKey = inject2[key].from;
      if (provideKey in vm._provided) {
        result[key] = vm._provided[provideKey];
      } else if ("default" in inject2[key]) {
        var provideDefault = inject2[key].default;
        result[key] = isFunction$1(provideDefault) ? provideDefault.call(vm) : provideDefault;
      } else ;
    }
    return result;
  }
}
function FunctionalRenderContext(data, props2, children, parent, Ctor) {
  var _this = this;
  var options = Ctor.options;
  var contextVm;
  if (hasOwn(parent, "_uid")) {
    contextVm = Object.create(parent);
    contextVm._original = parent;
  } else {
    contextVm = parent;
    parent = parent._original;
  }
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;
  this.data = data;
  this.props = props2;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function() {
    if (!_this.$slots) {
      normalizeScopedSlots(parent, data.scopedSlots, _this.$slots = resolveSlots(children, parent));
    }
    return _this.$slots;
  };
  Object.defineProperty(this, "scopedSlots", {
    enumerable: true,
    get: function() {
      return normalizeScopedSlots(parent, data.scopedSlots, this.slots());
    }
  });
  if (isCompiled) {
    this.$options = options;
    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);
  }
  if (options._scopeId) {
    this._c = function(a, b, c, d) {
      var vnode = createElement$1(contextVm, a, b, c, d, needNormalization);
      if (vnode && !isArray$1(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode;
    };
  } else {
    this._c = function(a, b, c, d) {
      return createElement$1(contextVm, a, b, c, d, needNormalization);
    };
  }
}
installRenderHelpers(FunctionalRenderContext.prototype);
function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props2 = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props2[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs))
      mergeProps(props2, data.attrs);
    if (isDef(data.props))
      mergeProps(props2, data.props);
  }
  var renderContext = new FunctionalRenderContext(data, props2, children, contextVm, Ctor);
  var vnode = options.render.call(null, renderContext._c, renderContext);
  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options);
  } else if (isArray$1(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);
    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options);
    }
    return res;
  }
}
function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
  var clone2 = cloneVNode(vnode);
  clone2.fnContext = contextVm;
  clone2.fnOptions = options;
  if (data.slot) {
    (clone2.data || (clone2.data = {})).slot = data.slot;
  }
  return clone2;
}
function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}
function getComponentName(options) {
  return options.name || options.__name || options._componentTag;
}
var componentVNodeHooks = {
  init: function(vnode, hydrating) {
    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
      var mountedNode = vnode;
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
      child.$mount(hydrating ? vnode.elm : void 0, hydrating);
    }
  },
  prepatch: function(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData,
      // updated props
      options.listeners,
      // updated listeners
      vnode,
      // new parent vnode
      options.children
      // new children
    );
  },
  insert: function(vnode) {
    var context = vnode.context, componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook$1(componentInstance, "mounted");
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(
          componentInstance,
          true
          /* direct */
        );
      }
    }
  },
  destroy: function(vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(
          componentInstance,
          true
          /* direct */
        );
      }
    }
  }
};
var hooksToMerge = Object.keys(componentVNodeHooks);
function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }
  var baseCtor = context.$options._base;
  if (isObject$2(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }
  if (typeof Ctor !== "function") {
    return;
  }
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
    if (Ctor === void 0) {
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }
  data = data || {};
  resolveConstructorOptions(Ctor);
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }
  var propsData = extractPropsFromVNodeData(data, Ctor);
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  }
  var listeners = data.on;
  data.on = data.nativeOn;
  if (isTrue(Ctor.options.abstract)) {
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }
  installComponentHooks(data);
  var name = getComponentName(Ctor.options) || tag;
  var vnode = new VNode(
    // @ts-expect-error
    "vue-component-".concat(Ctor.cid).concat(name ? "-".concat(name) : ""),
    data,
    void 0,
    void 0,
    void 0,
    context,
    // @ts-expect-error
    { Ctor, propsData, listeners, tag, children },
    asyncFactory
  );
  return vnode;
}
function createComponentInstanceForVnode(vnode, parent) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent
  };
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options);
}
function installComponentHooks(data) {
  var hooks2 = data.hook || (data.hook = {});
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks2[key];
    var toMerge = componentVNodeHooks[key];
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks2[key] = existing ? mergeHook(toMerge, existing) : toMerge;
    }
  }
}
function mergeHook(f1, f2) {
  var merged = function(a, b) {
    f1(a, b);
    f2(a, b);
  };
  merged._merged = true;
  return merged;
}
function transformModel(options, data) {
  var prop = options.model && options.model.prop || "value";
  var event = options.model && options.model.event || "input";
  (data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;
  if (isDef(existing)) {
    if (isArray$1(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}
var warn = noop$3;
var strats = config$1.optionMergeStrategies;
function mergeData(to, from, recursive) {
  if (recursive === void 0) {
    recursive = true;
  }
  if (!from)
    return to;
  var key, toVal, fromVal;
  var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    if (key === "__ob__")
      continue;
    toVal = to[key];
    fromVal = from[key];
    if (!recursive || !hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (toVal !== fromVal && isPlainObject$1(toVal) && isPlainObject$1(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to;
}
function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    if (!childVal) {
      return parentVal;
    }
    if (!parentVal) {
      return childVal;
    }
    return function mergedDataFn() {
      return mergeData(isFunction$1(childVal) ? childVal.call(this, this) : childVal, isFunction$1(parentVal) ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      var instanceData = isFunction$1(childVal) ? childVal.call(vm, vm) : childVal;
      var defaultData = isFunction$1(parentVal) ? parentVal.call(vm, vm) : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}
strats.data = function(parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== "function") {
      return parentVal;
    }
    return mergeDataOrFn(parentVal, childVal);
  }
  return mergeDataOrFn(parentVal, childVal, vm);
};
function mergeLifecycleHook(parentVal, childVal) {
  var res = childVal ? parentVal ? parentVal.concat(childVal) : isArray$1(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}
function dedupeHooks(hooks2) {
  var res = [];
  for (var i = 0; i < hooks2.length; i++) {
    if (res.indexOf(hooks2[i]) === -1) {
      res.push(hooks2[i]);
    }
  }
  return res;
}
LIFECYCLE_HOOKS.forEach(function(hook) {
  strats[hook] = mergeLifecycleHook;
});
function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);
  if (childVal) {
    return extend$1(res, childVal);
  } else {
    return res;
  }
}
ASSET_TYPES.forEach(function(type) {
  strats[type + "s"] = mergeAssets;
});
strats.watch = function(parentVal, childVal, vm, key) {
  if (parentVal === nativeWatch)
    parentVal = void 0;
  if (childVal === nativeWatch)
    childVal = void 0;
  if (!childVal)
    return Object.create(parentVal || null);
  if (!parentVal)
    return childVal;
  var ret = {};
  extend$1(ret, parentVal);
  for (var key_1 in childVal) {
    var parent_1 = ret[key_1];
    var child = childVal[key_1];
    if (parent_1 && !isArray$1(parent_1)) {
      parent_1 = [parent_1];
    }
    ret[key_1] = parent_1 ? parent_1.concat(child) : isArray$1(child) ? child : [child];
  }
  return ret;
};
strats.props = strats.methods = strats.inject = strats.computed = function(parentVal, childVal, vm, key) {
  if (!parentVal)
    return childVal;
  var ret = /* @__PURE__ */ Object.create(null);
  extend$1(ret, parentVal);
  if (childVal)
    extend$1(ret, childVal);
  return ret;
};
strats.provide = function(parentVal, childVal) {
  if (!parentVal)
    return childVal;
  return function() {
    var ret = /* @__PURE__ */ Object.create(null);
    mergeData(ret, isFunction$1(parentVal) ? parentVal.call(this) : parentVal);
    if (childVal) {
      mergeData(
        ret,
        isFunction$1(childVal) ? childVal.call(this) : childVal,
        false
        // non-recursive
      );
    }
    return ret;
  };
};
var defaultStrat = function(parentVal, childVal) {
  return childVal === void 0 ? parentVal : childVal;
};
function normalizeProps(options, vm) {
  var props2 = options.props;
  if (!props2)
    return;
  var res = {};
  var i, val, name;
  if (isArray$1(props2)) {
    i = props2.length;
    while (i--) {
      val = props2[i];
      if (typeof val === "string") {
        name = camelize(val);
        res[name] = { type: null };
      }
    }
  } else if (isPlainObject$1(props2)) {
    for (var key in props2) {
      val = props2[key];
      name = camelize(key);
      res[name] = isPlainObject$1(val) ? val : { type: val };
    }
  } else ;
  options.props = res;
}
function normalizeInject(options, vm) {
  var inject2 = options.inject;
  if (!inject2)
    return;
  var normalized = options.inject = {};
  if (isArray$1(inject2)) {
    for (var i = 0; i < inject2.length; i++) {
      normalized[inject2[i]] = { from: inject2[i] };
    }
  } else if (isPlainObject$1(inject2)) {
    for (var key in inject2) {
      var val = inject2[key];
      normalized[key] = isPlainObject$1(val) ? extend$1({ from: key }, val) : { from: val };
    }
  } else ;
}
function normalizeDirectives$1(options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def2 = dirs[key];
      if (isFunction$1(def2)) {
        dirs[key] = { bind: def2, update: def2 };
      }
    }
  }
}
function mergeOptions(parent, child, vm) {
  if (isFunction$1(child)) {
    child = child.options;
  }
  normalizeProps(child);
  normalizeInject(child);
  normalizeDirectives$1(child);
  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField(key2) {
    var strat = strats[key2] || defaultStrat;
    options[key2] = strat(parent[key2], child[key2], vm, key2);
  }
  return options;
}
function resolveAsset(options, type, id, warnMissing) {
  if (typeof id !== "string") {
    return;
  }
  var assets = options[type];
  if (hasOwn(assets, id))
    return assets[id];
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId))
    return assets[camelizedId];
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId))
    return assets[PascalCaseId];
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  return res;
}
function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  var booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, "default")) {
      value = false;
    } else if (value === "" || value === hyphenate(key)) {
      var stringIndex = getTypeIndex(String, prop.type);
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  if (value === void 0) {
    value = getPropDefaultValue(vm, prop, key);
    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  return value;
}
function getPropDefaultValue(vm, prop, key) {
  if (!hasOwn(prop, "default")) {
    return void 0;
  }
  var def2 = prop.default;
  if (vm && vm.$options.propsData && vm.$options.propsData[key] === void 0 && vm._props[key] !== void 0) {
    return vm._props[key];
  }
  return isFunction$1(def2) && getType(prop.type) !== "Function" ? def2.call(vm) : def2;
}
var functionTypeCheckRE = /^\s*function (\w+)/;
function getType(fn) {
  var match = fn && fn.toString().match(functionTypeCheckRE);
  return match ? match[1] : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (!isArray$1(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i;
    }
  }
  return -1;
}
var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop$3,
  set: noop$3
};
function proxy(target2, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target2, key, sharedPropertyDefinition);
}
function initState(vm) {
  var opts = vm.$options;
  if (opts.props)
    initProps$1(vm, opts.props);
  initSetup(vm);
  if (opts.methods)
    initMethods(vm, opts.methods);
  if (opts.data) {
    initData(vm);
  } else {
    var ob = observe(vm._data = {});
    ob && ob.vmCount++;
  }
  if (opts.computed)
    initComputed$1(vm, opts.computed);
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}
function initProps$1(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props2 = vm._props = shallowReactive({});
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  if (!isRoot) {
    toggleObserving(false);
  }
  var _loop_1 = function(key2) {
    keys.push(key2);
    var value = validateProp(key2, propsOptions, propsData, vm);
    {
      defineReactive(
        props2,
        key2,
        value,
        void 0,
        true
        /* shallow */
      );
    }
    if (!(key2 in vm)) {
      proxy(vm, "_props", key2);
    }
  };
  for (var key in propsOptions) {
    _loop_1(key);
  }
  toggleObserving(true);
}
function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = isFunction$1(data) ? getData(data, vm) : data || {};
  if (!isPlainObject$1(data)) {
    data = {};
  }
  var keys = Object.keys(data);
  var props2 = vm.$options.props;
  vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (props2 && hasOwn(props2, key)) ;
    else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  var ob = observe(data);
  ob && ob.vmCount++;
}
function getData(data, vm) {
  pushTarget();
  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  } finally {
    popTarget();
  }
}
var computedWatcherOptions = { lazy: true };
function initComputed$1(vm, computed2) {
  var watchers = vm._computedWatchers = /* @__PURE__ */ Object.create(null);
  var isSSR = isServerRendering();
  for (var key in computed2) {
    var userDef = computed2[key];
    var getter = isFunction$1(userDef) ? userDef : userDef.get;
    if (!isSSR) {
      watchers[key] = new Watcher(vm, getter || noop$3, noop$3, computedWatcherOptions);
    }
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    }
  }
}
function defineComputed(target2, key, userDef) {
  var shouldCache = !isServerRendering();
  if (isFunction$1(userDef)) {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop$3;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop$3;
    sharedPropertyDefinition.set = userDef.set || noop$3;
  }
  Object.defineProperty(target2, key, sharedPropertyDefinition);
}
function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value;
    }
  };
}
function createGetterInvoker(fn) {
  return function computedGetter() {
    return fn.call(this, this);
  };
}
function initMethods(vm, methods) {
  vm.$options.props;
  for (var key in methods) {
    vm[key] = typeof methods[key] !== "function" ? noop$3 : bind$2(methods[key], vm);
  }
}
function initWatch(vm, watch2) {
  for (var key in watch2) {
    var handler = watch2[key];
    if (isArray$1(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}
function createWatcher(vm, expOrFn, handler, options) {
  if (isPlainObject$1(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === "string") {
    handler = vm[handler];
  }
  return vm.$watch(expOrFn, handler, options);
}
function stateMixin(Vue2) {
  var dataDef = {};
  dataDef.get = function() {
    return this._data;
  };
  var propsDef = {};
  propsDef.get = function() {
    return this._props;
  };
  Object.defineProperty(Vue2.prototype, "$data", dataDef);
  Object.defineProperty(Vue2.prototype, "$props", propsDef);
  Vue2.prototype.$set = set;
  Vue2.prototype.$delete = del;
  Vue2.prototype.$watch = function(expOrFn, cb, options) {
    var vm = this;
    if (isPlainObject$1(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      var info = 'callback for immediate watcher "'.concat(watcher.expression, '"');
      pushTarget();
      invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
      popTarget();
    }
    return function unwatchFn() {
      watcher.teardown();
    };
  };
}
var uid = 0;
function initMixin$1(Vue2) {
  Vue2.prototype._init = function(options) {
    var vm = this;
    vm._uid = uid++;
    vm._isVue = true;
    vm.__v_skip = true;
    vm._scope = new EffectScope(
      true
      /* detached */
    );
    vm._scope.parent = void 0;
    vm._scope._vm = true;
    if (options && options._isComponent) {
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    {
      vm._renderProxy = vm;
    }
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook$1(
      vm,
      "beforeCreate",
      void 0,
      false
      /* setContext */
    );
    initInjections(vm);
    initState(vm);
    initProvide(vm);
    callHook$1(vm, "created");
    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}
function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}
function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      Ctor.superOptions = superOptions;
      var modifiedOptions = resolveModifiedOptions(Ctor);
      if (modifiedOptions) {
        extend$1(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options;
}
function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified)
        modified = {};
      modified[key] = latest[key];
    }
  }
  return modified;
}
function Vue(options) {
  this._init(options);
}
initMixin$1(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
function initUse(Vue2) {
  Vue2.use = function(plugin2) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
    if (installedPlugins.indexOf(plugin2) > -1) {
      return this;
    }
    var args = toArray$1(arguments, 1);
    args.unshift(this);
    if (isFunction$1(plugin2.install)) {
      plugin2.install.apply(plugin2, args);
    } else if (isFunction$1(plugin2)) {
      plugin2.apply(null, args);
    }
    installedPlugins.push(plugin2);
    return this;
  };
}
function initMixin(Vue2) {
  Vue2.mixin = function(mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}
function initExtend(Vue2) {
  Vue2.cid = 0;
  var cid = 1;
  Vue2.extend = function(extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }
    var name = getComponentName(extendOptions) || getComponentName(Super.options);
    var Sub = function VueComponent(options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub["super"] = Super;
    if (Sub.options.props) {
      initProps(Sub);
    }
    if (Sub.options.computed) {
      initComputed(Sub);
    }
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;
    ASSET_TYPES.forEach(function(type) {
      Sub[type] = Super[type];
    });
    if (name) {
      Sub.options.components[name] = Sub;
    }
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend$1({}, Sub.options);
    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}
function initProps(Comp) {
  var props2 = Comp.options.props;
  for (var key in props2) {
    proxy(Comp.prototype, "_props", key);
  }
}
function initComputed(Comp) {
  var computed2 = Comp.options.computed;
  for (var key in computed2) {
    defineComputed(Comp.prototype, key, computed2[key]);
  }
}
function initAssetRegisters(Vue2) {
  ASSET_TYPES.forEach(function(type) {
    Vue2[type] = function(id, definition) {
      if (!definition) {
        return this.options[type + "s"][id];
      } else {
        if (type === "component" && isPlainObject$1(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === "directive" && isFunction$1(definition)) {
          definition = { bind: definition, update: definition };
        }
        this.options[type + "s"][id] = definition;
        return definition;
      }
    };
  });
}
function _getComponentName(opts) {
  return opts && (getComponentName(opts.Ctor.options) || opts.tag);
}
function matches$1(pattern, name) {
  if (isArray$1(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === "string") {
    return pattern.split(",").indexOf(name) > -1;
  } else if (isRegExp$1(pattern)) {
    return pattern.test(name);
  }
  return false;
}
function pruneCache(keepAliveInstance, filter2) {
  var cache = keepAliveInstance.cache, keys = keepAliveInstance.keys, _vnode = keepAliveInstance._vnode, $vnode = keepAliveInstance.$vnode;
  for (var key in cache) {
    var entry = cache[key];
    if (entry) {
      var name_1 = entry.name;
      if (name_1 && !filter2(name_1)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
  $vnode.componentOptions.children = void 0;
}
function pruneCacheEntry(cache, key, keys, current) {
  var entry = cache[key];
  if (entry && (!current || entry.tag !== current.tag)) {
    entry.componentInstance.$destroy();
  }
  cache[key] = null;
  remove$2(keys, key);
}
var patternTypes = [String, RegExp, Array];
var KeepAlive = {
  name: "keep-alive",
  abstract: true,
  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },
  methods: {
    cacheVNode: function() {
      var _a2 = this, cache = _a2.cache, keys = _a2.keys, vnodeToCache = _a2.vnodeToCache, keyToCache = _a2.keyToCache;
      if (vnodeToCache) {
        var tag = vnodeToCache.tag, componentInstance = vnodeToCache.componentInstance, componentOptions = vnodeToCache.componentOptions;
        cache[keyToCache] = {
          name: _getComponentName(componentOptions),
          tag,
          componentInstance
        };
        keys.push(keyToCache);
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
        this.vnodeToCache = null;
      }
    }
  },
  created: function() {
    this.cache = /* @__PURE__ */ Object.create(null);
    this.keys = [];
  },
  destroyed: function() {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },
  mounted: function() {
    var _this = this;
    this.cacheVNode();
    this.$watch("include", function(val) {
      pruneCache(_this, function(name) {
        return matches$1(val, name);
      });
    });
    this.$watch("exclude", function(val) {
      pruneCache(_this, function(name) {
        return !matches$1(val, name);
      });
    });
  },
  updated: function() {
    this.cacheVNode();
  },
  render: function() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      var name_2 = _getComponentName(componentOptions);
      var _a2 = this, include = _a2.include, exclude = _a2.exclude;
      if (
        // not included
        include && (!name_2 || !matches$1(include, name_2)) || // excluded
        exclude && name_2 && matches$1(exclude, name_2)
      ) {
        return vnode;
      }
      var _b = this, cache = _b.cache, keys = _b.keys;
      var key = vnode.key == null ? (
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        componentOptions.Ctor.cid + (componentOptions.tag ? "::".concat(componentOptions.tag) : "")
      ) : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        remove$2(keys, key);
        keys.push(key);
      } else {
        this.vnodeToCache = vnode;
        this.keyToCache = key;
      }
      vnode.data.keepAlive = true;
    }
    return vnode || slot && slot[0];
  }
};
var builtInComponents = {
  KeepAlive
};
function initGlobalAPI(Vue2) {
  var configDef = {};
  configDef.get = function() {
    return config$1;
  };
  Object.defineProperty(Vue2, "config", configDef);
  Vue2.util = {
    warn,
    extend: extend$1,
    mergeOptions,
    defineReactive
  };
  Vue2.set = set;
  Vue2.delete = del;
  Vue2.nextTick = nextTick;
  Vue2.observable = function(obj) {
    observe(obj);
    return obj;
  };
  Vue2.options = /* @__PURE__ */ Object.create(null);
  ASSET_TYPES.forEach(function(type) {
    Vue2.options[type + "s"] = /* @__PURE__ */ Object.create(null);
  });
  Vue2.options._base = Vue2;
  extend$1(Vue2.options.components, builtInComponents);
  initUse(Vue2);
  initMixin(Vue2);
  initExtend(Vue2);
  initAssetRegisters(Vue2);
}
initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, "$isServer", {
  get: isServerRendering
});
Object.defineProperty(Vue.prototype, "$ssrContext", {
  get: function() {
    return this.$vnode && this.$vnode.ssrContext;
  }
});
Object.defineProperty(Vue, "FunctionalRenderContext", {
  value: FunctionalRenderContext
});
Vue.version = version;
var isReservedAttr = makeMap("style,class");
var acceptValue = makeMap("input,textarea,option,select,progress");
var mustUseProp = function(tag, type, attr) {
  return attr === "value" && acceptValue(tag) && type !== "button" || attr === "selected" && tag === "option" || attr === "checked" && tag === "input" || attr === "muted" && tag === "video";
};
var isEnumeratedAttr = makeMap("contenteditable,draggable,spellcheck");
var isValidContentEditableValue = makeMap("events,caret,typing,plaintext-only");
var convertEnumeratedValue = function(key, value) {
  return isFalsyAttrValue(value) || value === "false" ? "false" : (
    // allow arbitrary string value for contenteditable
    key === "contenteditable" && isValidContentEditableValue(value) ? value : "true"
  );
};
var isBooleanAttr = makeMap("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible");
var xlinkNS = "http://www.w3.org/1999/xlink";
var isXlink = function(name) {
  return name.charAt(5) === ":" && name.slice(0, 5) === "xlink";
};
var getXlinkProp = function(name) {
  return isXlink(name) ? name.slice(6, name.length) : "";
};
var isFalsyAttrValue = function(val) {
  return val == null || val === false;
};
function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode2 = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode2 = parentNode2.parent)) {
    if (parentNode2 && parentNode2.data) {
      data = mergeClassData(data, parentNode2.data);
    }
  }
  return renderClass(data.staticClass, data.class);
}
function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}
function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  return "";
}
function concat(a, b) {
  return a ? b ? a + " " + b : a : b || "";
}
function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }
  if (isObject$2(value)) {
    return stringifyObject(value);
  }
  if (typeof value === "string") {
    return value;
  }
  return "";
}
function stringifyArray(value) {
  var res = "";
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== "") {
      if (res)
        res += " ";
      res += stringified;
    }
  }
  return res;
}
function stringifyObject(value) {
  var res = "";
  for (var key in value) {
    if (value[key]) {
      if (res)
        res += " ";
      res += key;
    }
  }
  return res;
}
var namespaceMap = {
  svg: "http://www.w3.org/2000/svg",
  math: "http://www.w3.org/1998/Math/MathML"
};
var isHTMLTag = makeMap("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot");
var isSVG = makeMap("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", true);
var isReservedTag = function(tag) {
  return isHTMLTag(tag) || isSVG(tag);
};
function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return "svg";
  }
  if (tag === "math") {
    return "math";
  }
}
var unknownElementCache = /* @__PURE__ */ Object.create(null);
function isUnknownElement(tag) {
  if (!inBrowser) {
    return true;
  }
  if (isReservedTag(tag)) {
    return false;
  }
  tag = tag.toLowerCase();
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }
  var el = document.createElement(tag);
  if (tag.indexOf("-") > -1) {
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}
var isTextInputType = makeMap("text,number,password,search,email,tel,url");
function query(el) {
  if (typeof el === "string") {
    var selected = document.querySelector(el);
    if (!selected) {
      return document.createElement("div");
    }
    return selected;
  } else {
    return el;
  }
}
function createElement(tagName2, vnode) {
  var elm = document.createElement(tagName2);
  if (tagName2 !== "select") {
    return elm;
  }
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== void 0) {
    elm.setAttribute("multiple", "multiple");
  }
  return elm;
}
function createElementNS(namespace, tagName2) {
  return document.createElementNS(namespaceMap[namespace], tagName2);
}
function createTextNode(text2) {
  return document.createTextNode(text2);
}
function createComment(text2) {
  return document.createComment(text2);
}
function insertBefore(parentNode2, newNode, referenceNode) {
  parentNode2.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
  node.removeChild(child);
}
function appendChild(node, child) {
  node.appendChild(child);
}
function parentNode(node) {
  return node.parentNode;
}
function nextSibling(node) {
  return node.nextSibling;
}
function tagName(node) {
  return node.tagName;
}
function setTextContent(node, text2) {
  node.textContent = text2;
}
function setStyleScope(node, scopeId) {
  node.setAttribute(scopeId, "");
}
var nodeOps = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createElement,
  createElementNS,
  createTextNode,
  createComment,
  insertBefore,
  removeChild,
  appendChild,
  parentNode,
  nextSibling,
  tagName,
  setTextContent,
  setStyleScope
});
var ref = {
  create: function(_2, vnode) {
    registerRef(vnode);
  },
  update: function(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function(vnode) {
    registerRef(vnode, true);
  }
};
function registerRef(vnode, isRemoval) {
  var ref2 = vnode.data.ref;
  if (!isDef(ref2))
    return;
  var vm = vnode.context;
  var refValue = vnode.componentInstance || vnode.elm;
  var value = isRemoval ? null : refValue;
  var $refsValue = isRemoval ? void 0 : refValue;
  if (isFunction$1(ref2)) {
    invokeWithErrorHandling(ref2, vm, [value], vm, "template ref function");
    return;
  }
  var isFor = vnode.data.refInFor;
  var _isString = typeof ref2 === "string" || typeof ref2 === "number";
  var _isRef = isRef(ref2);
  var refs = vm.$refs;
  if (_isString || _isRef) {
    if (isFor) {
      var existing = _isString ? refs[ref2] : ref2.value;
      if (isRemoval) {
        isArray$1(existing) && remove$2(existing, refValue);
      } else {
        if (!isArray$1(existing)) {
          if (_isString) {
            refs[ref2] = [refValue];
            setSetupRef(vm, ref2, refs[ref2]);
          } else {
            ref2.value = [refValue];
          }
        } else if (!existing.includes(refValue)) {
          existing.push(refValue);
        }
      }
    } else if (_isString) {
      if (isRemoval && refs[ref2] !== refValue) {
        return;
      }
      refs[ref2] = $refsValue;
      setSetupRef(vm, ref2, value);
    } else if (_isRef) {
      if (isRemoval && ref2.value !== refValue) {
        return;
      }
      ref2.value = value;
    } else ;
  }
}
function setSetupRef(_a2, key, val) {
  var _setupState = _a2._setupState;
  if (_setupState && hasOwn(_setupState, key)) {
    if (isRef(_setupState[key])) {
      _setupState[key].value = val;
    } else {
      _setupState[key] = val;
    }
  }
}
var emptyNode = new VNode("", {}, []);
var hooks = ["create", "activate", "update", "remove", "destroy"];
function sameVnode(a, b) {
  return a.key === b.key && a.asyncFactory === b.asyncFactory && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error));
}
function sameInputType(a, b) {
  if (a.tag !== "input")
    return true;
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key))
      map[key] = i;
  }
  return map;
}
function createPatchFunction(backend) {
  var i, j;
  var cbs = {};
  var modules2 = backend.modules, nodeOps2 = backend.nodeOps;
  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules2.length; ++j) {
      if (isDef(modules2[j][hooks[i]])) {
        cbs[hooks[i]].push(modules2[j][hooks[i]]);
      }
    }
  }
  function emptyNodeAt(elm) {
    return new VNode(nodeOps2.tagName(elm).toLowerCase(), {}, [], void 0, elm);
  }
  function createRmCb(childElm, listeners) {
    function remove2() {
      if (--remove2.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove2.listeners = listeners;
    return remove2;
  }
  function removeNode(el) {
    var parent = nodeOps2.parentNode(el);
    if (isDef(parent)) {
      nodeOps2.removeChild(parent, el);
    }
  }
  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index2) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      vnode = ownerArray[index2] = cloneVNode(vnode);
    }
    vnode.isRootInsert = !nested;
    if (createComponent2(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }
    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      vnode.elm = vnode.ns ? nodeOps2.createElementNS(vnode.ns, tag) : nodeOps2.createElement(tag, vnode);
      setScope(vnode);
      createChildren(vnode, children, insertedVnodeQueue);
      if (isDef(data)) {
        invokeCreateHooks(vnode, insertedVnodeQueue);
      }
      insert(parentElm, vnode.elm, refElm);
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps2.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps2.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }
  function createComponent2(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i2 = vnode.data;
    if (isDef(i2)) {
      var isReactivated = isDef(vnode.componentInstance) && i2.keepAlive;
      if (isDef(i2 = i2.hook) && isDef(i2 = i2.init)) {
        i2(
          vnode,
          false
          /* hydrating */
        );
      }
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true;
      }
    }
  }
  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      registerRef(vnode);
      insertedVnodeQueue.push(vnode);
    }
  }
  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i2;
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i2 = innerNode.data) && isDef(i2 = i2.transition)) {
        for (i2 = 0; i2 < cbs.activate.length; ++i2) {
          cbs.activate[i2](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break;
      }
    }
    insert(parentElm, vnode.elm, refElm);
  }
  function insert(parent, elm, ref2) {
    if (isDef(parent)) {
      if (isDef(ref2)) {
        if (nodeOps2.parentNode(ref2) === parent) {
          nodeOps2.insertBefore(parent, elm, ref2);
        }
      } else {
        nodeOps2.appendChild(parent, elm);
      }
    }
  }
  function createChildren(vnode, children, insertedVnodeQueue) {
    if (isArray$1(children)) {
      for (var i_1 = 0; i_1 < children.length; ++i_1) {
        createElm(children[i_1], insertedVnodeQueue, vnode.elm, null, true, children, i_1);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps2.appendChild(vnode.elm, nodeOps2.createTextNode(String(vnode.text)));
    }
  }
  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag);
  }
  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i_2 = 0; i_2 < cbs.create.length; ++i_2) {
      cbs.create[i_2](emptyNode, vnode);
    }
    i = vnode.data.hook;
    if (isDef(i)) {
      if (isDef(i.create))
        i.create(emptyNode, vnode);
      if (isDef(i.insert))
        insertedVnodeQueue.push(vnode);
    }
  }
  function setScope(vnode) {
    var i2;
    if (isDef(i2 = vnode.fnScopeId)) {
      nodeOps2.setStyleScope(vnode.elm, i2);
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i2 = ancestor.context) && isDef(i2 = i2.$options._scopeId)) {
          nodeOps2.setStyleScope(vnode.elm, i2);
        }
        ancestor = ancestor.parent;
      }
    }
    if (isDef(i2 = activeInstance) && i2 !== vnode.context && i2 !== vnode.fnContext && isDef(i2 = i2.$options._scopeId)) {
      nodeOps2.setStyleScope(vnode.elm, i2);
    }
  }
  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }
  function invokeDestroyHook(vnode) {
    var i2, j2;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i2 = data.hook) && isDef(i2 = i2.destroy))
        i2(vnode);
      for (i2 = 0; i2 < cbs.destroy.length; ++i2)
        cbs.destroy[i2](vnode);
    }
    if (isDef(i2 = vnode.children)) {
      for (j2 = 0; j2 < vnode.children.length; ++j2) {
        invokeDestroyHook(vnode.children[j2]);
      }
    }
  }
  function removeVnodes(vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          removeNode(ch.elm);
        }
      }
    }
  }
  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i_3;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        rm.listeners += listeners;
      } else {
        rm = createRmCb(vnode.elm, listeners);
      }
      if (isDef(i_3 = vnode.componentInstance) && isDef(i_3 = i_3._vnode) && isDef(i_3.data)) {
        removeAndInvokeRemoveHook(i_3, rm);
      }
      for (i_3 = 0; i_3 < cbs.remove.length; ++i_3) {
        cbs.remove[i_3](vnode, rm);
      }
      if (isDef(i_3 = vnode.data.hook) && isDef(i_3 = i_3.remove)) {
        i_3(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }
  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;
    var canMove = !removeOnly;
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx];
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps2.insertBefore(parentElm, oldStartVnode.elm, nodeOps2.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps2.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx))
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) {
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = void 0;
            canMove && nodeOps2.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
  }
  function findIdxInOld(node, oldCh, start, end) {
    for (var i_5 = start; i_5 < end; i_5++) {
      var c = oldCh[i_5];
      if (isDef(c) && sameVnode(node, c))
        return i_5;
    }
  }
  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index2, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      vnode = ownerArray[index2] = cloneVNode(vnode);
    }
    var elm = vnode.elm = oldVnode.elm;
    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return;
    }
    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }
    var i2;
    var data = vnode.data;
    if (isDef(data) && isDef(i2 = data.hook) && isDef(i2 = i2.prepatch)) {
      i2(oldVnode, vnode);
    }
    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i2 = 0; i2 < cbs.update.length; ++i2)
        cbs.update[i2](oldVnode, vnode);
      if (isDef(i2 = data.hook) && isDef(i2 = i2.update))
        i2(oldVnode, vnode);
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch)
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text))
          nodeOps2.setTextContent(elm, "");
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps2.setTextContent(elm, "");
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps2.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i2 = data.hook) && isDef(i2 = i2.postpatch))
        i2(oldVnode, vnode);
    }
  }
  function invokeInsertHook(vnode, queue2, initial) {
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue2;
    } else {
      for (var i_6 = 0; i_6 < queue2.length; ++i_6) {
        queue2[i_6].data.hook.insert(queue2[i_6]);
      }
    }
  }
  var isRenderedModule = makeMap("attrs,class,staticClass,staticStyle,key");
  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i2;
    var tag = vnode.tag, data = vnode.data, children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;
    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    }
    if (isDef(data)) {
      if (isDef(i2 = data.hook) && isDef(i2 = i2.init))
        i2(
          vnode,
          true
          /* hydrating */
        );
      if (isDef(i2 = vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          if (isDef(i2 = data) && isDef(i2 = i2.domProps) && isDef(i2 = i2.innerHTML)) {
            if (i2 !== elm.innerHTML) {
              return false;
            }
          } else {
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i_7 = 0; i_7 < children.length; i_7++) {
              if (!childNode || !hydrate(childNode, children[i_7], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }
              childNode = childNode.nextSibling;
            }
            if (!childrenMatch || childNode) {
              return false;
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }
        if (!fullInvoke && data["class"]) {
          traverse(data["class"]);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true;
  }
  return function patch2(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode))
        invokeDestroyHook(oldVnode);
      return;
    }
    var isInitialPatch = false;
    var insertedVnodeQueue = [];
    if (isUndef(oldVnode)) {
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            }
          }
          oldVnode = emptyNodeAt(oldVnode);
        }
        var oldElm = oldVnode.elm;
        var parentElm = nodeOps2.parentNode(oldElm);
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm,
          nodeOps2.nextSibling(oldElm)
        );
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i_8 = 0; i_8 < cbs.destroy.length; ++i_8) {
              cbs.destroy[i_8](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i_9 = 0; i_9 < cbs.create.length; ++i_9) {
                cbs.create[i_9](emptyNode, ancestor);
              }
              var insert_1 = ancestor.data.hook.insert;
              if (insert_1.merged) {
                var cloned = insert_1.fns.slice(1);
                for (var i_10 = 0; i_10 < cloned.length; i_10++) {
                  cloned[i_10]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }
        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }
    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}
var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};
function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}
function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives(vnode.data.directives, vnode.context);
  var dirsWithInsert = [];
  var dirsWithPostpatch = [];
  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      callHook(dir, "bind", vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook(dir, "update", vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }
  if (dirsWithInsert.length) {
    var callInsert = function() {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook(dirsWithInsert[i], "inserted", vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, "insert", callInsert);
    } else {
      callInsert();
    }
  }
  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, "postpatch", function() {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook(dirsWithPostpatch[i], "componentUpdated", vnode, oldVnode);
      }
    });
  }
  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        callHook(oldDirs[key], "unbind", oldVnode, oldVnode, isDestroy);
      }
    }
  }
}
var emptyModifiers = /* @__PURE__ */ Object.create(null);
function normalizeDirectives(dirs, vm) {
  var res = /* @__PURE__ */ Object.create(null);
  if (!dirs) {
    return res;
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    if (vm._setupState && vm._setupState.__sfc) {
      var setupDef = dir.def || resolveAsset(vm, "_setupState", "v-" + dir.name);
      if (typeof setupDef === "function") {
        dir.def = {
          bind: setupDef,
          update: setupDef
        };
      } else {
        dir.def = setupDef;
      }
    }
    dir.def = dir.def || resolveAsset(vm.$options, "directives", dir.name);
  }
  return res;
}
function getRawDirName(dir) {
  return dir.rawName || "".concat(dir.name, ".").concat(Object.keys(dir.modifiers || {}).join("."));
}
function callHook(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive ".concat(dir.name, " ").concat(hook, " hook"));
    }
  }
}
var baseModules = [ref, directives];
function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs2 = vnode.data.attrs || {};
  if (isDef(attrs2.__ob__) || isTrue(attrs2._v_attr_proxy)) {
    attrs2 = vnode.data.attrs = extend$1({}, attrs2);
  }
  for (key in attrs2) {
    cur = attrs2[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur, vnode.data.pre);
    }
  }
  if ((isIE$1 || isEdge) && attrs2.value !== oldAttrs.value) {
    setAttr(elm, "value", attrs2.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs2[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}
function setAttr(el, key, value, isInPre) {
  if (isInPre || el.tagName.indexOf("-") > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      value = key === "allowfullscreen" && el.tagName === "EMBED" ? "true" : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}
function baseSetAttr(el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    if (isIE$1 && !isIE9 && el.tagName === "TEXTAREA" && key === "placeholder" && value !== "" && !el.__ieph) {
      var blocker_1 = function(e) {
        e.stopImmediatePropagation();
        el.removeEventListener("input", blocker_1);
      };
      el.addEventListener("input", blocker_1);
      el.__ieph = true;
    }
    el.setAttribute(key, value);
  }
}
var attrs = {
  create: updateAttrs,
  update: updateAttrs
};
function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }
  var cls = genClassForVnode(vnode);
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }
  if (cls !== el._prevClass) {
    el.setAttribute("class", cls);
    el._prevClass = cls;
  }
}
var klass = {
  create: updateClass,
  update: updateClass
};
var RANGE_TOKEN = "__r";
var CHECKBOX_RADIO_TOKEN = "__c";
function normalizeEvents(on) {
  if (isDef(on[RANGE_TOKEN])) {
    var event_1 = isIE$1 ? "change" : "input";
    on[event_1] = [].concat(on[RANGE_TOKEN], on[event_1] || []);
    delete on[RANGE_TOKEN];
  }
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}
var target;
function createOnceHandler(event, handler, capture) {
  var _target = target;
  return function onceHandler() {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove(event, onceHandler, capture, _target);
    }
  };
}
var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);
function add(name, handler, capture, passive) {
  if (useMicrotaskFix) {
    var attachedTimestamp_1 = currentFlushTimestamp;
    var original_1 = handler;
    handler = original_1._wrapper = function(e) {
      if (
        // no bubbling, should always fire.
        // this is just a safety net in case event.timeStamp is unreliable in
        // certain weird environments...
        e.target === e.currentTarget || // event is fired after handler attachment
        e.timeStamp >= attachedTimestamp_1 || // bail for environments that have buggy event.timeStamp implementations
        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
        // #9681 QtWebEngine event.timeStamp is negative value
        e.timeStamp <= 0 || // #9448 bail if event is fired in another document in a multi-page
        // electron/nw.js app, since event.timeStamp will be using a different
        // starting reference
        e.target.ownerDocument !== document
      ) {
        return original_1.apply(this, arguments);
      }
    };
  }
  target.addEventListener(name, handler, supportsPassive$1 ? { capture, passive } : capture);
}
function remove(name, handler, capture, _target) {
  (_target || target).removeEventListener(
    name,
    //@ts-expect-error
    handler._wrapper || handler,
    capture
  );
}
function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target = vnode.elm || oldVnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);
  target = void 0;
}
var events = {
  create: updateDOMListeners,
  update: updateDOMListeners,
  // @ts-expect-error emptyNode has actually data
  destroy: function(vnode) {
    return updateDOMListeners(vnode, emptyNode);
  }
};
var svgContainer;
function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props2 = vnode.data.domProps || {};
  if (isDef(props2.__ob__) || isTrue(props2._v_attr_proxy)) {
    props2 = vnode.data.domProps = extend$1({}, props2);
  }
  for (key in oldProps) {
    if (!(key in props2)) {
      elm[key] = "";
    }
  }
  for (key in props2) {
    cur = props2[key];
    if (key === "textContent" || key === "innerHTML") {
      if (vnode.children)
        vnode.children.length = 0;
      if (cur === oldProps[key])
        continue;
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }
    if (key === "value" && elm.tagName !== "PROGRESS") {
      elm._value = cur;
      var strCur = isUndef(cur) ? "" : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === "innerHTML" && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      svgContainer = svgContainer || document.createElement("div");
      svgContainer.innerHTML = "<svg>".concat(cur, "</svg>");
      var svg2 = svgContainer.firstChild;
      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }
      while (svg2.firstChild) {
        elm.appendChild(svg2.firstChild);
      }
    } else if (
      // skip the update if old and new VDOM state is the same.
      // `value` is handled separately because the DOM value may be temporarily
      // out of sync with VDOM state due to focus, composition and modifiers.
      // This  #4521 by skipping the unnecessary `checked` update.
      cur !== oldProps[key]
    ) {
      try {
        elm[key] = cur;
      } catch (e) {
      }
    }
  }
}
function shouldUpdateValue(elm, checkVal) {
  return (
    //@ts-expect-error
    !elm.composing && (elm.tagName === "OPTION" || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal))
  );
}
function isNotInFocusAndDirty(elm, checkVal) {
  var notInFocus = true;
  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {
  }
  return notInFocus && elm.value !== checkVal;
}
function isDirtyWithModifiers(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers;
  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }
    if (modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
  }
  return value !== newVal;
}
var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};
var parseStyleText = cached(function(cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function(item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
});
function normalizeStyleData(data) {
  var style2 = normalizeStyleBinding(data.style);
  return data.staticStyle ? extend$1(data.staticStyle, style2) : style2;
}
function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }
  if (typeof bindingStyle === "string") {
    return parseStyleText(bindingStyle);
  }
  return bindingStyle;
}
function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;
  {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend$1(res, styleData);
      }
    }
  }
  if (styleData = normalizeStyleData(vnode.data)) {
    extend$1(res, styleData);
  }
  var parentNode2 = vnode;
  while (parentNode2 = parentNode2.parent) {
    if (parentNode2.data && (styleData = normalizeStyleData(parentNode2.data))) {
      extend$1(res, styleData);
    }
  }
  return res;
}
var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function(el, name, val) {
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ""), "important");
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};
var vendorNames = ["Webkit", "Moz", "ms"];
var emptyStyle;
var normalize = cached(function(prop) {
  emptyStyle = emptyStyle || document.createElement("div").style;
  prop = camelize(prop);
  if (prop !== "filter" && prop in emptyStyle) {
    return prop;
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name_1 = vendorNames[i] + capName;
    if (name_1 in emptyStyle) {
      return name_1;
    }
  }
});
function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }
  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};
  var oldStyle = oldStaticStyle || oldStyleBinding;
  var style2 = normalizeStyleBinding(vnode.data.style) || {};
  vnode.data.normalizedStyle = isDef(style2.__ob__) ? extend$1({}, style2) : style2;
  var newStyle = getStyle(vnode);
  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, "");
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    setProp(el, name, cur == null ? "" : cur);
  }
}
var style = {
  create: updateStyle,
  update: updateStyle
};
var whitespaceRE = /\s+/;
function addClass(el, cls) {
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  if (el.classList) {
    if (cls.indexOf(" ") > -1) {
      cls.split(whitespaceRE).forEach(function(c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " ".concat(el.getAttribute("class") || "", " ");
    if (cur.indexOf(" " + cls + " ") < 0) {
      el.setAttribute("class", (cur + cls).trim());
    }
  }
}
function removeClass(el, cls) {
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  if (el.classList) {
    if (cls.indexOf(" ") > -1) {
      cls.split(whitespaceRE).forEach(function(c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute("class");
    }
  } else {
    var cur = " ".concat(el.getAttribute("class") || "", " ");
    var tar = " " + cls + " ";
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, " ");
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute("class", cur);
    } else {
      el.removeAttribute("class");
    }
  }
}
function resolveTransition(def2) {
  if (!def2) {
    return;
  }
  if (typeof def2 === "object") {
    var res = {};
    if (def2.css !== false) {
      extend$1(res, autoCssTransition(def2.name || "v"));
    }
    extend$1(res, def2);
    return res;
  } else if (typeof def2 === "string") {
    return autoCssTransition(def2);
  }
}
var autoCssTransition = cached(function(name) {
  return {
    enterClass: "".concat(name, "-enter"),
    enterToClass: "".concat(name, "-enter-to"),
    enterActiveClass: "".concat(name, "-enter-active"),
    leaveClass: "".concat(name, "-leave"),
    leaveToClass: "".concat(name, "-leave-to"),
    leaveActiveClass: "".concat(name, "-leave-active")
  };
});
var hasTransition = inBrowser && !isIE9;
var TRANSITION = "transition";
var ANIMATION = "animation";
var transitionProp = "transition";
var transitionEndEvent = "transitionend";
var animationProp = "animation";
var animationEndEvent = "animationend";
if (hasTransition) {
  if (window.ontransitionend === void 0 && window.onwebkittransitionend !== void 0) {
    transitionProp = "WebkitTransition";
    transitionEndEvent = "webkitTransitionEnd";
  }
  if (window.onanimationend === void 0 && window.onwebkitanimationend !== void 0) {
    animationProp = "WebkitAnimation";
    animationEndEvent = "webkitAnimationEnd";
  }
}
var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : (
  /* istanbul ignore next */
  function(fn) {
    return fn();
  }
);
function nextFrame$1(fn) {
  raf(function() {
    raf(fn);
  });
}
function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}
function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove$2(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}
function whenTransitionEnds(el, expectedType, cb) {
  var _a2 = getTransitionInfo(el, expectedType), type = _a2.type, timeout = _a2.timeout, propCount = _a2.propCount;
  if (!type)
    return cb();
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function() {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function(e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function() {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}
var transformRE = /\b(transform|all)(,|$)/;
function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = (styles[transitionProp + "Delay"] || "").split(", ");
  var transitionDurations = (styles[transitionProp + "Duration"] || "").split(", ");
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + "Delay"] || "").split(", ");
  var animationDurations = (styles[animationProp + "Duration"] || "").split(", ");
  var animationTimeout = getTimeout(animationDelays, animationDurations);
  var type;
  var timeout = 0;
  var propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + "Property"]);
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max.apply(null, durations.map(function(d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
}
function toMs(s) {
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function enter(vnode, toggleDisplay) {
  var el = vnode.elm;
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }
  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return;
  }
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }
  var css = data.css, type = data.type, enterClass = data.enterClass, enterToClass = data.enterToClass, enterActiveClass = data.enterActiveClass, appearClass = data.appearClass, appearToClass = data.appearToClass, appearActiveClass = data.appearActiveClass, beforeEnter = data.beforeEnter, enter2 = data.enter, afterEnter = data.afterEnter, enterCancelled = data.enterCancelled, beforeAppear = data.beforeAppear, appear = data.appear, afterAppear = data.afterAppear, appearCancelled = data.appearCancelled, duration = data.duration;
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    context = transitionNode.context;
    transitionNode = transitionNode.parent;
  }
  var isAppear = !context._isMounted || !vnode.isRootInsert;
  if (isAppear && !appear && appear !== "") {
    return;
  }
  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? isFunction$1(appear) ? appear : enter2 : enter2;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
  var explicitEnterDuration = toNumber(isObject$2(duration) ? duration.enter : duration);
  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);
  var cb = el._enterCb = once(function() {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });
  if (!vnode.data.show) {
    mergeVNodeHook(vnode, "insert", function() {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame$1(function() {
      removeTransitionClass(el, startClass);
      if (!cb.cancelled) {
        addTransitionClass(el, toClass);
        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }
  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }
  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}
function leave(vnode, rm) {
  var el = vnode.elm;
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }
  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }
  if (isDef(el._leaveCb)) {
    return;
  }
  var css = data.css, type = data.type, leaveClass = data.leaveClass, leaveToClass = data.leaveToClass, leaveActiveClass = data.leaveActiveClass, beforeLeave = data.beforeLeave, leave2 = data.leave, afterLeave = data.afterLeave, leaveCancelled = data.leaveCancelled, delayLeave = data.delayLeave, duration = data.duration;
  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave2);
  var explicitLeaveDuration = toNumber(isObject$2(duration) ? duration.leave : duration);
  var cb = el._leaveCb = once(function() {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });
  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }
  function performLeave() {
    if (cb.cancelled) {
      return;
    }
    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame$1(function() {
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }
    leave2 && leave2(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}
function isValidDuration(val) {
  return typeof val === "number" && !isNaN(val);
}
function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}
function _enter(_2, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}
var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function(vnode, rm) {
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};
var platformModules = [attrs, klass, events, domProps, style, transition];
var modules = platformModules.concat(baseModules);
var patch = createPatchFunction({ nodeOps, modules });
if (isIE9) {
  document.addEventListener("selectionchange", function() {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, "input");
    }
  });
}
var directive = {
  inserted: function(el, binding, vnode, oldVnode) {
    if (vnode.tag === "select") {
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, "postpatch", function() {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === "textarea" || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        el.addEventListener("compositionstart", onCompositionStart);
        el.addEventListener("compositionend", onCompositionEnd);
        el.addEventListener("change", onCompositionEnd);
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function(el, binding, vnode) {
    if (vnode.tag === "select") {
      setSelected(el, binding, vnode.context);
      var prevOptions_1 = el._vOptions;
      var curOptions_1 = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions_1.some(function(o, i) {
        return !looseEqual(o, prevOptions_1[i]);
      })) {
        var needReset = el.multiple ? binding.value.some(function(v) {
          return hasNoMatchingOption(v, curOptions_1);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions_1);
        if (needReset) {
          trigger(el, "change");
        }
      }
    }
  }
};
function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding);
  if (isIE$1 || isEdge) {
    setTimeout(function() {
      actuallySetSelected(el, binding);
    }, 0);
  }
}
function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    return;
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return;
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}
function hasNoMatchingOption(value, options) {
  return options.every(function(o) {
    return !looseEqual(o, value);
  });
}
function getValue(option) {
  return "_value" in option ? option._value : option.value;
}
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  if (!e.target.composing)
    return;
  e.target.composing = false;
  trigger(e.target, "input");
}
function trigger(el, type) {
  var e = document.createEvent("HTMLEvents");
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}
function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}
var show = {
  bind: function(el, _a2, vnode) {
    var value = _a2.value;
    vnode = locateNode(vnode);
    var transition2 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === "none" ? "" : el.style.display;
    if (value && transition2) {
      vnode.data.show = true;
      enter(vnode, function() {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : "none";
    }
  },
  update: function(el, _a2, vnode) {
    var value = _a2.value, oldValue = _a2.oldValue;
    if (!value === !oldValue)
      return;
    vnode = locateNode(vnode);
    var transition2 = vnode.data && vnode.data.transition;
    if (transition2) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function() {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function() {
          el.style.display = "none";
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : "none";
    }
  },
  unbind: function(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};
var platformDirectives = {
  model: directive,
  show
};
var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};
function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}
function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options;
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  var listeners = options._parentListeners;
  for (var key in listeners) {
    data[camelize(key)] = listeners[key];
  }
  return data;
}
function placeholder(h2, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h2("keep-alive", {
      props: rawChild.componentOptions.propsData
    });
  }
}
function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}
function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}
var isNotTextNode = function(c) {
  return c.tag || isAsyncPlaceholder(c);
};
var isVShowDirective = function(d) {
  return d.name === "show";
};
var Transition = {
  name: "transition",
  props: transitionProps,
  abstract: true,
  render: function(h2) {
    var _this = this;
    var children = this.$slots.default;
    if (!children) {
      return;
    }
    children = children.filter(isNotTextNode);
    if (!children.length) {
      return;
    }
    var mode = this.mode;
    var rawChild = children[0];
    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    }
    var child = getRealChild(rawChild);
    if (!child) {
      return rawChild;
    }
    if (this._leaving) {
      return placeholder(h2, rawChild);
    }
    var id = "__transition-".concat(this._uid, "-");
    child.key = child.key == null ? child.isComment ? id + "comment" : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);
    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }
    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node
    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      var oldData = oldChild.data.transition = extend$1({}, data);
      if (mode === "out-in") {
        this._leaving = true;
        mergeVNodeHook(oldData, "afterLeave", function() {
          _this._leaving = false;
          _this.$forceUpdate();
        });
        return placeholder(h2, rawChild);
      } else if (mode === "in-out") {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }
        var delayedLeave_1;
        var performLeave = function() {
          delayedLeave_1();
        };
        mergeVNodeHook(data, "afterEnter", performLeave);
        mergeVNodeHook(data, "enterCancelled", performLeave);
        mergeVNodeHook(oldData, "delayLeave", function(leave2) {
          delayedLeave_1 = leave2;
        });
      }
    }
    return rawChild;
  }
};
var props = extend$1({
  tag: String,
  moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
  props,
  beforeMount: function() {
    var _this = this;
    var update = this._update;
    this._update = function(vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(_this);
      _this.__patch__(
        _this._vnode,
        _this.kept,
        false,
        // hydrating
        true
        // removeOnly (!important, avoids unnecessary moves)
      );
      _this._vnode = _this.kept;
      restoreActiveInstance();
      update.call(_this, vnode, hydrating);
    };
  },
  render: function(h2) {
    var tag = this.tag || this.$vnode.data.tag || "span";
    var map = /* @__PURE__ */ Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);
    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf("__vlist") !== 0) {
          children.push(c);
          map[c.key] = c;
          (c.data || (c.data = {})).transition = transitionData;
        }
      }
    }
    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i = 0; i < prevChildren.length; i++) {
        var c = prevChildren[i];
        c.data.transition = transitionData;
        c.data.pos = c.elm.getBoundingClientRect();
        if (map[c.key]) {
          kept.push(c);
        } else {
          removed.push(c);
        }
      }
      this.kept = h2(tag, null, kept);
      this.removed = removed;
    }
    return h2(tag, null, children);
  },
  updated: function() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || "v") + "-move";
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    }
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);
    this._reflow = document.body.offsetHeight;
    children.forEach(function(c) {
      if (c.data.moved) {
        var el_1 = c.elm;
        var s = el_1.style;
        addTransitionClass(el_1, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = "";
        el_1.addEventListener(transitionEndEvent, el_1._moveCb = function cb(e) {
          if (e && e.target !== el_1) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el_1.removeEventListener(transitionEndEvent, cb);
            el_1._moveCb = null;
            removeTransitionClass(el_1, moveClass);
          }
        });
      }
    });
  },
  methods: {
    hasMove: function(el, moveClass) {
      if (!hasTransition) {
        return false;
      }
      if (this._hasMove) {
        return this._hasMove;
      }
      var clone2 = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function(cls) {
          removeClass(clone2, cls);
        });
      }
      addClass(clone2, moveClass);
      clone2.style.display = "none";
      this.$el.appendChild(clone2);
      var info = getTransitionInfo(clone2);
      this.$el.removeChild(clone2);
      return this._hasMove = info.hasTransform;
    }
  }
};
function callPendingCbs(c) {
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}
function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}
function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(".concat(dx, "px,").concat(dy, "px)");
    s.transitionDuration = "0s";
  }
}
var platformComponents = {
  Transition,
  TransitionGroup
};
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;
extend$1(Vue.options.directives, platformDirectives);
extend$1(Vue.options.components, platformComponents);
Vue.prototype.__patch__ = inBrowser ? patch : noop$3;
Vue.prototype.$mount = function(el, hydrating) {
  el = el && inBrowser ? query(el) : void 0;
  return mountComponent(this, el, hydrating);
};
if (inBrowser) {
  setTimeout(function() {
    if (config$1.devtools) {
      if (devtools) {
        devtools.emit("init", Vue);
      }
    }
  }, 0);
}
const appLogo = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='white'%20d='M6.5%2020Q4.22%2020%202.61%2018.43%201%2016.85%201%2014.58%201%2012.63%202.17%2011.1%203.35%209.57%205.25%209.15%205.88%206.85%207.75%205.43%209.63%204%2012%204%2014.93%204%2016.96%206.04%2019%208.07%2019%2011%2020.73%2011.2%2021.86%2012.5%2023%2013.78%2023%2015.5%2023%2017.38%2021.69%2018.69%2020.38%2020%2018.5%2020Z'%20/%3e%3c/svg%3e";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs$1(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var dist = {};
var storagebuilder = {};
var scopedstorage = {};
var hasRequiredScopedstorage;
function requireScopedstorage() {
  if (hasRequiredScopedstorage) return scopedstorage;
  hasRequiredScopedstorage = 1;
  Object.defineProperty(scopedstorage, "__esModule", {
    value: true
  });
  scopedstorage.default = void 0;
  function _defineProperty2(obj, key, value) {
    key = _toPropertyKey2(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey2(t2) {
    var i = _toPrimitive2(t2, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive2(t2, r) {
    if ("object" != typeof t2 || !t2) return t2;
    var e = t2[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t2, r);
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t2);
  }
  class ScopedStorage {
    constructor(scope, wrapped, persistent) {
      _defineProperty2(this, "scope", void 0);
      _defineProperty2(this, "wrapped", void 0);
      this.scope = "".concat(persistent ? ScopedStorage.GLOBAL_SCOPE_PERSISTENT : ScopedStorage.GLOBAL_SCOPE_VOLATILE, "_").concat(btoa(scope), "_");
      this.wrapped = wrapped;
    }
    scopeKey(key) {
      return "".concat(this.scope).concat(key);
    }
    setItem(key, value) {
      this.wrapped.setItem(this.scopeKey(key), value);
    }
    getItem(key) {
      return this.wrapped.getItem(this.scopeKey(key));
    }
    removeItem(key) {
      this.wrapped.removeItem(this.scopeKey(key));
    }
    clear() {
      Object.keys(this.wrapped).filter((key) => key.startsWith(this.scope)).map(this.wrapped.removeItem.bind(this.wrapped));
    }
  }
  scopedstorage.default = ScopedStorage;
  _defineProperty2(ScopedStorage, "GLOBAL_SCOPE_VOLATILE", "nextcloud_vol");
  _defineProperty2(ScopedStorage, "GLOBAL_SCOPE_PERSISTENT", "nextcloud_per");
  return scopedstorage;
}
var hasRequiredStoragebuilder;
function requireStoragebuilder() {
  if (hasRequiredStoragebuilder) return storagebuilder;
  hasRequiredStoragebuilder = 1;
  Object.defineProperty(storagebuilder, "__esModule", {
    value: true
  });
  storagebuilder.default = void 0;
  var _scopedstorage = _interopRequireDefault(requireScopedstorage());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _defineProperty2(obj, key, value) {
    key = _toPropertyKey2(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey2(t2) {
    var i = _toPrimitive2(t2, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive2(t2, r) {
    if ("object" != typeof t2 || !t2) return t2;
    var e = t2[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t2, r);
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t2);
  }
  class StorageBuilder {
    constructor(appId) {
      _defineProperty2(this, "appId", void 0);
      _defineProperty2(this, "persisted", false);
      _defineProperty2(this, "clearedOnLogout", false);
      this.appId = appId;
    }
    persist() {
      let persist = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this.persisted = persist;
      return this;
    }
    clearOnLogout() {
      let clear = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this.clearedOnLogout = clear;
      return this;
    }
    build() {
      return new _scopedstorage.default(this.appId, this.persisted ? window.localStorage : window.sessionStorage, !this.clearedOnLogout);
    }
  }
  storagebuilder.default = StorageBuilder;
  return storagebuilder;
}
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  Object.defineProperty(dist, "__esModule", {
    value: true
  });
  dist.clearAll = clearAll;
  dist.clearNonPersistent = clearNonPersistent;
  dist.getBuilder = getBuilder;
  var _storagebuilder = _interopRequireDefault(requireStoragebuilder());
  var _scopedstorage = _interopRequireDefault(requireScopedstorage());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function getBuilder(appId) {
    return new _storagebuilder.default(appId);
  }
  function clearStorage(storage, pred) {
    Object.keys(storage).filter((k) => pred ? pred(k) : true).map(storage.removeItem.bind(storage));
  }
  function clearAll() {
    const storages = [window.sessionStorage, window.localStorage];
    storages.map((s) => clearStorage(s));
  }
  function clearNonPersistent() {
    const storages = [window.sessionStorage, window.localStorage];
    storages.map((s) => clearStorage(s, (k) => !k.startsWith(_scopedstorage.default.GLOBAL_SCOPE_PERSISTENT)));
  }
  return dist;
}
var distExports = requireDist();
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var browser = { exports: {} };
var process = browser.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$2() {
}
process.on = noop$2;
process.addListener = noop$2;
process.once = noop$2;
process.off = noop$2;
process.removeListener = noop$2;
process.removeAllListeners = noop$2;
process.emit = noop$2;
process.prependListener = noop$2;
process.prependOnceListener = noop$2;
process.listeners = function(name) {
  return [];
};
process.binding = function(name) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(dir) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
var debug_1;
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug) return debug_1;
  hasRequiredDebug = 1;
  var define_process_env_default = {};
  const debug = typeof process$1 === "object" && define_process_env_default && define_process_env_default.NODE_DEBUG && /\bsemver\b/i.test(define_process_env_default.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  debug_1 = debug;
  return debug_1;
}
var constants;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  const SEMVER_SPEC_VERSION = "2.0.0";
  const MAX_LENGTH = 256;
  const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991;
  const MAX_SAFE_COMPONENT_LENGTH = 16;
  const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  const RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  constants = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
  return constants;
}
var re = { exports: {} };
var hasRequiredRe;
function requireRe() {
  if (hasRequiredRe) return re.exports;
  hasRequiredRe = 1;
  (function(module, exports) {
    const {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = requireConstants();
    const debug = requireDebug();
    exports = module.exports = {};
    const re2 = exports.re = [];
    const safeRe = exports.safeRe = [];
    const src = exports.src = [];
    const safeSrc = exports.safeSrc = [];
    const t2 = exports.t = {};
    let R = 0;
    const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    const safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    const makeSafeRegex = (value) => {
      for (const [token2, max2] of safeRegexReplacements) {
        value = value.split(`${token2}*`).join(`${token2}{0,${max2}}`).split(`${token2}+`).join(`${token2}{1,${max2}}`);
      }
      return value;
    };
    const createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index2 = R++;
      debug(name, index2, value);
      t2[name] = index2;
      src[index2] = value;
      safeSrc[index2] = safe;
      re2[index2] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NONNUMERICIDENTIFIER]}|${src[t2.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NONNUMERICIDENTIFIER]}|${src[t2.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
    createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
    createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t2.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t2.COERCEPLAIN] + `(?:${src[t2.PRERELEASE]})?(?:${src[t2.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t2.COERCE], true);
    createToken("COERCERTLFULL", src[t2.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  })(re, re.exports);
  return re.exports;
}
var parseOptions_1;
var hasRequiredParseOptions;
function requireParseOptions() {
  if (hasRequiredParseOptions) return parseOptions_1;
  hasRequiredParseOptions = 1;
  const looseOption = Object.freeze({ loose: true });
  const emptyOpts = Object.freeze({});
  const parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  parseOptions_1 = parseOptions;
  return parseOptions_1;
}
var identifiers;
var hasRequiredIdentifiers;
function requireIdentifiers() {
  if (hasRequiredIdentifiers) return identifiers;
  hasRequiredIdentifiers = 1;
  const numeric = /^[0-9]+$/;
  const compareIdentifiers = (a, b) => {
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  identifiers = {
    compareIdentifiers,
    rcompareIdentifiers
  };
  return identifiers;
}
var semver;
var hasRequiredSemver;
function requireSemver() {
  if (hasRequiredSemver) return semver;
  hasRequiredSemver = 1;
  const debug = requireDebug();
  const { MAX_LENGTH, MAX_SAFE_INTEGER } = requireConstants();
  const { safeRe: re2, t: t2 } = requireRe();
  const parseOptions = requireParseOptions();
  const { compareIdentifiers } = requireIdentifiers();
  class SemVer {
    constructor(version2, options) {
      options = parseOptions(options);
      if (version2 instanceof SemVer) {
        if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
          return version2;
        } else {
          version2 = version2.version;
        }
      } else if (typeof version2 !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
      }
      if (version2.length > MAX_LENGTH) {
        throw new TypeError(
          `version is longer than ${MAX_LENGTH} characters`
        );
      }
      debug("SemVer", version2, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version2.trim().match(options.loose ? re2[t2.LOOSE] : re2[t2.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version2}`);
      }
      this.raw = version2;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other.prerelease[i];
        debug("prerelease compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other.build[i];
        debug("build compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(release, identifier, identifierBase) {
      if (release.startsWith("pre")) {
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (identifier) {
          const match = `-${identifier}`.match(this.options.loose ? re2[t2.PRERELEASELOOSE] : re2[t2.PRERELEASE]);
          if (!match || match[1] !== identifier) {
            throw new Error(`invalid identifier: ${identifier}`);
          }
        }
      }
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "release":
          if (this.prerelease.length === 0) {
            throw new Error(`version ${this.raw} is not a prerelease`);
          }
          this.prerelease.length = 0;
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  semver = SemVer;
  return semver;
}
var parse_1;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse_1;
  hasRequiredParse = 1;
  const SemVer = requireSemver();
  const parse = (version2, options, throwErrors = false) => {
    if (version2 instanceof SemVer) {
      return version2;
    }
    try {
      return new SemVer(version2, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  parse_1 = parse;
  return parse_1;
}
var valid_1;
var hasRequiredValid;
function requireValid() {
  if (hasRequiredValid) return valid_1;
  hasRequiredValid = 1;
  const parse = requireParse();
  const valid2 = (version2, options) => {
    const v = parse(version2, options);
    return v ? v.version : null;
  };
  valid_1 = valid2;
  return valid_1;
}
var validExports = requireValid();
const valid = /* @__PURE__ */ getDefaultExportFromCjs$1(validExports);
var major_1;
var hasRequiredMajor;
function requireMajor() {
  if (hasRequiredMajor) return major_1;
  hasRequiredMajor = 1;
  const SemVer = requireSemver();
  const major2 = (a, loose) => new SemVer(a, loose).major;
  major_1 = major2;
  return major_1;
}
var majorExports = requireMajor();
const major = /* @__PURE__ */ getDefaultExportFromCjs$1(majorExports);
class ProxyBus {
  bus;
  constructor(bus2) {
    if (typeof bus2.getVersion !== "function" || !valid(bus2.getVersion())) {
      console.warn("Proxying an event bus with an unknown or invalid version");
    } else if (major(bus2.getVersion()) !== major(this.getVersion())) {
      console.warn(
        "Proxying an event bus of version " + bus2.getVersion() + " with " + this.getVersion()
      );
    }
    this.bus = bus2;
  }
  getVersion() {
    return "3.3.2";
  }
  subscribe(name, handler) {
    this.bus.subscribe(name, handler);
  }
  unsubscribe(name, handler) {
    this.bus.unsubscribe(name, handler);
  }
  emit(name, ...event) {
    this.bus.emit(name, ...event);
  }
}
class SimpleBus {
  handlers = /* @__PURE__ */ new Map();
  getVersion() {
    return "3.3.2";
  }
  subscribe(name, handler) {
    this.handlers.set(
      name,
      (this.handlers.get(name) || []).concat(
        handler
      )
    );
  }
  unsubscribe(name, handler) {
    this.handlers.set(
      name,
      (this.handlers.get(name) || []).filter((h) => h !== handler)
    );
  }
  emit(name, ...event) {
    const handlers = this.handlers.get(name) || [];
    handlers.forEach((h) => {
      try {
        ;
        h(event[0]);
      } catch (e) {
        console.error("could not invoke event listener", e);
      }
    });
  }
}
let bus = null;
function getBus() {
  if (bus !== null) {
    return bus;
  }
  if (typeof window === "undefined") {
    return new Proxy({}, {
      get: () => {
        return () => console.error(
          "Window not available, EventBus can not be established!"
        );
      }
    });
  }
  if (window.OC?._eventBus && typeof window._nc_event_bus === "undefined") {
    console.warn(
      "found old event bus instance at OC._eventBus. Update your version!"
    );
    window._nc_event_bus = window.OC._eventBus;
  }
  if (typeof window?._nc_event_bus !== "undefined") {
    bus = new ProxyBus(window._nc_event_bus);
  } else {
    bus = window._nc_event_bus = new SimpleBus();
  }
  return bus;
}
function subscribe(name, handler) {
  getBus().subscribe(name, handler);
}
function emit(name, ...event) {
  getBus().emit(name, ...event);
}
function loadState(app, key, fallback) {
  const elem = document.querySelector(`#initial-state-${app}-${key}`);
  if (elem === null) {
    if (fallback !== void 0) {
      return fallback;
    }
    throw new Error(`Could not find initial state ${key} of ${app}`);
  }
  try {
    return JSON.parse(atob(elem.value));
  } catch (e) {
    throw new Error(`Could not parse initial state ${key} of ${app}`);
  }
}
Vue.util.warn;
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function toValue(r) {
  return typeof r === "function" ? r() : unref(r);
}
const isClient = typeof window !== "undefined" && typeof document !== "undefined";
typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
const notNullish = (val) => val != null;
const toString$1 = Object.prototype.toString;
const isObject$1 = (val) => toString$1.call(val) === "[object Object]";
const noop$1 = () => {
};
function getLifeCycleTarget(target2) {
  return getCurrentInstance();
}
function tryOnMounted(fn, sync = true, target2) {
  const instance = getLifeCycleTarget();
  if (instance)
    onMounted(fn, target2);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
Vue.util.warn;
const defaultWindow = isClient ? window : void 0;
function unrefElement(elRef) {
  var _a2;
  const plain = toValue(elRef);
  return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
}
function useEventListener(...args) {
  let target2;
  let events2;
  let listeners;
  let options;
  if (typeof args[0] === "string" || Array.isArray(args[0])) {
    [events2, listeners, options] = args;
    target2 = defaultWindow;
  } else {
    [target2, events2, listeners, options] = args;
  }
  if (!target2)
    return noop$1;
  if (!Array.isArray(events2))
    events2 = [events2];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register2 = (el, event, listener, options2) => {
    el.addEventListener(event, listener, options2);
    return () => el.removeEventListener(event, listener, options2);
  };
  const stopWatch = watch(
    () => [unrefElement(target2), toValue(options)],
    ([el, options2]) => {
      cleanup();
      if (!el)
        return;
      const optionsClone = isObject$1(options2) ? { ...options2 } : options2;
      cleanups.push(
        ...events2.flatMap((event) => {
          return listeners.map((listener) => register2(el, event, listener, optionsClone));
        })
      );
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
function useMounted() {
  const isMounted = ref$1(false);
  const instance = getCurrentInstance();
  if (instance) {
    onMounted(() => {
      isMounted.value = true;
    }, void 0);
  }
  return isMounted;
}
function useSupported(callback) {
  const isMounted = useMounted();
  return computed(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
function useMutationObserver(target2, callback, options = {}) {
  const { window: window2 = defaultWindow, ...mutationOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed(() => {
    const value = toValue(target2);
    const items = (Array.isArray(value) ? value : [value]).map(unrefElement).filter(notNullish);
    return new Set(items);
  });
  const stopWatch = watch(
    () => targets.value,
    (targets2) => {
      cleanup();
      if (isSupported.value && targets2.size) {
        observer = new MutationObserver(callback);
        targets2.forEach((el) => observer.observe(el, mutationOptions));
      }
    },
    { immediate: true, flush: "post" }
  );
  const takeRecords = () => {
    return observer == null ? void 0 : observer.takeRecords();
  };
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop,
    takeRecords
  };
}
function useMediaQuery(query2, options = {}) {
  const { window: window2 = defaultWindow } = options;
  const isSupported = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
  let mediaQuery;
  const matches2 = ref$1(false);
  const handler = (event) => {
    matches2.value = event.matches;
  };
  const cleanup = () => {
    if (!mediaQuery)
      return;
    if ("removeEventListener" in mediaQuery)
      mediaQuery.removeEventListener("change", handler);
    else
      mediaQuery.removeListener(handler);
  };
  const stopWatch = watchEffect(() => {
    if (!isSupported.value)
      return;
    cleanup();
    mediaQuery = window2.matchMedia(toValue(query2));
    if ("addEventListener" in mediaQuery)
      mediaQuery.addEventListener("change", handler);
    else
      mediaQuery.addListener(handler);
    matches2.value = mediaQuery.matches;
  });
  tryOnScopeDispose(() => {
    stopWatch();
    cleanup();
    mediaQuery = void 0;
  });
  return matches2;
}
function useResizeObserver(target2, callback, options = {}) {
  const { window: window2 = defaultWindow, ...observerOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed(() => {
    const _targets = toValue(target2);
    return Array.isArray(_targets) ? _targets.map((el) => unrefElement(el)) : [unrefElement(_targets)];
  });
  const stopWatch = watch(
    targets,
    (els) => {
      cleanup();
      if (isSupported.value && window2) {
        observer = new ResizeObserver(callback);
        for (const _el of els) {
          if (_el)
            observer.observe(_el, observerOptions);
        }
      }
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}
function useElementBounding(target2, options = {}) {
  const {
    reset = true,
    windowResize = true,
    windowScroll = true,
    immediate = true,
    updateTiming = "sync"
  } = options;
  const height = ref$1(0);
  const bottom = ref$1(0);
  const left = ref$1(0);
  const right = ref$1(0);
  const top = ref$1(0);
  const width = ref$1(0);
  const x = ref$1(0);
  const y = ref$1(0);
  function recalculate() {
    const el = unrefElement(target2);
    if (!el) {
      if (reset) {
        height.value = 0;
        bottom.value = 0;
        left.value = 0;
        right.value = 0;
        top.value = 0;
        width.value = 0;
        x.value = 0;
        y.value = 0;
      }
      return;
    }
    const rect = el.getBoundingClientRect();
    height.value = rect.height;
    bottom.value = rect.bottom;
    left.value = rect.left;
    right.value = rect.right;
    top.value = rect.top;
    width.value = rect.width;
    x.value = rect.x;
    y.value = rect.y;
  }
  function update() {
    if (updateTiming === "sync")
      recalculate();
    else if (updateTiming === "next-frame")
      requestAnimationFrame(() => recalculate());
  }
  useResizeObserver(target2, update);
  watch(() => unrefElement(target2), (ele) => !ele && update());
  useMutationObserver(target2, update, {
    attributeFilter: ["style", "class"]
  });
  if (windowScroll)
    useEventListener("scroll", update, { capture: true, passive: true });
  if (windowResize)
    useEventListener("resize", update, { passive: true });
  tryOnMounted(() => {
    if (immediate)
      update();
  });
  return {
    height,
    bottom,
    left,
    right,
    top,
    width,
    x,
    y,
    update
  };
}
function useElementSize(target2, initialSize = { width: 0, height: 0 }, options = {}) {
  const { window: window2 = defaultWindow, box = "content-box" } = options;
  const isSVG2 = computed(() => {
    var _a2, _b;
    return (_b = (_a2 = unrefElement(target2)) == null ? void 0 : _a2.namespaceURI) == null ? void 0 : _b.includes("svg");
  });
  const width = ref$1(initialSize.width);
  const height = ref$1(initialSize.height);
  const { stop: stop1 } = useResizeObserver(
    target2,
    ([entry]) => {
      const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
      if (window2 && isSVG2.value) {
        const $elem = unrefElement(target2);
        if ($elem) {
          const rect = $elem.getBoundingClientRect();
          width.value = rect.width;
          height.value = rect.height;
        }
      } else {
        if (boxSize) {
          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];
          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);
          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);
        } else {
          width.value = entry.contentRect.width;
          height.value = entry.contentRect.height;
        }
      }
    },
    options
  );
  tryOnMounted(() => {
    const ele = unrefElement(target2);
    if (ele) {
      width.value = "offsetWidth" in ele ? ele.offsetWidth : initialSize.width;
      height.value = "offsetHeight" in ele ? ele.offsetHeight : initialSize.height;
    }
  });
  const stop2 = watch(
    () => unrefElement(target2),
    (ele) => {
      width.value = ele ? initialSize.width : 0;
      height.value = ele ? initialSize.height : 0;
    }
  );
  function stop() {
    stop1();
    stop2();
  }
  return {
    width,
    height,
    stop
  };
}
function useSwipe(target2, options = {}) {
  const {
    threshold = 50,
    onSwipe,
    onSwipeEnd,
    onSwipeStart,
    passive = true,
    window: window2 = defaultWindow
  } = options;
  const coordsStart = reactive({ x: 0, y: 0 });
  const coordsEnd = reactive({ x: 0, y: 0 });
  const diffX = computed(() => coordsStart.x - coordsEnd.x);
  const diffY = computed(() => coordsStart.y - coordsEnd.y);
  const { max: max2, abs } = Math;
  const isThresholdExceeded = computed(() => max2(abs(diffX.value), abs(diffY.value)) >= threshold);
  const isSwiping = ref$1(false);
  const direction = computed(() => {
    if (!isThresholdExceeded.value)
      return "none";
    if (abs(diffX.value) > abs(diffY.value)) {
      return diffX.value > 0 ? "left" : "right";
    } else {
      return diffY.value > 0 ? "up" : "down";
    }
  });
  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];
  const updateCoordsStart = (x, y) => {
    coordsStart.x = x;
    coordsStart.y = y;
  };
  const updateCoordsEnd = (x, y) => {
    coordsEnd.x = x;
    coordsEnd.y = y;
  };
  let listenerOptions;
  const isPassiveEventSupported = checkPassiveEventSupport(window2 == null ? void 0 : window2.document);
  if (!passive)
    listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true };
  else
    listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false };
  const onTouchEnd2 = (e) => {
    if (isSwiping.value)
      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);
    isSwiping.value = false;
  };
  const stops = [
    useEventListener(target2, "touchstart", (e) => {
      if (e.touches.length !== 1)
        return;
      const [x, y] = getTouchEventCoords(e);
      updateCoordsStart(x, y);
      updateCoordsEnd(x, y);
      onSwipeStart == null ? void 0 : onSwipeStart(e);
    }, listenerOptions),
    useEventListener(target2, "touchmove", (e) => {
      if (e.touches.length !== 1)
        return;
      const [x, y] = getTouchEventCoords(e);
      updateCoordsEnd(x, y);
      if (listenerOptions.capture && !listenerOptions.passive && Math.abs(diffX.value) > Math.abs(diffY.value))
        e.preventDefault();
      if (!isSwiping.value && isThresholdExceeded.value)
        isSwiping.value = true;
      if (isSwiping.value)
        onSwipe == null ? void 0 : onSwipe(e);
    }, listenerOptions),
    useEventListener(target2, ["touchend", "touchcancel"], onTouchEnd2, listenerOptions)
  ];
  const stop = () => stops.forEach((s) => s());
  return {
    isPassiveEventSupported,
    isSwiping,
    direction,
    coordsStart,
    coordsEnd,
    lengthX: diffX,
    lengthY: diffY,
    stop
  };
}
function checkPassiveEventSupport(document2) {
  if (!document2)
    return false;
  let supportsPassive2 = false;
  const optionsBlock = {
    get passive() {
      supportsPassive2 = true;
      return false;
    }
  };
  document2.addEventListener("x", noop$1, optionsBlock);
  document2.removeEventListener("x", noop$1);
  return supportsPassive2;
}
function useWindowSize(options = {}) {
  const {
    window: window2 = defaultWindow,
    initialWidth = Number.POSITIVE_INFINITY,
    initialHeight = Number.POSITIVE_INFINITY,
    listenOrientation = true,
    includeScrollbar = true,
    type = "inner"
  } = options;
  const width = ref$1(initialWidth);
  const height = ref$1(initialHeight);
  const update = () => {
    if (window2) {
      if (type === "outer") {
        width.value = window2.outerWidth;
        height.value = window2.outerHeight;
      } else if (includeScrollbar) {
        width.value = window2.innerWidth;
        height.value = window2.innerHeight;
      } else {
        width.value = window2.document.documentElement.clientWidth;
        height.value = window2.document.documentElement.clientHeight;
      }
    }
  };
  update();
  tryOnMounted(update);
  useEventListener("resize", update, { passive: true });
  if (listenOrientation) {
    const matches2 = useMediaQuery("(orientation: portrait)");
    watch(matches2, () => update());
  }
  return { width, height };
}
var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var __objRest$1 = (source, exclude) => {
  var target2 = {};
  for (var prop in source)
    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
      target2[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
        target2[prop] = source[prop];
    }
  return target2;
};
function normalizeComponent$4(scriptExports, render211, staticRenderFns2, functionalTemplate, injectStyles, scopeId, moduleIdentifier, shadowMode) {
  var options = typeof scriptExports === "function" ? scriptExports.options : scriptExports;
  if (render211) {
    options.render = render211;
    options.staticRenderFns = staticRenderFns2;
    options._compiled = true;
  }
  var hook;
  if (injectStyles) {
    hook = injectStyles;
  }
  if (hook) {
    if (options.functional) {
      options._injectStyles = hook;
      var originalRender = options.render;
      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }
  return {
    exports: scriptExports,
    options
  };
}
const __vue2_script$1$1 = {
  name: "splitpanes",
  props: {
    horizontal: { type: Boolean },
    pushOtherPanes: { type: Boolean, default: true },
    dblClickSplitter: { type: Boolean, default: true },
    rtl: { type: Boolean, default: false },
    firstSplitter: { type: Boolean }
  },
  provide() {
    return {
      requestUpdate: this.requestUpdate,
      onPaneAdd: this.onPaneAdd,
      onPaneRemove: this.onPaneRemove,
      onPaneClick: this.onPaneClick
    };
  },
  data: () => ({
    container: null,
    ready: false,
    panes: [],
    touch: {
      mouseDown: false,
      dragging: false,
      activeSplitter: null
    },
    splitterTaps: {
      splitter: null,
      timeoutId: null
    }
  }),
  computed: {
    panesCount() {
      return this.panes.length;
    },
    indexedPanes() {
      return this.panes.reduce((obj, pane2) => (obj[pane2.id] = pane2) && obj, {});
    }
  },
  methods: {
    updatePaneComponents() {
      this.panes.forEach((pane2) => {
        pane2.update && pane2.update({
          [this.horizontal ? "height" : "width"]: `${this.indexedPanes[pane2.id].size}%`
        });
      });
    },
    bindEvents() {
      document.addEventListener("mousemove", this.onMouseMove, { passive: false });
      document.addEventListener("mouseup", this.onMouseUp);
      if ("ontouchstart" in window) {
        document.addEventListener("touchmove", this.onMouseMove, { passive: false });
        document.addEventListener("touchend", this.onMouseUp);
      }
    },
    unbindEvents() {
      document.removeEventListener("mousemove", this.onMouseMove, { passive: false });
      document.removeEventListener("mouseup", this.onMouseUp);
      if ("ontouchstart" in window) {
        document.removeEventListener("touchmove", this.onMouseMove, { passive: false });
        document.removeEventListener("touchend", this.onMouseUp);
      }
    },
    onMouseDown(event, splitterIndex) {
      this.bindEvents();
      this.touch.mouseDown = true;
      this.touch.activeSplitter = splitterIndex;
    },
    onMouseMove(event) {
      if (this.touch.mouseDown) {
        event.preventDefault();
        this.touch.dragging = true;
        this.calculatePanesSize(this.getCurrentMouseDrag(event));
        this.$emit("resize", this.panes.map((pane2) => ({ min: pane2.min, max: pane2.max, size: pane2.size })));
      }
    },
    onMouseUp() {
      if (this.touch.dragging) {
        this.$emit("resized", this.panes.map((pane2) => ({ min: pane2.min, max: pane2.max, size: pane2.size })));
      }
      this.touch.mouseDown = false;
      setTimeout(() => {
        this.touch.dragging = false;
        this.unbindEvents();
      }, 100);
    },
    onSplitterClick(event, splitterIndex) {
      if ("ontouchstart" in window) {
        event.preventDefault();
        if (this.dblClickSplitter) {
          if (this.splitterTaps.splitter === splitterIndex) {
            clearTimeout(this.splitterTaps.timeoutId);
            this.splitterTaps.timeoutId = null;
            this.onSplitterDblClick(event, splitterIndex);
            this.splitterTaps.splitter = null;
          } else {
            this.splitterTaps.splitter = splitterIndex;
            this.splitterTaps.timeoutId = setTimeout(() => {
              this.splitterTaps.splitter = null;
            }, 500);
          }
        }
      }
      if (!this.touch.dragging)
        this.$emit("splitter-click", this.panes[splitterIndex]);
    },
    onSplitterDblClick(event, splitterIndex) {
      let totalMinSizes = 0;
      this.panes = this.panes.map((pane2, i) => {
        pane2.size = i === splitterIndex ? pane2.max : pane2.min;
        if (i !== splitterIndex)
          totalMinSizes += pane2.min;
        return pane2;
      });
      this.panes[splitterIndex].size -= totalMinSizes;
      this.$emit("pane-maximize", this.panes[splitterIndex]);
    },
    onPaneClick(event, paneId) {
      this.$emit("pane-click", this.indexedPanes[paneId]);
    },
    getCurrentMouseDrag(event) {
      const rect = this.container.getBoundingClientRect();
      const { clientX, clientY } = "ontouchstart" in window && event.touches ? event.touches[0] : event;
      return {
        x: clientX - rect.left,
        y: clientY - rect.top
      };
    },
    getCurrentDragPercentage(drag) {
      drag = drag[this.horizontal ? "y" : "x"];
      const containerSize = this.container[this.horizontal ? "clientHeight" : "clientWidth"];
      if (this.rtl && !this.horizontal)
        drag = containerSize - drag;
      return drag * 100 / containerSize;
    },
    calculatePanesSize(drag) {
      const splitterIndex = this.touch.activeSplitter;
      let sums = {
        prevPanesSize: this.sumPrevPanesSize(splitterIndex),
        nextPanesSize: this.sumNextPanesSize(splitterIndex),
        prevReachedMinPanes: 0,
        nextReachedMinPanes: 0
      };
      const minDrag = 0 + (this.pushOtherPanes ? 0 : sums.prevPanesSize);
      const maxDrag = 100 - (this.pushOtherPanes ? 0 : sums.nextPanesSize);
      const dragPercentage = Math.max(Math.min(this.getCurrentDragPercentage(drag), maxDrag), minDrag);
      let panesToResize = [splitterIndex, splitterIndex + 1];
      let paneBefore = this.panes[panesToResize[0]] || null;
      let paneAfter = this.panes[panesToResize[1]] || null;
      const paneBeforeMaxReached = paneBefore.max < 100 && dragPercentage >= paneBefore.max + sums.prevPanesSize;
      const paneAfterMaxReached = paneAfter.max < 100 && dragPercentage <= 100 - (paneAfter.max + this.sumNextPanesSize(splitterIndex + 1));
      if (paneBeforeMaxReached || paneAfterMaxReached) {
        if (paneBeforeMaxReached) {
          paneBefore.size = paneBefore.max;
          paneAfter.size = Math.max(100 - paneBefore.max - sums.prevPanesSize - sums.nextPanesSize, 0);
        } else {
          paneBefore.size = Math.max(100 - paneAfter.max - sums.prevPanesSize - this.sumNextPanesSize(splitterIndex + 1), 0);
          paneAfter.size = paneAfter.max;
        }
        return;
      }
      if (this.pushOtherPanes) {
        const vars = this.doPushOtherPanes(sums, dragPercentage);
        if (!vars)
          return;
        ({ sums, panesToResize } = vars);
        paneBefore = this.panes[panesToResize[0]] || null;
        paneAfter = this.panes[panesToResize[1]] || null;
      }
      if (paneBefore !== null) {
        paneBefore.size = Math.min(Math.max(dragPercentage - sums.prevPanesSize - sums.prevReachedMinPanes, paneBefore.min), paneBefore.max);
      }
      if (paneAfter !== null) {
        paneAfter.size = Math.min(Math.max(100 - dragPercentage - sums.nextPanesSize - sums.nextReachedMinPanes, paneAfter.min), paneAfter.max);
      }
    },
    doPushOtherPanes(sums, dragPercentage) {
      const splitterIndex = this.touch.activeSplitter;
      const panesToResize = [splitterIndex, splitterIndex + 1];
      if (dragPercentage < sums.prevPanesSize + this.panes[panesToResize[0]].min) {
        panesToResize[0] = this.findPrevExpandedPane(splitterIndex).index;
        sums.prevReachedMinPanes = 0;
        if (panesToResize[0] < splitterIndex) {
          this.panes.forEach((pane2, i) => {
            if (i > panesToResize[0] && i <= splitterIndex) {
              pane2.size = pane2.min;
              sums.prevReachedMinPanes += pane2.min;
            }
          });
        }
        sums.prevPanesSize = this.sumPrevPanesSize(panesToResize[0]);
        if (panesToResize[0] === void 0) {
          sums.prevReachedMinPanes = 0;
          this.panes[0].size = this.panes[0].min;
          this.panes.forEach((pane2, i) => {
            if (i > 0 && i <= splitterIndex) {
              pane2.size = pane2.min;
              sums.prevReachedMinPanes += pane2.min;
            }
          });
          this.panes[panesToResize[1]].size = 100 - sums.prevReachedMinPanes - this.panes[0].min - sums.prevPanesSize - sums.nextPanesSize;
          return null;
        }
      }
      if (dragPercentage > 100 - sums.nextPanesSize - this.panes[panesToResize[1]].min) {
        panesToResize[1] = this.findNextExpandedPane(splitterIndex).index;
        sums.nextReachedMinPanes = 0;
        if (panesToResize[1] > splitterIndex + 1) {
          this.panes.forEach((pane2, i) => {
            if (i > splitterIndex && i < panesToResize[1]) {
              pane2.size = pane2.min;
              sums.nextReachedMinPanes += pane2.min;
            }
          });
        }
        sums.nextPanesSize = this.sumNextPanesSize(panesToResize[1] - 1);
        if (panesToResize[1] === void 0) {
          sums.nextReachedMinPanes = 0;
          this.panes[this.panesCount - 1].size = this.panes[this.panesCount - 1].min;
          this.panes.forEach((pane2, i) => {
            if (i < this.panesCount - 1 && i >= splitterIndex + 1) {
              pane2.size = pane2.min;
              sums.nextReachedMinPanes += pane2.min;
            }
          });
          this.panes[panesToResize[0]].size = 100 - sums.prevPanesSize - sums.nextReachedMinPanes - this.panes[this.panesCount - 1].min - sums.nextPanesSize;
          return null;
        }
      }
      return { sums, panesToResize };
    },
    sumPrevPanesSize(splitterIndex) {
      return this.panes.reduce((total, pane2, i) => total + (i < splitterIndex ? pane2.size : 0), 0);
    },
    sumNextPanesSize(splitterIndex) {
      return this.panes.reduce((total, pane2, i) => total + (i > splitterIndex + 1 ? pane2.size : 0), 0);
    },
    findPrevExpandedPane(splitterIndex) {
      const pane2 = [...this.panes].reverse().find((p) => p.index < splitterIndex && p.size > p.min);
      return pane2 || {};
    },
    findNextExpandedPane(splitterIndex) {
      const pane2 = this.panes.find((p) => p.index > splitterIndex + 1 && p.size > p.min);
      return pane2 || {};
    },
    checkSplitpanesNodes() {
      const children = Array.from(this.container.children);
      children.forEach((child) => {
        const isPane = child.classList.contains("splitpanes__pane");
        const isSplitter = child.classList.contains("splitpanes__splitter");
        if (!isPane && !isSplitter) {
          child.parentNode.removeChild(child);
          console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed.");
          return;
        }
      });
    },
    addSplitter(paneIndex, nextPaneNode, isVeryFirst = false) {
      const splitterIndex = paneIndex - 1;
      const elm = document.createElement("div");
      elm.classList.add("splitpanes__splitter");
      if (!isVeryFirst) {
        elm.onmousedown = (event) => this.onMouseDown(event, splitterIndex);
        if (typeof window !== "undefined" && "ontouchstart" in window) {
          elm.ontouchstart = (event) => this.onMouseDown(event, splitterIndex);
        }
        elm.onclick = (event) => this.onSplitterClick(event, splitterIndex + 1);
      }
      if (this.dblClickSplitter) {
        elm.ondblclick = (event) => this.onSplitterDblClick(event, splitterIndex + 1);
      }
      nextPaneNode.parentNode.insertBefore(elm, nextPaneNode);
    },
    removeSplitter(node) {
      node.onmousedown = void 0;
      node.onclick = void 0;
      node.ondblclick = void 0;
      node.parentNode.removeChild(node);
    },
    redoSplitters() {
      const children = Array.from(this.container.children);
      children.forEach((el) => {
        if (el.className.includes("splitpanes__splitter"))
          this.removeSplitter(el);
      });
      let paneIndex = 0;
      children.forEach((el) => {
        if (el.className.includes("splitpanes__pane")) {
          if (!paneIndex && this.firstSplitter)
            this.addSplitter(paneIndex, el, true);
          else if (paneIndex)
            this.addSplitter(paneIndex, el);
          paneIndex++;
        }
      });
    },
    requestUpdate(_a2) {
      var _b = _a2, { target: target2 } = _b, args = __objRest$1(_b, ["target"]);
      const pane2 = this.indexedPanes[target2._uid];
      Object.entries(args).forEach(([key, value]) => pane2[key] = value);
    },
    onPaneAdd(pane2) {
      let index2 = -1;
      Array.from(pane2.$el.parentNode.children).some((el) => {
        if (el.className.includes("splitpanes__pane"))
          index2++;
        return el === pane2.$el;
      });
      const min2 = parseFloat(pane2.minSize);
      const max2 = parseFloat(pane2.maxSize);
      this.panes.splice(index2, 0, {
        id: pane2._uid,
        index: index2,
        min: isNaN(min2) ? 0 : min2,
        max: isNaN(max2) ? 100 : max2,
        size: pane2.size === null ? null : parseFloat(pane2.size),
        givenSize: pane2.size,
        update: pane2.update
      });
      this.panes.forEach((p, i) => p.index = i);
      if (this.ready) {
        this.$nextTick(() => {
          this.redoSplitters();
          this.resetPaneSizes({ addedPane: this.panes[index2] });
          this.$emit("pane-add", { index: index2, panes: this.panes.map((pane3) => ({ min: pane3.min, max: pane3.max, size: pane3.size })) });
        });
      }
    },
    onPaneRemove(pane2) {
      const index2 = this.panes.findIndex((p) => p.id === pane2._uid);
      const removed = this.panes.splice(index2, 1)[0];
      this.panes.forEach((p, i) => p.index = i);
      this.$nextTick(() => {
        this.redoSplitters();
        this.resetPaneSizes({ removedPane: __spreadProps$1(__spreadValues$1({}, removed), { index: index2 }) });
        this.$emit("pane-remove", { removed, panes: this.panes.map((pane3) => ({ min: pane3.min, max: pane3.max, size: pane3.size })) });
      });
    },
    resetPaneSizes(changedPanes = {}) {
      if (!changedPanes.addedPane && !changedPanes.removedPane)
        this.initialPanesSizing();
      else if (this.panes.some((pane2) => pane2.givenSize !== null || pane2.min || pane2.max < 100))
        this.equalizeAfterAddOrRemove(changedPanes);
      else
        this.equalize();
      if (this.ready)
        this.$emit("resized", this.panes.map((pane2) => ({ min: pane2.min, max: pane2.max, size: pane2.size })));
    },
    equalize() {
      const equalSpace = 100 / this.panesCount;
      let leftToAllocate = 0;
      let ungrowable = [];
      let unshrinkable = [];
      this.panes.forEach((pane2) => {
        pane2.size = Math.max(Math.min(equalSpace, pane2.max), pane2.min);
        leftToAllocate -= pane2.size;
        if (pane2.size >= pane2.max)
          ungrowable.push(pane2.id);
        if (pane2.size <= pane2.min)
          unshrinkable.push(pane2.id);
      });
      if (leftToAllocate > 0.1)
        this.readjustSizes(leftToAllocate, ungrowable, unshrinkable);
    },
    initialPanesSizing() {
      100 / this.panesCount;
      let leftToAllocate = 100;
      let ungrowable = [];
      let unshrinkable = [];
      let definedSizes = 0;
      this.panes.forEach((pane2) => {
        leftToAllocate -= pane2.size;
        if (pane2.size !== null)
          definedSizes++;
        if (pane2.size >= pane2.max)
          ungrowable.push(pane2.id);
        if (pane2.size <= pane2.min)
          unshrinkable.push(pane2.id);
      });
      let leftToAllocate2 = 100;
      if (leftToAllocate > 0.1) {
        this.panes.forEach((pane2) => {
          if (pane2.size === null) {
            pane2.size = Math.max(Math.min(leftToAllocate / (this.panesCount - definedSizes), pane2.max), pane2.min);
          }
          leftToAllocate2 -= pane2.size;
        });
        if (leftToAllocate2 > 0.1)
          this.readjustSizes(leftToAllocate, ungrowable, unshrinkable);
      }
    },
    equalizeAfterAddOrRemove({ addedPane, removedPane } = {}) {
      let equalSpace = 100 / this.panesCount;
      let leftToAllocate = 0;
      let ungrowable = [];
      let unshrinkable = [];
      if (addedPane && addedPane.givenSize !== null) {
        equalSpace = (100 - addedPane.givenSize) / (this.panesCount - 1);
      }
      this.panes.forEach((pane2) => {
        leftToAllocate -= pane2.size;
        if (pane2.size >= pane2.max)
          ungrowable.push(pane2.id);
        if (pane2.size <= pane2.min)
          unshrinkable.push(pane2.id);
      });
      if (Math.abs(leftToAllocate) < 0.1)
        return;
      this.panes.forEach((pane2) => {
        if (addedPane && addedPane.givenSize !== null && addedPane.id === pane2.id)
          ;
        else
          pane2.size = Math.max(Math.min(equalSpace, pane2.max), pane2.min);
        leftToAllocate -= pane2.size;
        if (pane2.size >= pane2.max)
          ungrowable.push(pane2.id);
        if (pane2.size <= pane2.min)
          unshrinkable.push(pane2.id);
      });
      if (leftToAllocate > 0.1)
        this.readjustSizes(leftToAllocate, ungrowable, unshrinkable);
    },
    readjustSizes(leftToAllocate, ungrowable, unshrinkable) {
      let equalSpaceToAllocate;
      if (leftToAllocate > 0)
        equalSpaceToAllocate = leftToAllocate / (this.panesCount - ungrowable.length);
      else
        equalSpaceToAllocate = leftToAllocate / (this.panesCount - unshrinkable.length);
      this.panes.forEach((pane2, i) => {
        if (leftToAllocate > 0 && !ungrowable.includes(pane2.id)) {
          const newPaneSize = Math.max(Math.min(pane2.size + equalSpaceToAllocate, pane2.max), pane2.min);
          const allocated = newPaneSize - pane2.size;
          leftToAllocate -= allocated;
          pane2.size = newPaneSize;
        } else if (!unshrinkable.includes(pane2.id)) {
          const newPaneSize = Math.max(Math.min(pane2.size + equalSpaceToAllocate, pane2.max), pane2.min);
          const allocated = newPaneSize - pane2.size;
          leftToAllocate -= allocated;
          pane2.size = newPaneSize;
        }
        pane2.update({
          [this.horizontal ? "height" : "width"]: `${this.indexedPanes[pane2.id].size}%`
        });
      });
      if (Math.abs(leftToAllocate) > 0.1) {
        this.$nextTick(() => {
          if (this.ready) {
            console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
          }
        });
      }
    }
  },
  watch: {
    panes: {
      deep: true,
      immediate: false,
      handler() {
        this.updatePaneComponents();
      }
    },
    horizontal() {
      this.updatePaneComponents();
    },
    firstSplitter() {
      this.redoSplitters();
    },
    dblClickSplitter(enable) {
      const splitters = [...this.container.querySelectorAll(".splitpanes__splitter")];
      splitters.forEach((splitter, i) => {
        splitter.ondblclick = enable ? (event) => this.onSplitterDblClick(event, i) : void 0;
      });
    }
  },
  beforeDestroy() {
    this.ready = false;
  },
  mounted() {
    this.container = this.$refs.container;
    this.checkSplitpanesNodes();
    this.redoSplitters();
    this.resetPaneSizes();
    this.$emit("ready");
    this.ready = true;
  },
  render(h) {
    return h("div", {
      ref: "container",
      class: [
        "splitpanes",
        `splitpanes--${this.horizontal ? "horizontal" : "vertical"}`,
        {
          "splitpanes--dragging": this.touch.dragging
        }
      ]
    }, this.$slots.default);
  }
};
let __vue2_render$3, __vue2_staticRenderFns$3;
const __cssModules$1$1 = {};
var __component__$1$5 = /* @__PURE__ */ normalizeComponent$4(__vue2_script$1$1, __vue2_render$3, __vue2_staticRenderFns$3, false, __vue2_injectStyles$1$1);
function __vue2_injectStyles$1$1(context) {
  for (let o in __cssModules$1$1) {
    this[o] = __cssModules$1$1[o];
  }
}
var splitpanes = /* @__PURE__ */ function() {
  return __component__$1$5.exports;
}();
var render$3 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "splitpanes__pane", style: _vm.style, on: { "click": function($event) {
    return _vm.onPaneClick($event, _vm._uid);
  } } }, [_vm._t("default")], 2);
};
var staticRenderFns$3 = [];
const __vue2_script$6 = {
  name: "pane",
  inject: ["requestUpdate", "onPaneAdd", "onPaneRemove", "onPaneClick"],
  props: {
    size: { type: [Number, String], default: null },
    minSize: { type: [Number, String], default: 0 },
    maxSize: { type: [Number, String], default: 100 }
  },
  data: () => ({
    style: {}
  }),
  mounted() {
    this.onPaneAdd(this);
  },
  beforeDestroy() {
    this.onPaneRemove(this);
  },
  methods: {
    update(style2) {
      this.style = style2;
    }
  },
  computed: {
    sizeNumber() {
      return this.size || this.size === 0 ? parseFloat(this.size) : null;
    },
    minSizeNumber() {
      return parseFloat(this.minSize);
    },
    maxSizeNumber() {
      return parseFloat(this.maxSize);
    }
  },
  watch: {
    sizeNumber(size2) {
      this.requestUpdate({ target: this, size: size2 });
    },
    minSizeNumber(min2) {
      this.requestUpdate({ target: this, min: min2 });
    },
    maxSizeNumber(max2) {
      this.requestUpdate({ target: this, max: max2 });
    }
  }
};
const __cssModules$6 = {};
var __component__$12 = /* @__PURE__ */ normalizeComponent$4(__vue2_script$6, render$3, staticRenderFns$3, false, __vue2_injectStyles$6);
function __vue2_injectStyles$6(context) {
  for (let o in __cssModules$6) {
    this[o] = __cssModules$6[o];
  }
}
var pane = /* @__PURE__ */ function() {
  return __component__$12.exports;
}();
const MOBILE_BREAKPOINT = 1024;
const MOBILE_SMALL_BREAKPOINT = MOBILE_BREAKPOINT / 2;
const isLessThanBreakpoint = (breakpoint) => document.documentElement.clientWidth < breakpoint;
const isMobile = ref$1(isLessThanBreakpoint(MOBILE_BREAKPOINT));
const isSmallMobile = ref$1(isLessThanBreakpoint(MOBILE_SMALL_BREAKPOINT));
window.addEventListener("resize", () => {
  isMobile.value = isLessThanBreakpoint(MOBILE_BREAKPOINT);
  isSmallMobile.value = isLessThanBreakpoint(MOBILE_SMALL_BREAKPOINT);
}, { passive: true });
function useIsMobile() {
  return readonly(isMobile);
}
readonly(isMobile);
const u = (n2, e, o) => {
  const c = Object.assign({
    escape: true
  }, {}), r = function(i, s) {
    return s = s || {}, i.replace(
      /{([^{}]*)}/g,
      function(l, t2) {
        const a = s[t2];
        return c.escape ? encodeURIComponent(typeof a == "string" || typeof a == "number" ? a.toString() : l) : typeof a == "string" || typeof a == "number" ? a.toString() : l;
      }
    );
  };
  return n2.charAt(0) !== "/" && (n2 = "/" + n2), r(n2, {});
}, _ = (n2, e, o) => {
  var c, r, i;
  const s = Object.assign({
    noRewrite: false
  }, {}), l = (c = void 0) != null ? c : f();
  return ((i = (r = window == null ? void 0 : window.OC) == null ? void 0 : r.config) == null ? void 0 : i.modRewriteWorking) === true && !s.noRewrite ? l + u(n2) : l + "/index.php" + u(n2);
};
function f() {
  let n2 = window._oc_webroot;
  if (typeof n2 > "u") {
    n2 = location.pathname;
    const e = n2.indexOf("/index.php/");
    if (e !== -1)
      n2 = n2.slice(0, e);
    else {
      const o = n2.indexOf("/", 1);
      n2 = n2.slice(0, o > 0 ? o : void 0);
    }
  }
  return n2;
}
/*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */
const {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf: getPrototypeOf$1,
  getOwnPropertyDescriptor
} = Object;
let {
  freeze,
  seal,
  create
} = Object;
let {
  apply,
  construct
} = typeof Reflect !== "undefined" && Reflect;
if (!freeze) {
  freeze = function freeze2(x) {
    return x;
  };
}
if (!seal) {
  seal = function seal2(x) {
    return x;
  };
}
if (!apply) {
  apply = function apply2(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!construct) {
  construct = function construct2(Func, args) {
    return new Func(...args);
  };
}
const arrayForEach = unapply(Array.prototype.forEach);
const arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
const arrayPop = unapply(Array.prototype.pop);
const arrayPush = unapply(Array.prototype.push);
const arraySplice = unapply(Array.prototype.splice);
const stringToLowerCase = unapply(String.prototype.toLowerCase);
const stringToString = unapply(String.prototype.toString);
const stringMatch = unapply(String.prototype.match);
const stringReplace = unapply(String.prototype.replace);
const stringIndexOf = unapply(String.prototype.indexOf);
const stringTrim = unapply(String.prototype.trim);
const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
const regExpTest = unapply(RegExp.prototype.test);
const typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    if (thisArg instanceof RegExp) {
      thisArg.lastIndex = 0;
    }
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
function addToSet(set2, array) {
  let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
  if (setPrototypeOf) {
    setPrototypeOf(set2, null);
  }
  let l = array.length;
  while (l--) {
    let element = array[l];
    if (typeof element === "string") {
      const lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }
        element = lcElement;
      }
    }
    set2[element] = true;
  }
  return set2;
}
function cleanArray(array) {
  for (let index2 = 0; index2 < array.length; index2++) {
    const isPropertyExist = objectHasOwnProperty(array, index2);
    if (!isPropertyExist) {
      array[index2] = null;
    }
  }
  return array;
}
function clone(object) {
  const newObject = create(null);
  for (const [property, value] of entries(object)) {
    const isPropertyExist = objectHasOwnProperty(object, property);
    if (isPropertyExist) {
      if (Array.isArray(value)) {
        newObject[property] = cleanArray(value);
      } else if (value && typeof value === "object" && value.constructor === Object) {
        newObject[property] = clone(value);
      } else {
        newObject[property] = value;
      }
    }
  }
  return newObject;
}
function lookupGetter(object, prop) {
  while (object !== null) {
    const desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf$1(object);
  }
  function fallbackValue() {
    return null;
  }
  return fallbackValue;
}
const html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
const svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
const svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
const svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
const mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
const mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
const text = freeze(["#text"]);
const html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
const svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
const mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
const xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
const TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm);
const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/);
const ARIA_ATTR = seal(/^aria-[\-\w]+$/);
const IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
const ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
const DOCTYPE_NAME = seal(/^html$/i);
const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR,
  ATTR_WHITESPACE,
  CUSTOM_ELEMENT,
  DATA_ATTR,
  DOCTYPE_NAME,
  ERB_EXPR,
  IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA,
  MUSTACHE_EXPR,
  TMPLIT_EXPR
});
const NODE_TYPE = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
};
const getGlobal = function getGlobal2() {
  return typeof window === "undefined" ? null : window;
};
const _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
  if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  let suffix = null;
  const ATTR_NAME = "data-tt-policy-suffix";
  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
    suffix = purifyHostElement.getAttribute(ATTR_NAME);
  }
  const policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML(html2) {
        return html2;
      },
      createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_2) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
const _createHooksMap = function _createHooksMap2() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function createDOMPurify() {
  let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  const DOMPurify = (root) => createDOMPurify(root);
  DOMPurify.version = "3.2.6";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== NODE_TYPE.document || !window2.Element) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  let {
    document: document2
  } = window2;
  const originalDocument = document2;
  const currentScript = originalDocument.currentScript;
  const {
    DocumentFragment,
    HTMLTemplateElement,
    Node,
    Element: Element2,
    NodeFilter,
    NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
    HTMLFormElement,
    DOMParser: DOMParser2,
    trustedTypes
  } = window2;
  const ElementPrototype = Element2.prototype;
  const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  const remove2 = lookupGetter(ElementPrototype, "remove");
  const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  const getParentNode2 = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    const template = document2.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document2 = template.content.ownerDocument;
    }
  }
  let trustedTypesPolicy;
  let emptyHTML = "";
  const {
    implementation,
    createNodeIterator,
    createDocumentFragment,
    getElementsByTagName
  } = document2;
  const {
    importNode
  } = originalDocument;
  let hooks2 = _createHooksMap();
  DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode2 === "function" && implementation && implementation.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: MUSTACHE_EXPR2,
    ERB_EXPR: ERB_EXPR2,
    TMPLIT_EXPR: TMPLIT_EXPR2,
    DATA_ATTR: DATA_ATTR2,
    ARIA_ATTR: ARIA_ATTR2,
    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
    ATTR_WHITESPACE: ATTR_WHITESPACE2,
    CUSTOM_ELEMENT: CUSTOM_ELEMENT2
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: IS_ALLOWED_URI$1
  } = EXPRESSIONS;
  let ALLOWED_TAGS = null;
  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
  let ALLOWED_ATTR = null;
  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
  let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  let FORBID_TAGS = null;
  let FORBID_ATTR = null;
  let ALLOW_ARIA_ATTR = true;
  let ALLOW_DATA_ATTR = true;
  let ALLOW_UNKNOWN_PROTOCOLS = false;
  let ALLOW_SELF_CLOSE_IN_ATTR = true;
  let SAFE_FOR_TEMPLATES = false;
  let SAFE_FOR_XML = true;
  let WHOLE_DOCUMENT = false;
  let SET_CONFIG = false;
  let FORCE_BODY = false;
  let RETURN_DOM = false;
  let RETURN_DOM_FRAGMENT = false;
  let RETURN_TRUSTED_TYPE = false;
  let SANITIZE_DOM = true;
  let SANITIZE_NAMED_PROPS = false;
  const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
  let KEEP_CONTENT = true;
  let IN_PLACE = false;
  let USE_PROFILES = {};
  let FORBID_CONTENTS = null;
  const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let DATA_URI_TAGS = null;
  const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  let URI_SAFE_ATTRIBUTES = null;
  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  let NAMESPACE = HTML_NAMESPACE;
  let IS_EMPTY_INPUT = false;
  let ALLOWED_NAMESPACES = null;
  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
  let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  let HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
  let PARSER_MEDIA_TYPE = null;
  const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  let transformCaseFunc = null;
  let CONFIG = null;
  const formElement = document2.createElement("form");
  const isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  const _parseConfig = function _parseConfig2() {
    let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || typeof cfg !== "object") {
      cfg = {};
    }
    cfg = clone(cfg);
    PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
    ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});
    FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});
    USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
    HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, text);
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (cfg.TRUSTED_TYPES_POLICY) {
      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
      }
      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
      }
      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
      emptyHTML = trustedTypesPolicy.createHTML("");
    } else {
      if (trustedTypesPolicy === void 0) {
        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
      }
      if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
        emptyHTML = trustedTypesPolicy.createHTML("");
      }
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
  const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
  const _checkValidNamespace = function _checkValidNamespace2(element) {
    let parent = getParentNode2(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: "template"
      };
    }
    const tagName2 = stringToLowerCase(element.tagName);
    const parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName2 === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName2 === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName2]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName2 === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName2 === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName2]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      return !ALL_MATHML_TAGS[tagName2] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName2] || !ALL_SVG_TAGS[tagName2]);
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }
    return false;
  };
  const _forceRemove = function _forceRemove2(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });
    try {
      getParentNode2(node).removeChild(node);
    } catch (_2) {
      remove2(node);
    }
  };
  const _removeAttribute = function _removeAttribute2(name, element) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: element.getAttributeNode(name),
        from: element
      });
    } catch (_2) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: element
      });
    }
    element.removeAttribute(name);
    if (name === "is") {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(element);
        } catch (_2) {
        }
      } else {
        try {
          element.setAttribute(name, "");
        } catch (_2) {
        }
      }
    }
  };
  const _initDocument = function _initDocument2(dirty) {
    let doc = null;
    let leadingWhitespace = null;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      const matches2 = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches2 && matches2[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_2) {
      }
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_2) {
      }
    }
    const body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  const _createNodeIterator = function _createNodeIterator2(root) {
    return createNodeIterator.call(
      root.ownerDocument || root,
      root,
      // eslint-disable-next-line no-bitwise
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
      null
    );
  };
  const _isClobbered = function _isClobbered2(element) {
    return element instanceof HTMLFormElement && (typeof element.nodeName !== "string" || typeof element.textContent !== "string" || typeof element.removeChild !== "function" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== "function" || typeof element.setAttribute !== "function" || typeof element.namespaceURI !== "string" || typeof element.insertBefore !== "function" || typeof element.hasChildNodes !== "function");
  };
  const _isNode = function _isNode2(value) {
    return typeof Node === "function" && value instanceof Node;
  };
  function _executeHooks(hooks3, currentNode, data) {
    arrayForEach(hooks3, (hook) => {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  }
  const _sanitizeElements = function _sanitizeElements2(currentNode) {
    let content = null;
    _executeHooks(hooks2.beforeSanitizeElements, currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    const tagName2 = transformCaseFunc(currentNode.nodeName);
    _executeHooks(hooks2.uponSanitizeElement, currentNode, {
      tagName: tagName2,
      allowedTags: ALLOWED_TAGS
    });
    if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName2] || FORBID_TAGS[tagName2]) {
      if (!FORBID_TAGS[tagName2] && _isBasicCustomElement(tagName2)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName2)) {
          return false;
        }
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName2)) {
          return false;
        }
      }
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName2]) {
        const parentNode2 = getParentNode2(currentNode) || currentNode.parentNode;
        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode2) {
          const childCount = childNodes.length;
          for (let i = childCount - 1; i >= 0; --i) {
            const childClone = cloneNode(childNodes[i], true);
            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
            parentNode2.insertBefore(childClone, getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName2 === "noscript" || tagName2 === "noembed" || tagName2 === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
      content = currentNode.textContent;
      arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
        content = stringReplace(content, expr, " ");
      });
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    _executeHooks(hooks2.afterSanitizeElements, currentNode, null);
    return false;
  };
  const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
        // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
      ) ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
    else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
    else if (value) {
      return false;
    } else ;
    return true;
  };
  const _isBasicCustomElement = function _isBasicCustomElement2(tagName2) {
    return tagName2 !== "annotation-xml" && stringMatch(tagName2, CUSTOM_ELEMENT2);
  };
  const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    _executeHooks(hooks2.beforeSanitizeAttributes, currentNode, null);
    const {
      attributes
    } = currentNode;
    if (!attributes || _isClobbered(currentNode)) {
      return;
    }
    const hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR,
      forceKeepAttr: void 0
    };
    let l = attributes.length;
    while (l--) {
      const attr = attributes[l];
      const {
        name,
        namespaceURI,
        value: attrValue
      } = attr;
      const lcName = transformCaseFunc(name);
      const initValue = attrValue;
      let value = name === "value" ? initValue : stringTrim(initValue);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHooks(hooks2.uponSanitizeAttribute, currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
        _removeAttribute(name, currentNode);
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      if (!hookEvent.keepAttr) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          value = stringReplace(value, expr, " ");
        });
      }
      const lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
        if (namespaceURI) ;
        else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case "TrustedHTML": {
              value = trustedTypesPolicy.createHTML(value);
              break;
            }
            case "TrustedScriptURL": {
              value = trustedTypesPolicy.createScriptURL(value);
              break;
            }
          }
        }
      }
      if (value !== initValue) {
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            currentNode.setAttribute(name, value);
          }
          if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
          } else {
            arrayPop(DOMPurify.removed);
          }
        } catch (_2) {
          _removeAttribute(name, currentNode);
        }
      }
    }
    _executeHooks(hooks2.afterSanitizeAttributes, currentNode, null);
  };
  const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    let shadowNode = null;
    const shadowIterator = _createNodeIterator(fragment);
    _executeHooks(hooks2.beforeSanitizeShadowDOM, fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHooks(hooks2.uponSanitizeShadowNode, shadowNode, null);
      _sanitizeElements(shadowNode);
      _sanitizeAttributes(shadowNode);
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
    }
    _executeHooks(hooks2.afterSanitizeShadowDOM, fragment, null);
  };
  DOMPurify.sanitize = function(dirty) {
    let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let body = null;
    let importedNode = null;
    let currentNode = null;
    let returnNode = null;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString === "function") {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      } else {
        throw typeErrorCreate("toString is not a function");
      }
    }
    if (!DOMPurify.isSupported) {
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        const tagName2 = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName2] || FORBID_TAGS[tagName2]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      _sanitizeElements(currentNode);
      _sanitizeAttributes(currentNode);
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
    }
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
    }
    if (SAFE_FOR_TEMPLATES) {
      arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
        serializedHTML = stringReplace(serializedHTML, expr, " ");
      });
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function() {
    let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    const lcTag = transformCaseFunc(tag);
    const lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    arrayPush(hooks2[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint, hookFunction) {
    if (hookFunction !== void 0) {
      const index2 = arrayLastIndexOf(hooks2[entryPoint], hookFunction);
      return index2 === -1 ? void 0 : arraySplice(hooks2[entryPoint], index2, 1)[0];
    }
    return arrayPop(hooks2[entryPoint]);
  };
  DOMPurify.removeHooks = function(entryPoint) {
    hooks2[entryPoint] = [];
  };
  DOMPurify.removeAllHooks = function() {
    hooks2 = _createHooksMap();
  };
  return DOMPurify;
}
var purify = createDOMPurify();
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
var escapeHtml_1;
var hasRequiredEscapeHtml;
function requireEscapeHtml() {
  if (hasRequiredEscapeHtml) return escapeHtml_1;
  hasRequiredEscapeHtml = 1;
  var matchHtmlRegExp = /["'&<>]/;
  escapeHtml_1 = escapeHtml;
  function escapeHtml(string) {
    var str = "" + string;
    var match = matchHtmlRegExp.exec(str);
    if (!match) {
      return str;
    }
    var escape;
    var html2 = "";
    var index2 = 0;
    var lastIndex = 0;
    for (index2 = match.index; index2 < str.length; index2++) {
      switch (str.charCodeAt(index2)) {
        case 34:
          escape = "&quot;";
          break;
        case 38:
          escape = "&amp;";
          break;
        case 39:
          escape = "&#39;";
          break;
        case 60:
          escape = "&lt;";
          break;
        case 62:
          escape = "&gt;";
          break;
        default:
          continue;
      }
      if (lastIndex !== index2) {
        html2 += str.substring(lastIndex, index2);
      }
      lastIndex = index2 + 1;
      html2 += escape;
    }
    return lastIndex !== index2 ? html2 + str.substring(lastIndex, index2) : html2;
  }
  return escapeHtml_1;
}
var escapeHtmlExports = requireEscapeHtml();
const escapeHTML = /* @__PURE__ */ getDefaultExportFromCjs$1(escapeHtmlExports);
/*!
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: GPL-3.0-or-later
 */
Intl.DateTimeFormat().resolvedOptions().locale;
function getLanguage() {
  return document.documentElement.lang || navigator.language;
}
function isRTL(language) {
  const languageCode = getLanguage();
  const rtlLanguages = [
    /* eslint-disable no-multi-spaces */
    "ae",
    // Avestan
    "ar",
    // 'العربية', Arabic
    "arc",
    // Aramaic
    "arz",
    // 'مصرى', Egyptian
    "bcc",
    // 'بلوچی مکرانی', Southern Balochi
    "bqi",
    // 'بختياري', Bakthiari
    "ckb",
    // 'Soranî / کوردی', Sorani
    "dv",
    // Dhivehi
    "fa",
    // 'فارسی', Persian
    "glk",
    // 'گیلکی', Gilaki
    "ha",
    // 'هَوُسَ', Hausa
    "he",
    // 'עברית', Hebrew
    "khw",
    // 'کھوار', Khowar
    "ks",
    // 'कॉशुर / کٲشُر', Kashmiri
    "ku",
    // 'Kurdî / كوردی', Kurdish
    "mzn",
    // 'مازِرونی', Mazanderani
    "nqo",
    // 'ߒߞߏ', N’Ko
    "pnb",
    // 'پنجابی', Western Punjabi
    "ps",
    // 'پښتو', Pashto,
    "sd",
    // 'سنڌي', Sindhi
    "ug",
    // 'Uyghurche / ئۇيغۇرچە', Uyghur
    "ur",
    // 'اردو', Urdu
    "ur-PK",
    // 'اردو', Urdu (nextcloud BCP47 variant)
    "uz-AF",
    // 'اوزبیکی', Uzbek Afghan
    "yi"
    // 'ייִדיש', Yiddish
    /* eslint-enable no-multi-spaces */
  ];
  return rtlLanguages.includes(languageCode);
}
function getAppTranslations(appId) {
  return {
    translations: window._oc_l10n_registry_translations?.[appId] ?? {},
    pluralFunction: window._oc_l10n_registry_plural_functions?.[appId] ?? ((number) => number)
  };
}
/*!
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: GPL-3.0-or-later
 */
function translate(app, text2, placeholdersOrNumber, optionsOrNumber, options) {
  const vars = typeof placeholdersOrNumber === "object" ? placeholdersOrNumber : void 0;
  const number = typeof optionsOrNumber === "number" ? optionsOrNumber : typeof placeholdersOrNumber === "number" ? placeholdersOrNumber : void 0;
  const allOptions = {
    // defaults
    escape: true,
    sanitize: true,
    // overwrite with user config
    ...typeof options === "object" ? options : typeof optionsOrNumber === "object" ? optionsOrNumber : {}
  };
  const identity2 = (value) => value;
  const optSanitize = allOptions.sanitize ? purify.sanitize : identity2;
  const optEscape = allOptions.escape ? escapeHTML : identity2;
  const isValidReplacement = (value) => typeof value === "string" || typeof value === "number";
  const _build = (text22, vars2, number2) => {
    return text22.replace(/%n/g, "" + number2).replace(/{([^{}]*)}/g, (match, key) => {
      if (vars2 === void 0 || !(key in vars2)) {
        return optEscape(match);
      }
      const replacement = vars2[key];
      if (isValidReplacement(replacement)) {
        return optEscape(`${replacement}`);
      } else if (typeof replacement === "object" && isValidReplacement(replacement.value)) {
        const escape = replacement.escape !== false ? escapeHTML : identity2;
        return escape(`${replacement.value}`);
      } else {
        return optEscape(match);
      }
    });
  };
  const bundle = options?.bundle ?? getAppTranslations(app);
  let translation = bundle.translations[text2] || text2;
  translation = Array.isArray(translation) ? translation[0] : translation;
  if (typeof vars === "object" || number !== void 0) {
    return optSanitize(_build(
      translation,
      vars,
      number
    ));
  } else {
    return optSanitize(translation);
  }
}
function translatePlural(app, textSingular, textPlural, number, vars, options) {
  const identifier = "_" + textSingular + "_::_" + textPlural + "_";
  const bundle = options?.bundle ?? getAppTranslations(app);
  const value = bundle.translations[identifier];
  if (typeof value !== "undefined") {
    const translation = value;
    if (Array.isArray(translation)) {
      const plural = bundle.pluralFunction(number);
      return translate(app, translation[plural], vars, number, options);
    }
  }
  if (number === 1) {
    return translate(app, textSingular, vars, number, options);
  } else {
    return translate(app, textPlural, vars, number, options);
  }
}
function getPlural(number, language = getLanguage()) {
  if (language === "pt-BR") {
    language = "xbr";
  }
  if (language.length > 3) {
    language = language.substring(0, language.lastIndexOf("-"));
  }
  switch (language) {
    case "az":
    case "bo":
    case "dz":
    case "id":
    case "ja":
    case "jv":
    case "ka":
    case "km":
    case "kn":
    case "ko":
    case "ms":
    case "th":
    case "tr":
    case "vi":
    case "zh":
      return 0;
    case "af":
    case "bn":
    case "bg":
    case "ca":
    case "da":
    case "de":
    case "el":
    case "en":
    case "eo":
    case "es":
    case "et":
    case "eu":
    case "fa":
    case "fi":
    case "fo":
    case "fur":
    case "fy":
    case "gl":
    case "gu":
    case "ha":
    case "he":
    case "hu":
    case "is":
    case "it":
    case "ku":
    case "lb":
    case "ml":
    case "mn":
    case "mr":
    case "nah":
    case "nb":
    case "ne":
    case "nl":
    case "nn":
    case "no":
    case "oc":
    case "om":
    case "or":
    case "pa":
    case "pap":
    case "ps":
    case "pt":
    case "so":
    case "sq":
    case "sv":
    case "sw":
    case "ta":
    case "te":
    case "tk":
    case "ur":
    case "zu":
      return number === 1 ? 0 : 1;
    case "am":
    case "bh":
    case "fil":
    case "fr":
    case "gun":
    case "hi":
    case "hy":
    case "ln":
    case "mg":
    case "nso":
    case "xbr":
    case "ti":
    case "wa":
      return number === 0 || number === 1 ? 0 : 1;
    case "be":
    case "bs":
    case "hr":
    case "ru":
    case "sh":
    case "sr":
    case "uk":
      return number % 10 === 1 && number % 100 !== 11 ? 0 : number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20) ? 1 : 2;
    case "cs":
    case "sk":
      return number === 1 ? 0 : number >= 2 && number <= 4 ? 1 : 2;
    case "ga":
      return number === 1 ? 0 : number === 2 ? 1 : 2;
    case "lt":
      return number % 10 === 1 && number % 100 !== 11 ? 0 : number % 10 >= 2 && (number % 100 < 10 || number % 100 >= 20) ? 1 : 2;
    case "sl":
      return number % 100 === 1 ? 0 : number % 100 === 2 ? 1 : number % 100 === 3 || number % 100 === 4 ? 2 : 3;
    case "mk":
      return number % 10 === 1 ? 0 : 1;
    case "mt":
      return number === 1 ? 0 : number === 0 || number % 100 > 1 && number % 100 < 11 ? 1 : number % 100 > 10 && number % 100 < 20 ? 2 : 3;
    case "lv":
      return number === 0 ? 0 : number % 10 === 1 && number % 100 !== 11 ? 1 : 2;
    case "pl":
      return number === 1 ? 0 : number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 12 || number % 100 > 14) ? 1 : 2;
    case "cy":
      return number === 1 ? 0 : number === 2 ? 1 : number === 8 || number === 11 ? 2 : 3;
    case "ro":
      return number === 1 ? 0 : number === 0 || number % 100 > 0 && number % 100 < 20 ? 1 : 2;
    case "ar":
      return number === 0 ? 0 : number === 1 ? 1 : number === 2 ? 2 : number % 100 >= 3 && number % 100 <= 10 ? 3 : number % 100 >= 11 && number % 100 <= 99 ? 4 : 5;
    default:
      return 0;
  }
}
/*!
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: GPL-3.0-or-later
 */
class GettextBuilder {
  debug = false;
  language = "en";
  translations = {};
  setLanguage(language) {
    this.language = language;
    return this;
  }
  /**
   * Try to detect locale from context with `en` as fallback value
   * This only works within a Nextcloud page context.
   *
   * @deprecated use `detectLanguage` instead.
   */
  detectLocale() {
    return this.detectLanguage();
  }
  /**
   * Try to detect locale from context with `en` as fallback value.
   * This only works within a Nextcloud page context.
   */
  detectLanguage() {
    return this.setLanguage(getLanguage().replace("-", "_"));
  }
  addTranslation(language, data) {
    this.translations[language] = data;
    return this;
  }
  enableDebugMode() {
    this.debug = true;
    return this;
  }
  build() {
    if (this.debug) {
      console.debug(`Creating gettext instance for language ${this.language}`);
    }
    const translations = Object.values(this.translations[this.language]?.translations[""] ?? {}).map(({ msgid, msgid_plural: msgidPlural, msgstr }) => {
      if (msgidPlural !== void 0) {
        return [`_${msgid}_::_${msgidPlural}_`, msgstr];
      }
      return [msgid, msgstr[0]];
    });
    const bundle = {
      pluralFunction: (n2) => getPlural(n2, this.language),
      translations: Object.fromEntries(translations)
    };
    return new GettextWrapper(bundle);
  }
}
class GettextWrapper {
  constructor(bundle) {
    this.bundle = bundle;
  }
  /**
   * Get translated string (singular form), optionally with placeholders
   *
   * @param original original string to translate
   * @param placeholders map of placeholder key to value
   */
  gettext(original, placeholders = {}) {
    return translate("", original, placeholders, void 0, { bundle: this.bundle });
  }
  /**
   * Get translated string with plural forms
   *
   * @param singular Singular text form
   * @param plural Plural text form to be used if `count` requires it
   * @param count The number to insert into the text
   * @param placeholders optional map of placeholder key to value
   */
  ngettext(singular, plural, count, placeholders = {}) {
    return translatePlural("", singular, plural, count, placeholders, { bundle: this.bundle });
  }
}
function getGettextBuilder() {
  return new GettextBuilder();
}
const builder = getGettextBuilder().setLanguage(getLanguage());
let gettext = builder.build();
const t$1 = (...args) => gettext.gettext(...args);
function register(...chunks) {
  for (const chunk of chunks) {
    if (!chunk.registered) {
      for (const { l: language, t: translations } of chunk) {
        if (language !== getLanguage() || !translations) {
          continue;
        }
        const decompressed = Object.fromEntries(
          Object.entries(translations).map(([id, value]) => [
            id,
            {
              msgid: id,
              msgid_plural: value.p,
              msgstr: value.v
            }
          ])
        );
        gettext = builder.addTranslation(getLanguage(), {
          translations: {
            "": {
              ...gettext.bundle.translations?.[""] ?? {},
              ...decompressed
            }
          }
        }).build();
      }
      chunk.registered = true;
    }
  }
}
const t4 = [{ "l": "af", "t": { "Actions": { "v": [""] } } }, { "l": "ar", "t": { "Actions": { "v": ["إجراءات"] } } }, { "l": "ast", "t": { "Actions": { "v": ["Aiciones"] } } }, { "l": "az", "t": { "Actions": { "v": [""] } } }, { "l": "be", "t": { "Actions": { "v": [""] } } }, { "l": "bg", "t": { "Actions": { "v": [""] } } }, { "l": "bn_BD", "t": { "Actions": { "v": [""] } } }, { "l": "br", "t": { "Actions": { "v": ["Oberioù"] } } }, { "l": "bs", "t": { "Actions": { "v": [""] } } }, { "l": "ca", "t": { "Actions": { "v": ["Accions"] } } }, { "l": "cs", "t": { "Actions": { "v": ["Akce"] } } }, { "l": "cs_CZ", "t": { "Actions": { "v": ["Akce"] } } }, { "l": "cy_GB", "t": { "Actions": { "v": [""] } } }, { "l": "da", "t": { "Actions": { "v": ["Handlinger"] } } }, { "l": "de", "t": { "Actions": { "v": ["Aktionen"] } } }, { "l": "de_DE", "t": { "Actions": { "v": ["Aktionen"] } } }, { "l": "el", "t": { "Actions": { "v": ["Ενέργειες"] } } }, { "l": "en_GB", "t": { "Actions": { "v": ["Actions"] } } }, { "l": "eo", "t": { "Actions": { "v": ["Agoj"] } } }, { "l": "es", "t": { "Actions": { "v": ["Acciones"] } } }, { "l": "es_419", "t": { "Actions": { "v": [""] } } }, { "l": "es_AR", "t": { "Actions": { "v": ["Acciones"] } } }, { "l": "es_CL", "t": { "Actions": { "v": [""] } } }, { "l": "es_CO", "t": { "Actions": { "v": [""] } } }, { "l": "es_CR", "t": { "Actions": { "v": [""] } } }, { "l": "es_DO", "t": { "Actions": { "v": [""] } } }, { "l": "es_EC", "t": { "Actions": { "v": ["Acciones"] } } }, { "l": "es_GT", "t": { "Actions": { "v": [""] } } }, { "l": "es_HN", "t": { "Actions": { "v": [""] } } }, { "l": "es_MX", "t": { "Actions": { "v": ["Acciones"] } } }, { "l": "es_NI", "t": { "Actions": { "v": [""] } } }, { "l": "es_PA", "t": { "Actions": { "v": [""] } } }, { "l": "es_PE", "t": { "Actions": { "v": [""] } } }, { "l": "es_PR", "t": { "Actions": { "v": [""] } } }, { "l": "es_PY", "t": { "Actions": { "v": [""] } } }, { "l": "es_SV", "t": { "Actions": { "v": [""] } } }, { "l": "es_UY", "t": { "Actions": { "v": [""] } } }, { "l": "et_EE", "t": { "Actions": { "v": ["Tegevus"] } } }, { "l": "eu", "t": { "Actions": { "v": ["Ekintzak"] } } }, { "l": "fa", "t": { "Actions": { "v": ["کنش‌ها"] } } }, { "l": "fi", "t": { "Actions": { "v": ["Toiminnot"] } } }, { "l": "fo", "t": { "Actions": { "v": [""] } } }, { "l": "fr", "t": { "Actions": { "v": ["Actions"] } } }, { "l": "ga", "t": { "Actions": { "v": ["Gníomhartha"] } } }, { "l": "gd", "t": { "Actions": { "v": [""] } } }, { "l": "gl", "t": { "Actions": { "v": ["Accións"] } } }, { "l": "he", "t": { "Actions": { "v": ["פעולות"] } } }, { "l": "hi_IN", "t": { "Actions": { "v": [""] } } }, { "l": "hr", "t": { "Actions": { "v": [""] } } }, { "l": "hsb", "t": { "Actions": { "v": [""] } } }, { "l": "hu", "t": { "Actions": { "v": ["Műveletek"] } } }, { "l": "hy", "t": { "Actions": { "v": [""] } } }, { "l": "ia", "t": { "Actions": { "v": [""] } } }, { "l": "id", "t": { "Actions": { "v": ["Tindakan"] } } }, { "l": "ig", "t": { "Actions": { "v": [""] } } }, { "l": "is", "t": { "Actions": { "v": ["Aðgerðir"] } } }, { "l": "it", "t": { "Actions": { "v": ["Azioni"] } } }, { "l": "ja", "t": { "Actions": { "v": ["操作"] } } }, { "l": "ja_JP", "t": { "Actions": { "v": ["操作"] } } }, { "l": "ka", "t": { "Actions": { "v": [""] } } }, { "l": "ka_GE", "t": { "Actions": { "v": [""] } } }, { "l": "kab", "t": { "Actions": { "v": [""] } } }, { "l": "kk", "t": { "Actions": { "v": [""] } } }, { "l": "km", "t": { "Actions": { "v": [""] } } }, { "l": "kn", "t": { "Actions": { "v": [""] } } }, { "l": "ko", "t": { "Actions": { "v": ["동작"] } } }, { "l": "la", "t": { "Actions": { "v": [""] } } }, { "l": "lb", "t": { "Actions": { "v": [""] } } }, { "l": "lo", "t": { "Actions": { "v": [""] } } }, { "l": "lt_LT", "t": { "Actions": { "v": ["Veiksmai"] } } }, { "l": "lv", "t": { "Actions": { "v": [""] } } }, { "l": "mk", "t": { "Actions": { "v": ["Акции"] } } }, { "l": "mn", "t": { "Actions": { "v": [""] } } }, { "l": "mr", "t": { "Actions": { "v": [""] } } }, { "l": "ms_MY", "t": { "Actions": { "v": [""] } } }, { "l": "my", "t": { "Actions": { "v": ["လုပ်ဆောင်ချက်များ"] } } }, { "l": "nb", "t": { "Actions": { "v": ["Handlinger"] } } }, { "l": "ne", "t": { "Actions": { "v": [""] } } }, { "l": "nl", "t": { "Actions": { "v": ["Acties"] } } }, { "l": "nn_NO", "t": { "Actions": { "v": [""] } } }, { "l": "oc", "t": { "Actions": { "v": ["Accions"] } } }, { "l": "pl", "t": { "Actions": { "v": ["Działania"] } } }, { "l": "ps", "t": { "Actions": { "v": [""] } } }, { "l": "pt_BR", "t": { "Actions": { "v": ["Ações"] } } }, { "l": "pt_PT", "t": { "Actions": { "v": ["Ações"] } } }, { "l": "ro", "t": { "Actions": { "v": ["Acțiuni"] } } }, { "l": "ru", "t": { "Actions": { "v": ["Действия "] } } }, { "l": "sc", "t": { "Actions": { "v": [""] } } }, { "l": "si", "t": { "Actions": { "v": [""] } } }, { "l": "sk", "t": { "Actions": { "v": ["Akcie"] } } }, { "l": "sl", "t": { "Actions": { "v": ["Dejanja"] } } }, { "l": "sq", "t": { "Actions": { "v": [""] } } }, { "l": "sr", "t": { "Actions": { "v": ["Радње"] } } }, { "l": "sr@latin", "t": { "Actions": { "v": [""] } } }, { "l": "sv", "t": { "Actions": { "v": ["Åtgärder"] } } }, { "l": "sw", "t": { "Actions": { "v": [""] } } }, { "l": "ta", "t": { "Actions": { "v": [""] } } }, { "l": "th", "t": { "Actions": { "v": [""] } } }, { "l": "tk", "t": { "Actions": { "v": [""] } } }, { "l": "tr", "t": { "Actions": { "v": ["İşlemler"] } } }, { "l": "ug", "t": { "Actions": { "v": [""] } } }, { "l": "uk", "t": { "Actions": { "v": ["Дії"] } } }, { "l": "ur_PK", "t": { "Actions": { "v": [""] } } }, { "l": "uz", "t": { "Actions": { "v": ["Harakatlar"] } } }, { "l": "vi", "t": { "Actions": { "v": [""] } } }, { "l": "zh_CN", "t": { "Actions": { "v": ["行为"] } } }, { "l": "zh_HK", "t": { "Actions": { "v": ["動作"] } } }, { "l": "zh_TW", "t": { "Actions": { "v": ["動作"] } } }, { "l": "zu_ZA", "t": { "Actions": { "v": [""] } } }];
const t17 = [{ "l": "af", "t": { "Close": { "v": [""] } } }, { "l": "ar", "t": { "Close": { "v": ["إغلاق"] } } }, { "l": "ast", "t": { "Close": { "v": ["Zarrar"] } } }, { "l": "az", "t": { "Close": { "v": [""] } } }, { "l": "be", "t": { "Close": { "v": [""] } } }, { "l": "bg", "t": { "Close": { "v": [""] } } }, { "l": "bn_BD", "t": { "Close": { "v": [""] } } }, { "l": "br", "t": { "Close": { "v": ["Serriñ"] } } }, { "l": "bs", "t": { "Close": { "v": [""] } } }, { "l": "ca", "t": { "Close": { "v": ["Tanca"] } } }, { "l": "cs", "t": { "Close": { "v": ["Zavřít"] } } }, { "l": "cs_CZ", "t": { "Close": { "v": ["Zavřít"] } } }, { "l": "cy_GB", "t": { "Close": { "v": [""] } } }, { "l": "da", "t": { "Close": { "v": ["Luk"] } } }, { "l": "de", "t": { "Close": { "v": ["Schließen"] } } }, { "l": "de_DE", "t": { "Close": { "v": ["Schließen"] } } }, { "l": "el", "t": { "Close": { "v": ["Κλείσιμο"] } } }, { "l": "en_GB", "t": { "Close": { "v": ["Close"] } } }, { "l": "eo", "t": { "Close": { "v": ["Fermu"] } } }, { "l": "es", "t": { "Close": { "v": ["Cerrar"] } } }, { "l": "es_419", "t": { "Close": { "v": [""] } } }, { "l": "es_AR", "t": { "Close": { "v": ["Cerrar"] } } }, { "l": "es_CL", "t": { "Close": { "v": [""] } } }, { "l": "es_CO", "t": { "Close": { "v": [""] } } }, { "l": "es_CR", "t": { "Close": { "v": [""] } } }, { "l": "es_DO", "t": { "Close": { "v": [""] } } }, { "l": "es_EC", "t": { "Close": { "v": ["Cerrar"] } } }, { "l": "es_GT", "t": { "Close": { "v": [""] } } }, { "l": "es_HN", "t": { "Close": { "v": [""] } } }, { "l": "es_MX", "t": { "Close": { "v": ["Cerrar"] } } }, { "l": "es_NI", "t": { "Close": { "v": [""] } } }, { "l": "es_PA", "t": { "Close": { "v": [""] } } }, { "l": "es_PE", "t": { "Close": { "v": [""] } } }, { "l": "es_PR", "t": { "Close": { "v": [""] } } }, { "l": "es_PY", "t": { "Close": { "v": [""] } } }, { "l": "es_SV", "t": { "Close": { "v": [""] } } }, { "l": "es_UY", "t": { "Close": { "v": [""] } } }, { "l": "et_EE", "t": { "Close": { "v": ["Sulge"] } } }, { "l": "eu", "t": { "Close": { "v": ["Itxi"] } } }, { "l": "fa", "t": { "Close": { "v": ["بستن"] } } }, { "l": "fi", "t": { "Close": { "v": ["Sulje"] } } }, { "l": "fo", "t": { "Close": { "v": [""] } } }, { "l": "fr", "t": { "Close": { "v": ["Fermer"] } } }, { "l": "ga", "t": { "Close": { "v": ["Dún"] } } }, { "l": "gd", "t": { "Close": { "v": [""] } } }, { "l": "gl", "t": { "Close": { "v": ["Pechar"] } } }, { "l": "he", "t": { "Close": { "v": ["סגירה"] } } }, { "l": "hi_IN", "t": { "Close": { "v": [""] } } }, { "l": "hr", "t": { "Close": { "v": [""] } } }, { "l": "hsb", "t": { "Close": { "v": [""] } } }, { "l": "hu", "t": { "Close": { "v": ["Bezárás"] } } }, { "l": "hy", "t": { "Close": { "v": [""] } } }, { "l": "ia", "t": { "Close": { "v": [""] } } }, { "l": "id", "t": { "Close": { "v": ["Tutup"] } } }, { "l": "ig", "t": { "Close": { "v": [""] } } }, { "l": "is", "t": { "Close": { "v": ["Loka"] } } }, { "l": "it", "t": { "Close": { "v": ["Chiudi"] } } }, { "l": "ja", "t": { "Close": { "v": ["閉じる"] } } }, { "l": "ja_JP", "t": { "Close": { "v": ["閉じる"] } } }, { "l": "ka", "t": { "Close": { "v": [""] } } }, { "l": "ka_GE", "t": { "Close": { "v": [""] } } }, { "l": "kab", "t": { "Close": { "v": [""] } } }, { "l": "kk", "t": { "Close": { "v": [""] } } }, { "l": "km", "t": { "Close": { "v": [""] } } }, { "l": "kn", "t": { "Close": { "v": [""] } } }, { "l": "ko", "t": { "Close": { "v": ["닫기"] } } }, { "l": "la", "t": { "Close": { "v": [""] } } }, { "l": "lb", "t": { "Close": { "v": [""] } } }, { "l": "lo", "t": { "Close": { "v": [""] } } }, { "l": "lt_LT", "t": { "Close": { "v": ["Užverti"] } } }, { "l": "lv", "t": { "Close": { "v": ["Aizvērt"] } } }, { "l": "mk", "t": { "Close": { "v": ["Затвори"] } } }, { "l": "mn", "t": { "Close": { "v": [""] } } }, { "l": "mr", "t": { "Close": { "v": [""] } } }, { "l": "ms_MY", "t": { "Close": { "v": [""] } } }, { "l": "my", "t": { "Close": { "v": ["ပိတ်ရန်"] } } }, { "l": "nb", "t": { "Close": { "v": ["Lukk"] } } }, { "l": "ne", "t": { "Close": { "v": [""] } } }, { "l": "nl", "t": { "Close": { "v": ["Sluiten"] } } }, { "l": "nn_NO", "t": { "Close": { "v": [""] } } }, { "l": "oc", "t": { "Close": { "v": ["Tampar"] } } }, { "l": "pl", "t": { "Close": { "v": ["Zamknij"] } } }, { "l": "ps", "t": { "Close": { "v": [""] } } }, { "l": "pt_BR", "t": { "Close": { "v": ["Fechar"] } } }, { "l": "pt_PT", "t": { "Close": { "v": ["Fechar"] } } }, { "l": "ro", "t": { "Close": { "v": ["Închideți"] } } }, { "l": "ru", "t": { "Close": { "v": ["Закрыть"] } } }, { "l": "sc", "t": { "Close": { "v": [""] } } }, { "l": "si", "t": { "Close": { "v": [""] } } }, { "l": "sk", "t": { "Close": { "v": ["Zavrieť"] } } }, { "l": "sl", "t": { "Close": { "v": ["Zapri"] } } }, { "l": "sq", "t": { "Close": { "v": [""] } } }, { "l": "sr", "t": { "Close": { "v": ["Затвори"] } } }, { "l": "sr@latin", "t": { "Close": { "v": [""] } } }, { "l": "sv", "t": { "Close": { "v": ["Stäng"] } } }, { "l": "sw", "t": { "Close": { "v": [""] } } }, { "l": "ta", "t": { "Close": { "v": [""] } } }, { "l": "th", "t": { "Close": { "v": [""] } } }, { "l": "tk", "t": { "Close": { "v": [""] } } }, { "l": "tr", "t": { "Close": { "v": ["Kapat"] } } }, { "l": "ug", "t": { "Close": { "v": [""] } } }, { "l": "uk", "t": { "Close": { "v": ["Закрити"] } } }, { "l": "ur_PK", "t": { "Close": { "v": [""] } } }, { "l": "uz", "t": { "Close": { "v": ["Yopish"] } } }, { "l": "vi", "t": { "Close": { "v": [""] } } }, { "l": "zh_CN", "t": { "Close": { "v": ["关闭"] } } }, { "l": "zh_HK", "t": { "Close": { "v": ["關閉"] } } }, { "l": "zh_TW", "t": { "Close": { "v": ["關閉"] } } }, { "l": "zu_ZA", "t": { "Close": { "v": [""] } } }];
const t25 = [{ "l": "af", "t": { "Go back to the list": { "v": [""] } } }, { "l": "ar", "t": { "Go back to the list": { "v": ["عودة إلى القائمة"] } } }, { "l": "ast", "t": { "Go back to the list": { "v": ["Volver a la llista"] } } }, { "l": "az", "t": { "Go back to the list": { "v": [""] } } }, { "l": "be", "t": { "Go back to the list": { "v": [""] } } }, { "l": "bg", "t": { "Go back to the list": { "v": [""] } } }, { "l": "bn_BD", "t": { "Go back to the list": { "v": [""] } } }, { "l": "br", "t": { "Go back to the list": { "v": [""] } } }, { "l": "bs", "t": { "Go back to the list": { "v": [""] } } }, { "l": "ca", "t": { "Go back to the list": { "v": ["Torna a la llista"] } } }, { "l": "cs", "t": { "Go back to the list": { "v": ["Jít zpět na seznam"] } } }, { "l": "cs_CZ", "t": { "Go back to the list": { "v": ["Jít zpět na seznam"] } } }, { "l": "cy_GB", "t": { "Go back to the list": { "v": [""] } } }, { "l": "da", "t": { "Go back to the list": { "v": ["Tilbage til listen"] } } }, { "l": "de", "t": { "Go back to the list": { "v": ["Zurück zur Liste"] } } }, { "l": "de_DE", "t": { "Go back to the list": { "v": ["Zurück zur Liste"] } } }, { "l": "el", "t": { "Go back to the list": { "v": ["Επιστροφή στην αρχική λίστα"] } } }, { "l": "en_GB", "t": { "Go back to the list": { "v": ["Go back to the list"] } } }, { "l": "eo", "t": { "Go back to the list": { "v": [""] } } }, { "l": "es", "t": { "Go back to the list": { "v": ["Volver a la lista"] } } }, { "l": "es_419", "t": { "Go back to the list": { "v": [""] } } }, { "l": "es_AR", "t": { "Go back to the list": { "v": ["Volver a la lista"] } } }, { "l": "es_CL", "t": { "Go back to the list": { "v": [""] } } }, { "l": "es_CO", "t": { "Go back to the list": { "v": [""] } } }, { "l": "es_CR", "t": { "Go back to the list": { "v": [""] } } }, { "l": "es_DO", "t": { "Go back to the list": { "v": [""] } } }, { "l": "es_EC", "t": { "Go back to the list": { "v": ["Volver a la lista"] } } }, { "l": "es_GT", "t": { "Go back to the list": { "v": [""] } } }, { "l": "es_HN", "t": { "Go back to the list": { "v": [""] } } }, { "l": "es_MX", "t": { "Go back to the list": { "v": ["Regresar a la lista"] } } }, { "l": "es_NI", "t": { "Go back to the list": { "v": [""] } } }, { "l": "es_PA", "t": { "Go back to the list": { "v": [""] } } }, { "l": "es_PE", "t": { "Go back to the list": { "v": [""] } } }, { "l": "es_PR", "t": { "Go back to the list": { "v": [""] } } }, { "l": "es_PY", "t": { "Go back to the list": { "v": [""] } } }, { "l": "es_SV", "t": { "Go back to the list": { "v": [""] } } }, { "l": "es_UY", "t": { "Go back to the list": { "v": [""] } } }, { "l": "et_EE", "t": { "Go back to the list": { "v": ["Tagasi nimekirja juurde"] } } }, { "l": "eu", "t": { "Go back to the list": { "v": ["Bueltatu zerrendara"] } } }, { "l": "fa", "t": { "Go back to the list": { "v": ["برگشت به لیست"] } } }, { "l": "fi", "t": { "Go back to the list": { "v": ["Takaisin listaan"] } } }, { "l": "fo", "t": { "Go back to the list": { "v": [""] } } }, { "l": "fr", "t": { "Go back to the list": { "v": ["Retourner à la liste"] } } }, { "l": "ga", "t": { "Go back to the list": { "v": ["Téigh ar ais go dtí an liosta"] } } }, { "l": "gd", "t": { "Go back to the list": { "v": [""] } } }, { "l": "gl", "t": { "Go back to the list": { "v": ["Volver á lista"] } } }, { "l": "he", "t": { "Go back to the list": { "v": ["חזרה לרשימה"] } } }, { "l": "hi_IN", "t": { "Go back to the list": { "v": [""] } } }, { "l": "hr", "t": { "Go back to the list": { "v": [""] } } }, { "l": "hsb", "t": { "Go back to the list": { "v": [""] } } }, { "l": "hu", "t": { "Go back to the list": { "v": ["Ugrás vissza a listához"] } } }, { "l": "hy", "t": { "Go back to the list": { "v": [""] } } }, { "l": "ia", "t": { "Go back to the list": { "v": [""] } } }, { "l": "id", "t": { "Go back to the list": { "v": ["Kembali ke daftar"] } } }, { "l": "ig", "t": { "Go back to the list": { "v": [""] } } }, { "l": "is", "t": { "Go back to the list": { "v": ["Fara til baka í listann"] } } }, { "l": "it", "t": { "Go back to the list": { "v": ["Torna all'elenco"] } } }, { "l": "ja", "t": { "Go back to the list": { "v": ["リストに戻る"] } } }, { "l": "ja_JP", "t": { "Go back to the list": { "v": ["リストに戻る"] } } }, { "l": "ka", "t": { "Go back to the list": { "v": [""] } } }, { "l": "ka_GE", "t": { "Go back to the list": { "v": [""] } } }, { "l": "kab", "t": { "Go back to the list": { "v": [""] } } }, { "l": "kk", "t": { "Go back to the list": { "v": [""] } } }, { "l": "km", "t": { "Go back to the list": { "v": [""] } } }, { "l": "kn", "t": { "Go back to the list": { "v": [""] } } }, { "l": "ko", "t": { "Go back to the list": { "v": ["목록으로 돌아가기"] } } }, { "l": "la", "t": { "Go back to the list": { "v": [""] } } }, { "l": "lb", "t": { "Go back to the list": { "v": [""] } } }, { "l": "lo", "t": { "Go back to the list": { "v": [""] } } }, { "l": "lt_LT", "t": { "Go back to the list": { "v": [""] } } }, { "l": "lv", "t": { "Go back to the list": { "v": [""] } } }, { "l": "mk", "t": { "Go back to the list": { "v": ["Врати се на листата"] } } }, { "l": "mn", "t": { "Go back to the list": { "v": [""] } } }, { "l": "mr", "t": { "Go back to the list": { "v": [""] } } }, { "l": "ms_MY", "t": { "Go back to the list": { "v": [""] } } }, { "l": "my", "t": { "Go back to the list": { "v": [""] } } }, { "l": "nb", "t": { "Go back to the list": { "v": ["Gå tilbake til listen"] } } }, { "l": "ne", "t": { "Go back to the list": { "v": [""] } } }, { "l": "nl", "t": { "Go back to the list": { "v": ["Ga terug naar de lijst"] } } }, { "l": "nn_NO", "t": { "Go back to the list": { "v": [""] } } }, { "l": "oc", "t": { "Go back to the list": { "v": [""] } } }, { "l": "pl", "t": { "Go back to the list": { "v": ["Powrót do listy"] } } }, { "l": "ps", "t": { "Go back to the list": { "v": [""] } } }, { "l": "pt_BR", "t": { "Go back to the list": { "v": ["Voltar para a lista"] } } }, { "l": "pt_PT", "t": { "Go back to the list": { "v": ["Voltar para a lista"] } } }, { "l": "ro", "t": { "Go back to the list": { "v": ["Întoarceți-vă la listă"] } } }, { "l": "ru", "t": { "Go back to the list": { "v": ["Вернуться к списку"] } } }, { "l": "sc", "t": { "Go back to the list": { "v": [""] } } }, { "l": "si", "t": { "Go back to the list": { "v": [""] } } }, { "l": "sk", "t": { "Go back to the list": { "v": ["Späť na zoznam"] } } }, { "l": "sl", "t": { "Go back to the list": { "v": ["Vrni se na seznam"] } } }, { "l": "sq", "t": { "Go back to the list": { "v": [""] } } }, { "l": "sr", "t": { "Go back to the list": { "v": ["Назад на листу"] } } }, { "l": "sr@latin", "t": { "Go back to the list": { "v": [""] } } }, { "l": "sv", "t": { "Go back to the list": { "v": ["Gå tillbaka till listan"] } } }, { "l": "sw", "t": { "Go back to the list": { "v": [""] } } }, { "l": "ta", "t": { "Go back to the list": { "v": [""] } } }, { "l": "th", "t": { "Go back to the list": { "v": [""] } } }, { "l": "tk", "t": { "Go back to the list": { "v": [""] } } }, { "l": "tr", "t": { "Go back to the list": { "v": ["Listeye dön"] } } }, { "l": "ug", "t": { "Go back to the list": { "v": [""] } } }, { "l": "uk", "t": { "Go back to the list": { "v": ["Повернутися до списку"] } } }, { "l": "ur_PK", "t": { "Go back to the list": { "v": [""] } } }, { "l": "uz", "t": { "Go back to the list": { "v": ["Ro'yxatga qayting"] } } }, { "l": "vi", "t": { "Go back to the list": { "v": [""] } } }, { "l": "zh_CN", "t": { "Go back to the list": { "v": ["返回至列表"] } } }, { "l": "zh_HK", "t": { "Go back to the list": { "v": ["返回清單"] } } }, { "l": "zh_TW", "t": { "Go back to the list": { "v": ["回到清單"] } } }, { "l": "zu_ZA", "t": { "Go back to the list": { "v": [""] } } }];
const t30 = [{ "l": "af", "t": {} }, { "l": "ar", "t": { "Loading …": { "v": ["التحميل جارٍ ..."] } } }, { "l": "ast", "t": {} }, { "l": "az", "t": {} }, { "l": "be", "t": {} }, { "l": "bg", "t": {} }, { "l": "bn_BD", "t": {} }, { "l": "br", "t": {} }, { "l": "bs", "t": {} }, { "l": "ca", "t": {} }, { "l": "cs", "t": { "Loading …": { "v": ["Načítání…"] } } }, { "l": "cs_CZ", "t": {} }, { "l": "cy_GB", "t": {} }, { "l": "da", "t": { "Loading …": { "v": ["Indlæser…"] } } }, { "l": "de", "t": { "Loading …": { "v": ["Wird geladen …"] } } }, { "l": "de_DE", "t": { "Loading …": { "v": ["Wird geladen …"] } } }, { "l": "el", "t": { "Loading …": { "v": ["Φόρτωση …"] } } }, { "l": "en_GB", "t": { "Loading …": { "v": ["Loading …"] } } }, { "l": "eo", "t": {} }, { "l": "es", "t": {} }, { "l": "es_419", "t": {} }, { "l": "es_AR", "t": {} }, { "l": "es_CL", "t": {} }, { "l": "es_CO", "t": {} }, { "l": "es_CR", "t": {} }, { "l": "es_DO", "t": {} }, { "l": "es_EC", "t": {} }, { "l": "es_GT", "t": {} }, { "l": "es_HN", "t": {} }, { "l": "es_MX", "t": {} }, { "l": "es_NI", "t": {} }, { "l": "es_PA", "t": {} }, { "l": "es_PE", "t": {} }, { "l": "es_PR", "t": {} }, { "l": "es_PY", "t": {} }, { "l": "es_SV", "t": {} }, { "l": "es_UY", "t": {} }, { "l": "et_EE", "t": { "Loading …": { "v": ["Laadin…"] } } }, { "l": "eu", "t": {} }, { "l": "fa", "t": { "Loading …": { "v": ["در حال بارگذاری ..."] } } }, { "l": "fi", "t": { "Loading …": { "v": ["Ladataan ..."] } } }, { "l": "fo", "t": {} }, { "l": "fr", "t": { "Loading …": { "v": ["Chargement …"] } } }, { "l": "ga", "t": { "Loading …": { "v": ["Á lódáil…"] } } }, { "l": "gd", "t": {} }, { "l": "gl", "t": { "Loading …": { "v": ["Cargando…"] } } }, { "l": "he", "t": {} }, { "l": "hi_IN", "t": {} }, { "l": "hr", "t": {} }, { "l": "hsb", "t": {} }, { "l": "hu", "t": {} }, { "l": "hy", "t": {} }, { "l": "ia", "t": {} }, { "l": "id", "t": {} }, { "l": "ig", "t": {} }, { "l": "is", "t": { "Loading …": { "v": ["Hleð inn …"] } } }, { "l": "it", "t": {} }, { "l": "ja", "t": { "Loading …": { "v": ["読み込み中 …"] } } }, { "l": "ja_JP", "t": {} }, { "l": "ka", "t": {} }, { "l": "ka_GE", "t": {} }, { "l": "kab", "t": {} }, { "l": "kk", "t": {} }, { "l": "km", "t": {} }, { "l": "kn", "t": {} }, { "l": "ko", "t": { "Loading …": { "v": ["불러오는 중..."] } } }, { "l": "la", "t": {} }, { "l": "lb", "t": {} }, { "l": "lo", "t": {} }, { "l": "lt_LT", "t": {} }, { "l": "lv", "t": {} }, { "l": "mk", "t": {} }, { "l": "mn", "t": {} }, { "l": "mr", "t": {} }, { "l": "ms_MY", "t": {} }, { "l": "my", "t": {} }, { "l": "nb", "t": { "Loading …": { "v": ["Laster inn..."] } } }, { "l": "ne", "t": {} }, { "l": "nl", "t": { "Loading …": { "v": ["Laden ..."] } } }, { "l": "nn_NO", "t": {} }, { "l": "oc", "t": {} }, { "l": "pl", "t": { "Loading …": { "v": ["Wczytywanie…"] } } }, { "l": "ps", "t": {} }, { "l": "pt_BR", "t": { "Loading …": { "v": ["Carregando …"] } } }, { "l": "pt_PT", "t": { "Loading …": { "v": ["A carregar..."] } } }, { "l": "ro", "t": {} }, { "l": "ru", "t": { "Loading …": { "v": ["Загрузка ..."] } } }, { "l": "sc", "t": {} }, { "l": "si", "t": {} }, { "l": "sk", "t": { "Loading …": { "v": ["Nahrávam ..."] } } }, { "l": "sl", "t": {} }, { "l": "sq", "t": {} }, { "l": "sr", "t": { "Loading …": { "v": ["Учитава се…"] } } }, { "l": "sr@latin", "t": {} }, { "l": "sv", "t": { "Loading …": { "v": ["Laddar ..."] } } }, { "l": "sw", "t": {} }, { "l": "ta", "t": {} }, { "l": "th", "t": {} }, { "l": "tk", "t": {} }, { "l": "tr", "t": { "Loading …": { "v": ["Yükleniyor…"] } } }, { "l": "ug", "t": {} }, { "l": "uk", "t": { "Loading …": { "v": ["Завантаження ..."] } } }, { "l": "ur_PK", "t": {} }, { "l": "uz", "t": { "Loading …": { "v": ["Yuklanmoqda..."] } } }, { "l": "vi", "t": {} }, { "l": "zh_CN", "t": { "Loading …": { "v": ["加载中..."] } } }, { "l": "zh_HK", "t": { "Loading …": { "v": ["加載中 …"] } } }, { "l": "zh_TW", "t": {} }, { "l": "zu_ZA", "t": {} }];
const t33 = [{ "l": "af", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "ar", "t": { "Next": { "v": ["التالي"] }, "Pause slideshow": { "v": ["تجميد عرض الشرائح"] }, "Previous": { "v": ["السابق"] }, "Start slideshow": { "v": ["إبدإ العرض"] } } }, { "l": "ast", "t": { "Next": { "v": ["Siguiente"] }, "Pause slideshow": { "v": ["Posar la presentación de diapositives"] }, "Previous": { "v": ["Anterior"] }, "Start slideshow": { "v": ["Aniciar la presentación de diapositives"] } } }, { "l": "az", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "be", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "bg", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "bn_BD", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "br", "t": { "Next": { "v": ["Da heul"] }, "Pause slideshow": { "v": ["Arsav an diaporama"] }, "Previous": { "v": ["A-raok"] }, "Start slideshow": { "v": ["Kregiñ an diaporama"] } } }, { "l": "bs", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "ca", "t": { "Next": { "v": ["Següent"] }, "Pause slideshow": { "v": ["Atura la presentació"] }, "Previous": { "v": ["Anterior"] }, "Start slideshow": { "v": ["Inicia la presentació"] } } }, { "l": "cs", "t": { "Next": { "v": ["Následující"] }, "Pause slideshow": { "v": ["Pozastavit prezentaci"] }, "Previous": { "v": ["Předchozí"] }, "Start slideshow": { "v": ["Spustit prezentaci"] } } }, { "l": "cs_CZ", "t": { "Next": { "v": ["Následující"] }, "Pause slideshow": { "v": ["Pozastavit prezentaci"] }, "Previous": { "v": ["Předchozí"] }, "Start slideshow": { "v": ["Spustit prezentaci"] } } }, { "l": "cy_GB", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "da", "t": { "Next": { "v": ["Videre"] }, "Pause slideshow": { "v": ["Suspender fremvisning"] }, "Previous": { "v": ["Forrige"] }, "Start slideshow": { "v": ["Start fremvisning"] } } }, { "l": "de", "t": { "Next": { "v": ["Weiter"] }, "Pause slideshow": { "v": ["Diashow pausieren"] }, "Previous": { "v": ["Vorherige"] }, "Start slideshow": { "v": ["Diashow starten"] } } }, { "l": "de_DE", "t": { "Next": { "v": ["Weiter"] }, "Pause slideshow": { "v": ["Diashow pausieren"] }, "Previous": { "v": ["Vorherige"] }, "Start slideshow": { "v": ["Diashow starten"] } } }, { "l": "el", "t": { "Next": { "v": ["Επόμενο"] }, "Pause slideshow": { "v": ["Παύση προβολής διαφανειών"] }, "Previous": { "v": ["Προηγούμενο"] }, "Start slideshow": { "v": ["Έναρξη προβολής διαφανειών"] } } }, { "l": "en_GB", "t": { "Next": { "v": ["Next"] }, "Pause slideshow": { "v": ["Pause slideshow"] }, "Previous": { "v": ["Previous"] }, "Start slideshow": { "v": ["Start slideshow"] } } }, { "l": "eo", "t": { "Next": { "v": ["Sekva"] }, "Pause slideshow": { "v": ["Payzi bildprezenton"] }, "Previous": { "v": ["Antaŭa"] }, "Start slideshow": { "v": ["Komenci bildprezenton"] } } }, { "l": "es", "t": { "Next": { "v": ["Siguiente"] }, "Pause slideshow": { "v": ["Pausar la presentación "] }, "Previous": { "v": ["Anterior"] }, "Start slideshow": { "v": ["Iniciar la presentación"] } } }, { "l": "es_419", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "es_AR", "t": { "Next": { "v": ["Siguiente"] }, "Pause slideshow": { "v": ["Pausar la presentación "] }, "Previous": { "v": ["Anterior"] }, "Start slideshow": { "v": ["Iniciar la presentación"] } } }, { "l": "es_CL", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "es_CO", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "es_CR", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "es_DO", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "es_EC", "t": { "Next": { "v": ["Siguiente"] }, "Pause slideshow": { "v": ["Pausar presentación de diapositivas"] }, "Previous": { "v": ["Anterior"] }, "Start slideshow": { "v": ["Iniciar presentación de diapositivas"] } } }, { "l": "es_GT", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "es_HN", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "es_MX", "t": { "Next": { "v": ["Siguiente"] }, "Pause slideshow": { "v": ["Pausar presentación de diapositivas"] }, "Previous": { "v": ["Anterior"] }, "Start slideshow": { "v": ["Iniciar presentación de diapositivas"] } } }, { "l": "es_NI", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "es_PA", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "es_PE", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "es_PR", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "es_PY", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "es_SV", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "es_UY", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "et_EE", "t": { "Next": { "v": ["Edasi"] }, "Pause slideshow": { "v": ["Slaidiesitluse paus"] }, "Previous": { "v": ["Eelmine"] }, "Start slideshow": { "v": ["Alusta slaidiesitust"] } } }, { "l": "eu", "t": { "Next": { "v": ["Hurrengoa"] }, "Pause slideshow": { "v": ["Pausatu diaporama"] }, "Previous": { "v": ["Aurrekoa"] }, "Start slideshow": { "v": ["Hasi diaporama"] } } }, { "l": "fa", "t": { "Next": { "v": ["بعدی"] }, "Pause slideshow": { "v": ["توقف نمایش اسلاید"] }, "Previous": { "v": ["قبلی"] }, "Start slideshow": { "v": ["شروع نمایش اسلاید"] } } }, { "l": "fi", "t": { "Next": { "v": ["Seuraava"] }, "Pause slideshow": { "v": ["Keskeytä diaesitys"] }, "Previous": { "v": ["Edellinen"] }, "Start slideshow": { "v": ["Aloita diaesitys"] } } }, { "l": "fo", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "fr", "t": { "Next": { "v": ["Suivant"] }, "Pause slideshow": { "v": ["Mettre le diaporama en pause"] }, "Previous": { "v": ["Précédent"] }, "Start slideshow": { "v": ["Démarrer le diaporama"] } } }, { "l": "ga", "t": { "Next": { "v": ["Ar aghaidh"] }, "Pause slideshow": { "v": ["Cuir taispeántas sleamhnán ar sos"] }, "Previous": { "v": ["Roimhe Seo"] }, "Start slideshow": { "v": ["Tosaigh taispeántas sleamhnán"] } } }, { "l": "gd", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "gl", "t": { "Next": { "v": ["Seguinte"] }, "Pause slideshow": { "v": ["Pausar o diaporama"] }, "Previous": { "v": ["Anterir"] }, "Start slideshow": { "v": ["Iniciar o diaporama"] } } }, { "l": "he", "t": { "Next": { "v": ["הבא"] }, "Pause slideshow": { "v": ["השהיית מצגת"] }, "Previous": { "v": ["הקודם"] }, "Start slideshow": { "v": ["התחלת המצגת"] } } }, { "l": "hi_IN", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "hr", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "hsb", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "hu", "t": { "Next": { "v": ["Következő"] }, "Pause slideshow": { "v": ["Diavetítés szüneteltetése"] }, "Previous": { "v": ["Előző"] }, "Start slideshow": { "v": ["Diavetítés indítása"] } } }, { "l": "hy", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "ia", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "id", "t": { "Next": { "v": ["Selanjutnya"] }, "Pause slideshow": { "v": ["Jeda tayangan slide"] }, "Previous": { "v": ["Sebelumnya"] }, "Start slideshow": { "v": ["Mulai salindia"] } } }, { "l": "ig", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "is", "t": { "Next": { "v": ["Næsta"] }, "Pause slideshow": { "v": ["Gera hlé á skyggnusýningu"] }, "Previous": { "v": ["Fyrri"] }, "Start slideshow": { "v": ["Byrja skyggnusýningu"] } } }, { "l": "it", "t": { "Next": { "v": ["Successivo"] }, "Pause slideshow": { "v": ["Presentazione in pausa"] }, "Previous": { "v": ["Precedente"] }, "Start slideshow": { "v": ["Avvia presentazione"] } } }, { "l": "ja", "t": { "Next": { "v": ["次"] }, "Pause slideshow": { "v": ["スライドショーを一時停止"] }, "Previous": { "v": ["前"] }, "Start slideshow": { "v": ["スライドショーを開始"] } } }, { "l": "ja_JP", "t": { "Next": { "v": ["次"] }, "Pause slideshow": { "v": ["スライドショーを一時停止"] }, "Previous": { "v": ["前"] }, "Start slideshow": { "v": ["スライドショーを開始"] } } }, { "l": "ka", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "ka_GE", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "kab", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "kk", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "km", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "kn", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "ko", "t": { "Next": { "v": ["다음"] }, "Pause slideshow": { "v": ["슬라이드쇼 일시정지"] }, "Previous": { "v": ["이전"] }, "Start slideshow": { "v": ["슬라이드쇼 시작"] } } }, { "l": "la", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "lb", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "lo", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "lt_LT", "t": { "Next": { "v": ["Kitas"] }, "Pause slideshow": { "v": ["Pristabdyti skaidrių rodymą"] }, "Previous": { "v": ["Ankstesnis"] }, "Start slideshow": { "v": ["Pradėti skaidrių rodymą"] } } }, { "l": "lv", "t": { "Next": { "v": ["Nākamais"] }, "Pause slideshow": { "v": ["Pauzēt slaidrādi"] }, "Previous": { "v": ["Iepriekšējais"] }, "Start slideshow": { "v": ["Sākt slaidrādi"] } } }, { "l": "mk", "t": { "Next": { "v": ["Следно"] }, "Pause slideshow": { "v": ["Пузирај слајдшоу"] }, "Previous": { "v": ["Предходно"] }, "Start slideshow": { "v": ["Стартувај слајдшоу"] } } }, { "l": "mn", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "mr", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "ms_MY", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "my", "t": { "Next": { "v": ["နောက်သို့ဆက်ရန်"] }, "Pause slideshow": { "v": ["စလိုက်ရှိုး ခေတ္တရပ်ရန်"] }, "Previous": { "v": ["ယခင်"] }, "Start slideshow": { "v": ["စလိုက်ရှိုးအား စတင်ရန်"] } } }, { "l": "nb", "t": { "Next": { "v": ["Neste"] }, "Pause slideshow": { "v": ["Pause lysbildefremvisning"] }, "Previous": { "v": ["Forrige"] }, "Start slideshow": { "v": ["Start lysbildefremvisning"] } } }, { "l": "ne", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "nl", "t": { "Next": { "v": ["Volgende"] }, "Pause slideshow": { "v": ["Pauzeer diavoorstelling"] }, "Previous": { "v": ["Vorige"] }, "Start slideshow": { "v": ["Start diavoorstelling"] } } }, { "l": "nn_NO", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "oc", "t": { "Next": { "v": ["Seguent"] }, "Pause slideshow": { "v": ["Metre en pausa lo diaporama"] }, "Previous": { "v": ["Precedent"] }, "Start slideshow": { "v": ["Lançar lo diaporama"] } } }, { "l": "pl", "t": { "Next": { "v": ["Następny"] }, "Pause slideshow": { "v": ["Wstrzymaj pokaz slajdów"] }, "Previous": { "v": ["Poprzedni"] }, "Start slideshow": { "v": ["Rozpocznij pokaz slajdów"] } } }, { "l": "ps", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "pt_BR", "t": { "Next": { "v": ["Próximo"] }, "Pause slideshow": { "v": ["Pausar apresentação de slides"] }, "Previous": { "v": ["Anterior"] }, "Start slideshow": { "v": ["Iniciar apresentação de slides"] } } }, { "l": "pt_PT", "t": { "Next": { "v": ["Seguinte"] }, "Pause slideshow": { "v": ["Pausar diaporama"] }, "Previous": { "v": ["Anterior"] }, "Start slideshow": { "v": ["Iniciar diaporama"] } } }, { "l": "ro", "t": { "Next": { "v": ["Următorul"] }, "Pause slideshow": { "v": ["Pauză prezentare de diapozitive"] }, "Previous": { "v": ["Anterior"] }, "Start slideshow": { "v": ["Începeți prezentarea de diapozitive"] } } }, { "l": "ru", "t": { "Next": { "v": ["Следующее"] }, "Pause slideshow": { "v": ["Приостановить показ слйдов"] }, "Previous": { "v": ["Предыдущее"] }, "Start slideshow": { "v": ["Начать показ слайдов"] } } }, { "l": "sc", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "si", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "sk", "t": { "Next": { "v": ["Ďalej"] }, "Pause slideshow": { "v": ["Pozastaviť prezentáciu"] }, "Previous": { "v": ["Predchádzajúce"] }, "Start slideshow": { "v": ["Začať prezentáciu"] } } }, { "l": "sl", "t": { "Next": { "v": ["Naslednji"] }, "Pause slideshow": { "v": ["Ustavi predstavitev"] }, "Previous": { "v": ["Predhodni"] }, "Start slideshow": { "v": ["Začni predstavitev"] } } }, { "l": "sq", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "sr", "t": { "Next": { "v": ["Следеће"] }, "Pause slideshow": { "v": ["Паузирај слајд шоу"] }, "Previous": { "v": ["Претходно"] }, "Start slideshow": { "v": ["Покрени слајд шоу"] } } }, { "l": "sr@latin", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "sv", "t": { "Next": { "v": ["Nästa"] }, "Pause slideshow": { "v": ["Pausa bildspelet"] }, "Previous": { "v": ["Föregående"] }, "Start slideshow": { "v": ["Starta bildspelet"] } } }, { "l": "sw", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "ta", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "th", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "tk", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "tr", "t": { "Next": { "v": ["Sonraki"] }, "Pause slideshow": { "v": ["Slayt sunumunu duraklat"] }, "Previous": { "v": ["Önceki"] }, "Start slideshow": { "v": ["Slayt sunumunu başlat"] } } }, { "l": "ug", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "uk", "t": { "Next": { "v": ["Вперед"] }, "Pause slideshow": { "v": ["Пауза у показі слайдів"] }, "Previous": { "v": ["Назад"] }, "Start slideshow": { "v": ["Почати показ слайдів"] } } }, { "l": "ur_PK", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "uz", "t": { "Next": { "v": ["Keyingi"] }, "Pause slideshow": { "v": ["Slayd-shouni to'xtatib turish"] }, "Previous": { "v": ["Oldingi"] }, "Start slideshow": { "v": ["Slayd-shouni boshlash"] } } }, { "l": "vi", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }, { "l": "zh_CN", "t": { "Next": { "v": ["下一个"] }, "Pause slideshow": { "v": ["暂停幻灯片"] }, "Previous": { "v": ["上一个"] }, "Start slideshow": { "v": ["开始幻灯片"] } } }, { "l": "zh_HK", "t": { "Next": { "v": ["下一個"] }, "Pause slideshow": { "v": ["暫停幻燈片"] }, "Previous": { "v": ["上一個"] }, "Start slideshow": { "v": ["開始幻燈片"] } } }, { "l": "zh_TW", "t": { "Next": { "v": ["下一個"] }, "Pause slideshow": { "v": ["暫停幻燈片"] }, "Previous": { "v": ["上一個"] }, "Start slideshow": { "v": ["開始幻燈片"] } } }, { "l": "zu_ZA", "t": { "Next": { "v": [""] }, "Pause slideshow": { "v": [""] }, "Previous": { "v": [""] }, "Start slideshow": { "v": [""] } } }];
function normalizeComponent$3(scriptExports, render66, staticRenderFns2, functionalTemplate, injectStyles, scopeId, moduleIdentifier, shadowMode) {
  var options = typeof scriptExports === "function" ? scriptExports.options : scriptExports;
  if (render66) {
    options.render = render66;
    options.staticRenderFns = staticRenderFns2;
    options._compiled = true;
  }
  if (scopeId) {
    options._scopeId = "data-v-" + scopeId;
  }
  return {
    exports: scriptExports,
    options
  };
}
const _sfc_main$10 = {
  name: "ArrowRightIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$10 = function render() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon arrow-right-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M4,11V13H16L10.5,18.5L11.92,19.92L19.84,12L11.92,4.08L10.5,5.5L16,11H4Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$10 = [];
var __component__$11 = /* @__PURE__ */ normalizeComponent$3(
  _sfc_main$10,
  _sfc_render$10,
  _sfc_staticRenderFns$10,
  false,
  null,
  null
);
const ArrowRight = __component__$11.exports;
const _sfc_main$$ = {
  name: "ArrowLeftIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$$ = function render2() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon arrow-left-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$$ = [];
var __component__$10 = /* @__PURE__ */ normalizeComponent$3(
  _sfc_main$$,
  _sfc_render$$,
  _sfc_staticRenderFns$$,
  false,
  null,
  null
);
const ArrowLeft = __component__$10.exports;
const _sfc_main$_ = {
  name: "NcButton",
  inject: {
    getNcPopoverTriggerAttrs: {
      from: "NcPopover:trigger:attrs",
      default: () => () => ({})
    }
  },
  props: {
    /**
     * Set the text and icon alignment
     *
     * @default 'center'
     */
    alignment: {
      type: String,
      default: "center",
      validator: (alignment) => ["start", "start-reverse", "center", "center-reverse", "end", "end-reverse"].includes(alignment)
    },
    /**
     * Toggles the disabled state of the button on and off.
     */
    disabled: {
      type: Boolean,
      default: false
    },
    /**
     * Specify the button size
     * Accepted values: `'small'`, `'normal'` (default), `'large'`
     */
    size: {
      type: String,
      default: "normal",
      validator(value) {
        return ["small", "normal", "large"].includes(value);
      }
    },
    /**
     * Specifies the HTML button type.
     * Accepted values: submit, reset, button.
     *
     * For legacy reasons this can also be used to set the variant of the button (color schema).
     * This is discouraged but the accepted values are:
     * primary, secondary, tertiary, tertiary-no-background, tertiary-on-primary, error, warning, success.
     *
     * @default 'secondary' (will change with v9)
     * @deprecated The behavior will change in v9 to only allow the native HTML button types - use `variant` instead for setting the appearance of the button.
     */
    type: {
      type: String,
      validator(value) {
        return ["primary", "secondary", "tertiary", "tertiary-no-background", "tertiary-on-primary", "error", "warning", "success"].includes(value) || ["submit", "reset", "button"].includes(value);
      },
      default: "secondary"
    },
    /**
     * Specifies the button native type
     * Accepted values: submit, reset, button. If left empty,
     * the default "button" type will be used.
     *
     * @deprecated use `type` instead - will be removed with v9
     */
    nativeType: {
      type: String,
      validator(value) {
        return ["submit", "reset", "button"].indexOf(value) !== -1;
      },
      default: "button"
    },
    /**
     * Specifies whether the button should span all the available width.
     * By default, buttons span the whole width of the container.
     */
    wide: {
      type: Boolean,
      default: false
    },
    /**
     * Always try to provide an aria-label to your button. Make it more
     * specific than the button's name by provide some more context. E.g. if
     * the name of the button is "send" in the Mail app, the aria label could
     * be "Send email".
     */
    ariaLabel: {
      type: String,
      default: null
    },
    /**
     * Providing the href attribute turns the button component into an `a`
     * element.
     */
    href: {
      type: String,
      default: null
    },
    /**
     * Target for the `a` element if `href` is set.
     */
    target: {
      type: String,
      default: "_self"
    },
    /**
     * Providing the download attribute with href downloads file when clicking.
     */
    download: {
      type: String,
      default: null
    },
    /**
     * Providing the to attribute turns the button component into a `router-link`
     * element. Takes precedence over the href attribute.
     */
    to: {
      type: [String, Object],
      default: null
    },
    /**
     * Pass in `true` if you want the matching behaviour of `router-link` to
     * be non-inclusive: https://router.vuejs.org/api/#exact
     */
    exact: {
      type: Boolean,
      default: false
    },
    /**
     * @deprecated To be removed in @nextcloud/vue 9. Migration guide: remove ariaHidden prop from NcAction* components.
     * @todo Add a check in @nextcloud/vue 9 that this prop is not provided,
     * otherwise root element will inherit incorrect aria-hidden.
     */
    ariaHidden: {
      type: Boolean,
      default: null
    },
    /**
     * The pressed state of the button if it has a checked state
     * This will add the `aria-pressed` attribute and for the button to have the primary style in checked state.
     *
     * Pressed state is not supported for links
     */
    pressed: {
      type: Boolean,
      default: null
    },
    /**
     * Specifies the button variant.
     *
     * Accepted values: primary, secondary, tertiary, tertiary-no-background, tertiary-on-primary, error, warning, success.
     *
     * @default 'secondary'
     * @since 8.24.0
     */
    variant: {
      type: String,
      validator(value) {
        return ["primary", "secondary", "tertiary", "tertiary-no-background", "tertiary-on-primary", "error", "warning", "success"].includes(value);
      },
      default: "secondary"
    }
  },
  emits: ["update:pressed", "click"],
  computed: {
    /**
     * The real type to be used for the button, enforces `primary` for pressed state and, if stateful button, any other type for not pressed state
     * Otherwise the type property is used.
     */
    realVariant() {
      if (this.pressed) {
        return "primary";
      }
      if (this.pressed === false && (this.type === "primary" || this.variant === "primary")) {
        return "secondary";
      }
      if (this.type !== "secondary" && ["primary", "tertiary", "tertiary-no-background", "tertiary-on-primary", "error", "warning", "success"].includes(this.type)) {
        return this.type;
      }
      return this.variant;
    },
    /**
     * The HTML button type
     */
    realType() {
      if (typeof this.pressed === "boolean") {
        return "button";
      }
      if (this.nativeType !== "button") {
        return this.nativeType;
      }
      if (["primary", "secondary", "tertiary", "tertiary-no-background", "tertiary-on-primary", "error", "warning", "success"].includes(this.type)) {
        return this.nativeType;
      }
      return this.type;
    },
    /**
     * The flexbox alignment of the button content
     */
    flexAlignment() {
      return this.alignment.split("-")[0];
    },
    /**
     * If the button content should be reversed (icon on the end)
     */
    isReverseAligned() {
      return this.alignment.includes("-");
    },
    ncPopoverTriggerAttrs() {
      return this.getNcPopoverTriggerAttrs();
    }
  },
  /**
   * The render function to display the component
   *
   * @param {Function} h The function to create VNodes
   * @return {object|undefined} The created VNode
   */
  render(h) {
    const hasText = !!this.$slots.default;
    const hasIcon = this.$slots?.icon;
    if (!hasText && !this.ariaLabel) {
      console.warn(
        "You need to fill either the text or the ariaLabel props in the button component.",
        {
          text: this.$slots.default?.[0]?.text,
          ariaLabel: this.ariaLabel
        },
        this
      );
    }
    const isLink = this.to || this.href;
    const hasPressed = !isLink && typeof this.pressed === "boolean";
    const renderButton = ({ href, navigate, isActive, isExactActive } = {}) => h(
      isLink ? "a" : "button",
      {
        class: [
          "button-vue",
          `button-vue--size-${this.size}`,
          {
            "button-vue--icon-only": hasIcon && !hasText,
            "button-vue--text-only": hasText && !hasIcon,
            "button-vue--icon-and-text": hasIcon && hasText,
            [`button-vue--vue-${this.realVariant}`]: this.realVariant,
            "button-vue--wide": this.wide,
            [`button-vue--${this.flexAlignment}`]: this.flexAlignment !== "center",
            "button-vue--reverse": this.isReverseAligned,
            active: isActive,
            "router-link-exact-active": isExactActive
          }
        ],
        attrs: {
          "aria-label": this.ariaLabel,
          "aria-pressed": hasPressed ? this.pressed.toString() : void 0,
          disabled: this.disabled,
          type: isLink ? null : this.realType,
          role: isLink ? "button" : null,
          href: this.to ? href : this.href || null,
          target: isLink ? this.target || "_self" : null,
          rel: isLink ? "nofollow noreferrer noopener" : null,
          download: !this.to && this.href && this.download ? this.download : null,
          // If this button is used as a popover trigger, we need to apply trigger attrs, e.g. aria attributes
          ...this.ncPopoverTriggerAttrs,
          // Inherit all the component attrs
          ...this.$attrs
        },
        on: {
          ...this.$listeners,
          click: ($event) => {
            if (hasPressed) {
              this.$emit("update:pressed", !this.pressed);
            }
            this.$emit("click", $event);
            navigate?.($event);
          }
        }
      },
      [
        h("span", { class: "button-vue__wrapper" }, [
          hasIcon ? h(
            "span",
            {
              class: "button-vue__icon",
              attrs: {
                "aria-hidden": "true"
              }
            },
            [this.$slots.icon]
          ) : null,
          hasText ? h("span", { class: "button-vue__text" }, [this.$slots.default]) : null
        ])
      ]
    );
    if (this.to) {
      return h("router-link", {
        props: {
          custom: true,
          to: this.to,
          exact: this.exact
        },
        scopedSlots: {
          default: renderButton
        }
      });
    }
    return renderButton();
  }
};
const _sfc_render$_ = null;
const _sfc_staticRenderFns$_ = null;
var __component__$$ = /* @__PURE__ */ normalizeComponent$3(
  _sfc_main$_,
  _sfc_render$_,
  _sfc_staticRenderFns$_,
  false,
  null,
  "3f8e123a"
);
const NcButton = __component__$$.exports;
const isRtl = isRTL();
register(t25);
const _sfc_main$1$3 = {
  name: "NcAppDetailsToggle",
  components: {
    ArrowRight,
    ArrowLeft,
    NcButton
  },
  setup() {
    return {
      isRtl,
      isMobile: useIsMobile()
    };
  },
  computed: {
    title() {
      return t$1("Go back to the list");
    }
  },
  watch: {
    isMobile: {
      immediate: true,
      handler() {
        this.toggleAppNavigationButton(this.isMobile);
      }
    }
  },
  beforeDestroy() {
    if (this.isMobile) {
      this.toggleAppNavigationButton(false);
    }
  },
  methods: {
    toggleAppNavigationButton(hide = true) {
      const appNavigationToggle = document.querySelector(".app-navigation .app-navigation-toggle");
      if (appNavigationToggle) {
        appNavigationToggle.style.display = hide ? "none" : null;
        if (hide === true) {
          emit("toggle-navigation", { open: false });
        }
      }
    }
  }
};
var _sfc_render$1$3 = function render3() {
  var _vm = this, _c = _vm._self._c;
  return _c("NcButton", { staticClass: "app-details-toggle", class: { "app-details-toggle--mobile": _vm.isMobile }, attrs: { "aria-label": _vm.title, "title": _vm.title, "variant": "tertiary" }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_vm.isRtl ? _c("ArrowLeft", { attrs: { "size": 20 } }) : _c("ArrowRight", { attrs: { "size": 20 } })];
  }, proxy: true }]) });
};
var _sfc_staticRenderFns$1$3 = [];
var __component__$1$4 = /* @__PURE__ */ normalizeComponent$3(
  _sfc_main$1$3,
  _sfc_render$1$3,
  _sfc_staticRenderFns$1$3,
  false,
  null,
  "0bdd48d0"
);
const NcAppDetailsToggle = __component__$1$4.exports;
const browserStorage = distExports.getBuilder("nextcloud").persist().build();
const { name: productName } = loadState("theming", "data", { name: "Nextcloud" });
const activeApp = loadState("core", "active-app", appName);
const localizedAppName = loadState("core", "apps", {})[activeApp]?.name ?? appName;
const _sfc_main$Z = {
  name: "NcAppContent",
  components: {
    NcAppDetailsToggle,
    Pane: pane,
    Splitpanes: splitpanes
  },
  props: {
    /**
     * Allows to disable the control by swipe of the app navigation open state
     * @deprecated will be removed with the next version - use `disableSwipe` instead
     */
    allowSwipeNavigation: {
      type: Boolean,
      default: true
    },
    /**
     * Allows to disable the control by swipe of the app navigation open state.
     */
    disableSwipe: {
      type: Boolean,
      default: false
    },
    /**
     * Allows you to set the default width of the resizable list in % on vertical-split
     * Allows you to set the default height of the resizable list in % on horizontal-split
     * Must be between listMinWidth and listMaxWidth
     */
    listSize: {
      type: Number,
      default: 20
    },
    /**
     * Allows you to set the minimum width of the list column in % on vertical-split
     * Allows you to set the minimum height of the list column in % on horizontal-split
     */
    listMinWidth: {
      type: Number,
      default: 15
    },
    /**
     * Allows you to set the maximum width of the list column in % on vertical-split
     * Allows you to set the maximum height of the list column in % on horizontal-split
     */
    listMaxWidth: {
      type: Number,
      default: 40
    },
    /**
     * Specify the config key for the pane config sizes
     * Default is the global var appName if you use the webpack-vue-config
     */
    paneConfigKey: {
      type: String,
      default: ""
    },
    /**
     * When in mobile view, only the list or the details are shown.
     *
     * If you provide a list, you need to provide a variable
     * that will be set to true by the user when an element of
     * the list gets selected. The details will then show a back
     * arrow to return to the list that will update this prop to false.
     */
    showDetails: {
      type: Boolean,
      default: true
    },
    /**
     * Specify the `<h1>` page heading
     */
    pageHeading: {
      type: String,
      default: null
    },
    /**
     * Content layout used when there is a list together with content:
     * - `vertical-split` - a 2-column layout with list and default content separated vertically
     * - `no-split` - a single column layout; List is shown when `showDetails` is `false`, otherwise the default slot content is shown with a back button to return to the list.
     * - 'horizontal-split' - a 2-column layout with list and default content separated horizontally
     * On mobile screen `no-split` layout is forced.
     */
    layout: {
      type: String,
      default: "vertical-split",
      validator(value) {
        return ["no-split", "vertical-split", "horizontal-split"].includes(value);
      }
    },
    /**
     * Allow setting the page's `<title>`
     *
     * If a page heading is set it defaults to `{pageHeading} - {appName} - {productName}` e.g. `Favorites - Files - Nextcloud`.
     * When the page heading and the app name is the same only one is used, e.g. `Files - Files - Nextcloud` is shown as `Files - Nextcloud`.
     * When setting the prop then the following format will be used: `{pageTitle} - {pageHeading || appName} - {productName}`
     */
    pageTitle: {
      type: String,
      default: null
    }
  },
  emits: [
    "update:showDetails",
    "resize:list"
  ],
  setup() {
    return {
      isMobile: useIsMobile(),
      isRtl
    };
  },
  data() {
    return {
      contentHeight: 0,
      hasList: false,
      hasContent: false,
      swiping: {},
      listPaneSize: this.restorePaneConfig()
    };
  },
  computed: {
    paneConfigID() {
      if (this.paneConfigKey !== "") {
        return `pane-list-size-${this.paneConfigKey}`;
      }
      try {
        return `pane-list-size-${appName}`;
      } catch (e) {
        console.info("[INFO] AppContent:", "falling back to global nextcloud pane config");
        return "pane-list-size-nextcloud";
      }
    },
    detailsPaneSize() {
      if (this.listPaneSize) {
        return 100 - this.listPaneSize;
      }
      return this.paneDefaults.details.size;
    },
    paneDefaults() {
      return {
        list: {
          size: this.listSize,
          min: this.listMinWidth,
          max: this.listMaxWidth
        },
        // set the inverse values of the details column
        // based on the provided (or default) values of the list column
        details: {
          size: 100 - this.listSize,
          min: 100 - this.listMaxWidth,
          max: 100 - this.listMinWidth
        }
      };
    },
    realPageTitle() {
      const entries2 = /* @__PURE__ */ new Set();
      if (this.pageTitle) {
        entries2.add(this.pageTitle);
      }
      if (this.pageHeading) {
        entries2.add(this.pageHeading);
      }
      if (entries2.size === 0) {
        return null;
      }
      if (entries2.size < 2) {
        entries2.add(localizedAppName);
      }
      entries2.add(productName);
      return [...entries2.values()].join(" - ");
    }
  },
  watch: {
    realPageTitle: {
      immediate: true,
      handler() {
        if (this.realPageTitle !== null) {
          document.title = this.realPageTitle;
        }
      }
    }
  },
  updated() {
    this.checkSlots();
  },
  mounted() {
    if (this.allowSwipeNavigation && !this.disableSwipe) {
      this.swiping = useSwipe(this.$el, {
        onSwipeEnd: this.handleSwipe
      });
    }
    this.checkSlots();
    this.restorePaneConfig();
  },
  methods: {
    /**
     * handle the swipe event
     *
     * @param {TouchEvent} e The touch event
     * @param {import('@vueuse/core').SwipeDirection} direction The swipe direction of the event
     */
    handleSwipe(e, direction) {
      const minSwipeX = 70;
      const touchZone = 300;
      if (Math.abs(this.swiping.lengthX) > minSwipeX) {
        if (this.swiping.coordsStart.x < touchZone / 2 && direction === "right") {
          emit("toggle-navigation", {
            open: true
          });
        } else if (this.swiping.coordsStart.x < touchZone * 1.5 && direction === "left") {
          emit("toggle-navigation", {
            open: false
          });
        }
      }
    },
    handlePaneResize(event) {
      const listPaneSize = parseInt(event[0].size, 10);
      browserStorage.setItem(this.paneConfigID, JSON.stringify(listPaneSize));
      this.listPaneSize = listPaneSize;
      this.$emit("resize:list", { size: listPaneSize });
      console.debug("AppContent pane config", listPaneSize);
    },
    // $slots is not reactive, we need to update this manually
    checkSlots() {
      this.hasList = !!this.$scopedSlots.list;
      this.hasContent = !!this.$scopedSlots.default;
    },
    // browserStorage is not reactive, we need to update this manually
    restorePaneConfig() {
      const listPaneSize = parseInt(browserStorage.getItem(this.paneConfigID), 10);
      if (!isNaN(listPaneSize) && listPaneSize !== this.listPaneSize) {
        console.debug("AppContent pane config", listPaneSize);
        this.listPaneSize = listPaneSize;
        return listPaneSize;
      }
    },
    /**
     * The user clicked the back arrow from the details view
     */
    hideDetails() {
      this.$emit("update:showDetails", false);
    }
  }
};
var _sfc_render$Z = function render22() {
  var _vm = this, _c = _vm._self._c;
  return _c("main", { staticClass: "app-content no-snapper", class: { "app-content--has-list": _vm.hasList }, attrs: { "id": "app-content-vue" } }, [_vm.pageHeading ? _c("h1", { staticClass: "hidden-visually" }, [_vm._v(" " + _vm._s(_vm.pageHeading) + " ")]) : _vm._e(), _vm.hasList ? [_vm.isMobile || _vm.layout === "no-split" ? _c("div", { staticClass: "app-content-wrapper app-content-wrapper--no-split", class: {
    "app-content-wrapper--show-details": _vm.showDetails,
    "app-content-wrapper--show-list": !_vm.showDetails,
    "app-content-wrapper--mobile": _vm.isMobile
  } }, [_vm.showDetails ? _c("NcAppDetailsToggle", { nativeOn: { "click": function($event) {
    $event.stopPropagation();
    $event.preventDefault();
    return _vm.hideDetails.apply(null, arguments);
  } } }) : _vm._e(), _c("div", { directives: [{ name: "show", rawName: "v-show", value: !_vm.showDetails, expression: "!showDetails" }] }, [_vm._t("list")], 2), _vm.showDetails ? _vm._t("default") : _vm._e()], 2) : _vm.layout === "vertical-split" || _vm.layout === "horizontal-split" ? _c("div", { staticClass: "app-content-wrapper" }, [_c("Splitpanes", { staticClass: "default-theme", class: {
    "splitpanes--horizontal": _vm.layout === "horizontal-split",
    "splitpanes--vertical": _vm.layout === "vertical-split"
  }, attrs: { "horizontal": _vm.layout === "horizontal-split", "rtl": _vm.isRtl }, on: { "resized": _vm.handlePaneResize } }, [_c("Pane", { staticClass: "splitpanes__pane-list", attrs: { "size": _vm.listPaneSize || _vm.paneDefaults.list.size, "min-size": _vm.paneDefaults.list.min, "max-size": _vm.paneDefaults.list.max } }, [_vm._t("list")], 2), _c("Pane", { staticClass: "splitpanes__pane-details", attrs: { "size": _vm.detailsPaneSize, "min-size": _vm.paneDefaults.details.min, "max-size": _vm.paneDefaults.details.max } }, [_vm._t("default")], 2)], 1)], 1) : _vm._e()] : _vm._e(), !_vm.hasList ? _vm._t("default") : _vm._e()], 2);
};
var _sfc_staticRenderFns$Z = [];
var __component__$_ = /* @__PURE__ */ normalizeComponent$3(
  _sfc_main$Z,
  _sfc_render$Z,
  _sfc_staticRenderFns$Z,
  false,
  null,
  "bfc6f887"
);
const NcAppContent = __component__$_.exports;
function normalizeComponent$2(scriptExports, render66, staticRenderFns2, functionalTemplate, injectStyles, scopeId, moduleIdentifier, shadowMode) {
  var options = typeof scriptExports === "function" ? scriptExports.options : scriptExports;
  if (render66) {
    options.render = render66;
    options.staticRenderFns = staticRenderFns2;
    options._compiled = true;
  }
  if (scopeId) {
    options._scopeId = "data-v-" + scopeId;
  }
  return {
    exports: scriptExports,
    options
  };
}
const _sfc_main$Y = {
  name: "PlusIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$Y = function render4() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon plus-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$Y = [];
var __component__$Z = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$Y,
  _sfc_render$Y,
  _sfc_staticRenderFns$Y,
  false,
  null,
  null
);
const PlusIcon = __component__$Z.exports;
const _sfc_main$X = {
  name: "PencilIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$X = function render5() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon pencil-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$X = [];
var __component__$Y = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$X,
  _sfc_render$X,
  _sfc_staticRenderFns$X,
  false,
  null,
  null
);
const PencilIcon = __component__$Y.exports;
var vueGridLayout_common = { exports: {} };
var vue_runtime_common = { exports: {} };
var vue_runtime_common_prod = { exports: {} };
var hasRequiredVue_runtime_common_prod;
function requireVue_runtime_common_prod() {
  if (hasRequiredVue_runtime_common_prod) return vue_runtime_common_prod.exports;
  hasRequiredVue_runtime_common_prod = 1;
  var define_global_process_env_default2 = {};
  /*!
   * Vue.js v2.7.16
   * (c) 2014-2023 Evan You
   * Released under the MIT License.
   */
  /*!
   * Vue.js v2.7.16
   * (c) 2014-2023 Evan You
   * Released under the MIT License.
   */
  const t2 = Object.freeze({}), e = Array.isArray;
  function n2(t3) {
    return null == t3;
  }
  function o(t3) {
    return null != t3;
  }
  function r(t3) {
    return true === t3;
  }
  function s(t3) {
    return "string" == typeof t3 || "number" == typeof t3 || "symbol" == typeof t3 || "boolean" == typeof t3;
  }
  function i(t3) {
    return "function" == typeof t3;
  }
  function c(t3) {
    return null !== t3 && "object" == typeof t3;
  }
  const a = Object.prototype.toString;
  function l(t3) {
    return "[object Object]" === a.call(t3);
  }
  function u2(t3) {
    const e2 = parseFloat(String(t3));
    return e2 >= 0 && Math.floor(e2) === e2 && isFinite(t3);
  }
  function f2(t3) {
    return o(t3) && "function" == typeof t3.then && "function" == typeof t3.catch;
  }
  function d(t3) {
    return null == t3 ? "" : Array.isArray(t3) || l(t3) && t3.toString === a ? JSON.stringify(t3, p, 2) : String(t3);
  }
  function p(t3, e2) {
    return e2 && e2.__v_isRef ? e2.value : e2;
  }
  function h(t3) {
    const e2 = parseFloat(t3);
    return isNaN(e2) ? t3 : e2;
  }
  function m(t3, e2) {
    const n22 = /* @__PURE__ */ Object.create(null), o2 = t3.split(",");
    for (let t42 = 0; t42 < o2.length; t42++) n22[o2[t42]] = true;
    return e2 ? (t42) => n22[t42.toLowerCase()] : (t42) => n22[t42];
  }
  const _2 = m("key,ref,slot,slot-scope,is");
  function v(t3, e2) {
    const n22 = t3.length;
    if (n22) {
      if (e2 === t3[n22 - 1]) return void (t3.length = n22 - 1);
      const o2 = t3.indexOf(e2);
      if (o2 > -1) return t3.splice(o2, 1);
    }
  }
  const y = Object.prototype.hasOwnProperty;
  function g(t3, e2) {
    return y.call(t3, e2);
  }
  function b(t3) {
    const e2 = /* @__PURE__ */ Object.create(null);
    return function(n22) {
      return e2[n22] || (e2[n22] = t3(n22));
    };
  }
  const $ = /-(\w)/g, w = b((t3) => t3.replace($, (t42, e2) => e2 ? e2.toUpperCase() : "")), C = b((t3) => t3.charAt(0).toUpperCase() + t3.slice(1)), x = /\B([A-Z])/g, O = b((t3) => t3.replace(x, "-$1").toLowerCase());
  const k = Function.prototype.bind ? function(t3, e2) {
    return t3.bind(e2);
  } : function(t3, e2) {
    function n22(n3) {
      const o2 = arguments.length;
      return o2 ? o2 > 1 ? t3.apply(e2, arguments) : t3.call(e2, n3) : t3.call(e2);
    }
    return n22._length = t3.length, n22;
  };
  function S(t3, e2) {
    e2 = e2 || 0;
    let n22 = t3.length - e2;
    const o2 = new Array(n22);
    for (; n22--; ) o2[n22] = t3[n22 + e2];
    return o2;
  }
  function j(t3, e2) {
    for (const n22 in e2) t3[n22] = e2[n22];
    return t3;
  }
  function A(t3) {
    const e2 = {};
    for (let n22 = 0; n22 < t3.length; n22++) t3[n22] && j(e2, t3[n22]);
    return e2;
  }
  function T(t3, e2, n22) {
  }
  const E = (t3, e2, n22) => false, P = (t3) => t3;
  function I(t3, e2) {
    if (t3 === e2) return true;
    const n22 = c(t3), o2 = c(e2);
    if (!n22 || !o2) return !n22 && !o2 && String(t3) === String(e2);
    try {
      const n3 = Array.isArray(t3), o3 = Array.isArray(e2);
      if (n3 && o3) return t3.length === e2.length && t3.every((t42, n4) => I(t42, e2[n4]));
      if (t3 instanceof Date && e2 instanceof Date) return t3.getTime() === e2.getTime();
      if (n3 || o3) return false;
      {
        const n4 = Object.keys(t3), o4 = Object.keys(e2);
        return n4.length === o4.length && n4.every((n5) => I(t3[n5], e2[n5]));
      }
    } catch (t42) {
      return false;
    }
  }
  function D(t3, e2) {
    for (let n22 = 0; n22 < t3.length; n22++) if (I(t3[n22], e2)) return n22;
    return -1;
  }
  function N(t3) {
    let e2 = false;
    return function() {
      e2 || (e2 = true, t3.apply(this, arguments));
    };
  }
  function M(t3, e2) {
    return t3 === e2 ? 0 === t3 && 1 / t3 != 1 / e2 : t3 == t3 || e2 == e2;
  }
  const L = "data-server-rendered", R = ["component", "directive", "filter"], F = ["beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeDestroy", "destroyed", "activated", "deactivated", "errorCaptured", "serverPrefetch", "renderTracked", "renderTriggered"];
  var U = { optionMergeStrategies: /* @__PURE__ */ Object.create(null), silent: false, productionTip: false, devtools: false, performance: false, errorHandler: null, warnHandler: null, ignoredElements: [], keyCodes: /* @__PURE__ */ Object.create(null), isReservedTag: E, isReservedAttr: E, isUnknownElement: E, getTagNamespace: T, parsePlatformTagName: P, mustUseProp: E, async: true, _lifecycleHooks: F };
  function B(t3) {
    const e2 = (t3 + "").charCodeAt(0);
    return 36 === e2 || 95 === e2;
  }
  function V(t3, e2, n22, o2) {
    Object.defineProperty(t3, e2, { value: n22, enumerable: false, writable: true, configurable: true });
  }
  const z = new RegExp(`[^${/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/.source}.$_\\d]`);
  const H = "__proto__" in {}, W = "undefined" != typeof window, K = W && window.navigator.userAgent.toLowerCase(), q = K && /msie|trident/.test(K), G = K && K.indexOf("msie 9.0") > 0, Z = K && K.indexOf("edge/") > 0;
  K && K.indexOf("android");
  const J = K && /iphone|ipad|ipod|ios/.test(K);
  const X = K && K.match(/firefox\/(\d+)/), Q = {}.watch;
  let Y, tt = false;
  if (W) try {
    const t3 = {};
    Object.defineProperty(t3, "passive", { get() {
      tt = true;
    } }), window.addEventListener("test-passive", null, t3);
  } catch (t3) {
  }
  const et = () => (void 0 === Y && (Y = !W && "undefined" != typeof commonjsGlobal && (commonjsGlobal.process && "server" === define_global_process_env_default2.VUE_ENV)), Y);
  function ot(t3) {
    return "function" == typeof t3 && /native code/.test(t3.toString());
  }
  const rt = "undefined" != typeof Symbol && ot(Symbol) && "undefined" != typeof Reflect && ot(Reflect.ownKeys);
  let st;
  st = "undefined" != typeof Set && ot(Set) ? Set : class {
    constructor() {
      this.set = /* @__PURE__ */ Object.create(null);
    }
    has(t3) {
      return true === this.set[t3];
    }
    add(t3) {
      this.set[t3] = true;
    }
    clear() {
      this.set = /* @__PURE__ */ Object.create(null);
    }
  };
  let it = null;
  function ct(t3 = null) {
    t3 || it && it._scope.off(), it = t3, t3 && t3._scope.on();
  }
  class at {
    constructor(t3, e2, n22, o2, r2, s2, i2, c2) {
      this.tag = t3, this.data = e2, this.children = n22, this.text = o2, this.elm = r2, this.ns = void 0, this.context = s2, this.fnContext = void 0, this.fnOptions = void 0, this.fnScopeId = void 0, this.key = e2 && e2.key, this.componentOptions = i2, this.componentInstance = void 0, this.parent = void 0, this.raw = false, this.isStatic = false, this.isRootInsert = true, this.isComment = false, this.isCloned = false, this.isOnce = false, this.asyncFactory = c2, this.asyncMeta = void 0, this.isAsyncPlaceholder = false;
    }
    get child() {
      return this.componentInstance;
    }
  }
  const lt = (t3 = "") => {
    const e2 = new at();
    return e2.text = t3, e2.isComment = true, e2;
  };
  function ut(t3) {
    return new at(void 0, void 0, void 0, String(t3));
  }
  function ft(t3) {
    const e2 = new at(t3.tag, t3.data, t3.children && t3.children.slice(), t3.text, t3.elm, t3.context, t3.componentOptions, t3.asyncFactory);
    return e2.ns = t3.ns, e2.isStatic = t3.isStatic, e2.key = t3.key, e2.isComment = t3.isComment, e2.fnContext = t3.fnContext, e2.fnOptions = t3.fnOptions, e2.fnScopeId = t3.fnScopeId, e2.asyncMeta = t3.asyncMeta, e2.isCloned = true, e2;
  }
  let dt = 0;
  const pt = [], ht = () => {
    for (let t3 = 0; t3 < pt.length; t3++) {
      const e2 = pt[t3];
      e2.subs = e2.subs.filter((t42) => t42), e2._pending = false;
    }
    pt.length = 0;
  };
  class mt {
    constructor() {
      this._pending = false, this.id = dt++, this.subs = [];
    }
    addSub(t3) {
      this.subs.push(t3);
    }
    removeSub(t3) {
      this.subs[this.subs.indexOf(t3)] = null, this._pending || (this._pending = true, pt.push(this));
    }
    depend(t3) {
      mt.target && mt.target.addDep(this);
    }
    notify(t3) {
      const e2 = this.subs.filter((t42) => t42);
      for (let t42 = 0, n22 = e2.length; t42 < n22; t42++) {
        e2[t42].update();
      }
    }
  }
  mt.target = null;
  const _t = [];
  function vt(t3) {
    _t.push(t3), mt.target = t3;
  }
  function yt() {
    _t.pop(), mt.target = _t[_t.length - 1];
  }
  const gt = Array.prototype, bt = Object.create(gt);
  ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"].forEach(function(t3) {
    const e2 = gt[t3];
    V(bt, t3, function(...n22) {
      const o2 = e2.apply(this, n22), r2 = this.__ob__;
      let s2;
      switch (t3) {
        case "push":
        case "unshift":
          s2 = n22;
          break;
        case "splice":
          s2 = n22.slice(2);
      }
      return s2 && r2.observeArray(s2), r2.dep.notify(), o2;
    });
  });
  const $t = Object.getOwnPropertyNames(bt), wt = {};
  let Ct = true;
  function xt(t3) {
    Ct = t3;
  }
  const Ot = { notify: T, depend: T, addSub: T, removeSub: T };
  class kt {
    constructor(t3, n22 = false, o2 = false) {
      if (this.value = t3, this.shallow = n22, this.mock = o2, this.dep = o2 ? Ot : new mt(), this.vmCount = 0, V(t3, "__ob__", this), e(t3)) {
        if (!o2) if (H) t3.__proto__ = bt;
        else for (let e2 = 0, n3 = $t.length; e2 < n3; e2++) {
          const n4 = $t[e2];
          V(t3, n4, bt[n4]);
        }
        n22 || this.observeArray(t3);
      } else {
        const e2 = Object.keys(t3);
        for (let r2 = 0; r2 < e2.length; r2++) {
          jt(t3, e2[r2], wt, void 0, n22, o2);
        }
      }
    }
    observeArray(t3) {
      for (let e2 = 0, n22 = t3.length; e2 < n22; e2++) St(t3[e2], false, this.mock);
    }
  }
  function St(t3, n22, o2) {
    return t3 && g(t3, "__ob__") && t3.__ob__ instanceof kt ? t3.__ob__ : !Ct || !o2 && et() || !e(t3) && !l(t3) || !Object.isExtensible(t3) || t3.__v_skip || Rt(t3) || t3 instanceof at ? void 0 : new kt(t3, n22, o2);
  }
  function jt(t3, n22, o2, r2, s2, i2, c2 = false) {
    const a2 = new mt(), l2 = Object.getOwnPropertyDescriptor(t3, n22);
    if (l2 && false === l2.configurable) return;
    const u22 = l2 && l2.get, f22 = l2 && l2.set;
    u22 && !f22 || o2 !== wt && 2 !== arguments.length || (o2 = t3[n22]);
    let d2 = s2 ? o2 && o2.__ob__ : St(o2, false, i2);
    return Object.defineProperty(t3, n22, { enumerable: true, configurable: true, get: function() {
      const n3 = u22 ? u22.call(t3) : o2;
      return mt.target && (a2.depend(), d2 && (d2.dep.depend(), e(n3) && Et(n3))), Rt(n3) && !s2 ? n3.value : n3;
    }, set: function(e2) {
      const n3 = u22 ? u22.call(t3) : o2;
      if (M(n3, e2)) {
        if (f22) f22.call(t3, e2);
        else {
          if (u22) return;
          if (!s2 && Rt(n3) && !Rt(e2)) return void (n3.value = e2);
          o2 = e2;
        }
        d2 = s2 ? e2 && e2.__ob__ : St(e2, false, i2), a2.notify();
      }
    } }), a2;
  }
  function At(t3, n22, o2) {
    if (Mt(t3)) return;
    const r2 = t3.__ob__;
    return e(t3) && u2(n22) ? (t3.length = Math.max(t3.length, n22), t3.splice(n22, 1, o2), r2 && !r2.shallow && r2.mock && St(o2, false, true), o2) : n22 in t3 && !(n22 in Object.prototype) ? (t3[n22] = o2, o2) : t3._isVue || r2 && r2.vmCount ? o2 : r2 ? (jt(r2.value, n22, o2, void 0, r2.shallow, r2.mock), r2.dep.notify(), o2) : (t3[n22] = o2, o2);
  }
  function Tt(t3, n22) {
    if (e(t3) && u2(n22)) return void t3.splice(n22, 1);
    const o2 = t3.__ob__;
    t3._isVue || o2 && o2.vmCount || Mt(t3) || g(t3, n22) && (delete t3[n22], o2 && o2.dep.notify());
  }
  function Et(t3) {
    for (let n22, o2 = 0, r2 = t3.length; o2 < r2; o2++) n22 = t3[o2], n22 && n22.__ob__ && n22.__ob__.dep.depend(), e(n22) && Et(n22);
  }
  function Pt(t3) {
    return It(t3, true), V(t3, "__v_isShallow", true), t3;
  }
  function It(t3, e2) {
    Mt(t3) || St(t3, e2, et());
  }
  function Dt(t3) {
    return Mt(t3) ? Dt(t3.__v_raw) : !(!t3 || !t3.__ob__);
  }
  function Nt(t3) {
    return !(!t3 || !t3.__v_isShallow);
  }
  function Mt(t3) {
    return !(!t3 || !t3.__v_isReadonly);
  }
  const Lt = "__v_isRef";
  function Rt(t3) {
    return !(!t3 || true !== t3.__v_isRef);
  }
  function Ft(t3, e2) {
    if (Rt(t3)) return t3;
    const n22 = {};
    return V(n22, Lt, true), V(n22, "__v_isShallow", e2), V(n22, "dep", jt(n22, "value", t3, null, e2, et())), n22;
  }
  function Ut(t3, e2, n22) {
    Object.defineProperty(t3, n22, { enumerable: true, configurable: true, get: () => {
      const t42 = e2[n22];
      if (Rt(t42)) return t42.value;
      {
        const e3 = t42 && t42.__ob__;
        return e3 && e3.dep.depend(), t42;
      }
    }, set: (t42) => {
      const o2 = e2[n22];
      Rt(o2) && !Rt(t42) ? o2.value = t42 : e2[n22] = t42;
    } });
  }
  function Bt(t3, e2, n22) {
    const o2 = t3[e2];
    if (Rt(o2)) return o2;
    const r2 = { get value() {
      const o3 = t3[e2];
      return void 0 === o3 ? n22 : o3;
    }, set value(n3) {
      t3[e2] = n3;
    } };
    return V(r2, Lt, true), r2;
  }
  const Vt = "__v_rawToReadonly", zt = "__v_rawToShallowReadonly";
  function Ht(t3) {
    return Wt(t3, false);
  }
  function Wt(t3, e2) {
    if (!l(t3)) return t3;
    if (Mt(t3)) return t3;
    const n22 = e2 ? zt : Vt, o2 = t3[n22];
    if (o2) return o2;
    const r2 = Object.create(Object.getPrototypeOf(t3));
    V(t3, n22, r2), V(r2, "__v_isReadonly", true), V(r2, "__v_raw", t3), Rt(t3) && V(r2, Lt, true), (e2 || Nt(t3)) && V(r2, "__v_isShallow", true);
    const s2 = Object.keys(t3);
    for (let n3 = 0; n3 < s2.length; n3++) Kt(r2, t3, s2[n3], e2);
    return r2;
  }
  function Kt(t3, e2, n22, o2) {
    Object.defineProperty(t3, n22, { enumerable: true, configurable: true, get() {
      const t42 = e2[n22];
      return o2 || !l(t42) ? t42 : Ht(t42);
    }, set() {
    } });
  }
  const qt = "watcher", Gt = `${qt} callback`, Zt = `${qt} getter`, Jt = `${qt} cleanup`;
  function Xt(t3, e2) {
    return Yt(t3, null, { flush: "post" });
  }
  const Qt = {};
  function Yt(n22, o2, { immediate: r2, deep: s2, flush: c2 = "pre", onTrack: a2, onTrigger: l2 } = t2) {
    const u22 = it, f22 = (t3, e2, n3 = null) => {
      const o3 = Ke(t3, null, n3, u22, e2);
      return s2 && o3 && o3.__ob__ && o3.__ob__.dep.depend(), o3;
    };
    let d2, p2, h2 = false, m2 = false;
    if (Rt(n22) ? (d2 = () => n22.value, h2 = Nt(n22)) : Dt(n22) ? (d2 = () => (n22.__ob__.dep.depend(), n22), s2 = true) : e(n22) ? (m2 = true, h2 = n22.some((t3) => Dt(t3) || Nt(t3)), d2 = () => n22.map((t3) => Rt(t3) ? t3.value : Dt(t3) ? (t3.__ob__.dep.depend(), yn(t3)) : i(t3) ? f22(t3, Zt) : void 0)) : d2 = i(n22) ? o2 ? () => f22(n22, Zt) : () => {
      if (!u22 || !u22._isDestroyed) return p2 && p2(), f22(n22, qt, [_22]);
    } : T, o2 && s2) {
      const t3 = d2;
      d2 = () => yn(t3());
    }
    let _22 = (t3) => {
      p2 = v2.onStop = () => {
        f22(t3, Jt);
      };
    };
    if (et()) return _22 = T, o2 ? r2 && f22(o2, Gt, [d2(), m2 ? [] : void 0, _22]) : d2(), T;
    const v2 = new wn(it, d2, T, { lazy: true });
    v2.noRecurse = !o2;
    let y2 = m2 ? [] : Qt;
    return v2.run = () => {
      if (v2.active) if (o2) {
        const t3 = v2.get();
        (s2 || h2 || (m2 ? t3.some((t42, e2) => M(t42, y2[e2])) : M(t3, y2))) && (p2 && p2(), f22(o2, Gt, [t3, y2 === Qt ? void 0 : y2, _22]), y2 = t3);
      } else v2.get();
    }, "sync" === c2 ? v2.update = v2.run : "post" === c2 ? (v2.post = true, v2.update = () => zn(v2)) : v2.update = () => {
      if (u22 && u22 === it && !u22._isMounted) {
        const t3 = u22._preWatchers || (u22._preWatchers = []);
        t3.indexOf(v2) < 0 && t3.push(v2);
      } else zn(v2);
    }, o2 ? r2 ? v2.run() : y2 = v2.get() : "post" === c2 && u22 ? u22.$once("hook:mounted", () => v2.get()) : v2.get(), () => {
      v2.teardown();
    };
  }
  let te;
  class ee {
    constructor(t3 = false) {
      this.detached = t3, this.active = true, this.effects = [], this.cleanups = [], this.parent = te, !t3 && te && (this.index = (te.scopes || (te.scopes = [])).push(this) - 1);
    }
    run(t3) {
      if (this.active) {
        const e2 = te;
        try {
          return te = this, t3();
        } finally {
          te = e2;
        }
      }
    }
    on() {
      te = this;
    }
    off() {
      te = this.parent;
    }
    stop(t3) {
      if (this.active) {
        let e2, n22;
        for (e2 = 0, n22 = this.effects.length; e2 < n22; e2++) this.effects[e2].teardown();
        for (e2 = 0, n22 = this.cleanups.length; e2 < n22; e2++) this.cleanups[e2]();
        if (this.scopes) for (e2 = 0, n22 = this.scopes.length; e2 < n22; e2++) this.scopes[e2].stop(true);
        if (!this.detached && this.parent && !t3) {
          const t42 = this.parent.scopes.pop();
          t42 && t42 !== this && (this.parent.scopes[this.index] = t42, t42.index = this.index);
        }
        this.parent = void 0, this.active = false;
      }
    }
  }
  function ne() {
    return te;
  }
  function oe(t3) {
    const e2 = t3._provided, n22 = t3.$parent && t3.$parent._provided;
    return n22 === e2 ? t3._provided = Object.create(n22) : e2;
  }
  const re2 = b((t3) => {
    const e2 = "&" === t3.charAt(0), n22 = "~" === (t3 = e2 ? t3.slice(1) : t3).charAt(0), o2 = "!" === (t3 = n22 ? t3.slice(1) : t3).charAt(0);
    return { name: t3 = o2 ? t3.slice(1) : t3, once: n22, capture: o2, passive: e2 };
  });
  function se(t3, n22) {
    function o2() {
      const t42 = o2.fns;
      if (!e(t42)) return Ke(t42, null, arguments, n22, "v-on handler");
      {
        const e2 = t42.slice();
        for (let t5 = 0; t5 < e2.length; t5++) Ke(e2[t5], null, arguments, n22, "v-on handler");
      }
    }
    return o2.fns = t3, o2;
  }
  function ie(t3, e2, o2, s2, i2, c2) {
    let a2, l2, u22, f22;
    for (a2 in t3) l2 = t3[a2], u22 = e2[a2], f22 = re2(a2), n2(l2) || (n2(u22) ? (n2(l2.fns) && (l2 = t3[a2] = se(l2, c2)), r(f22.once) && (l2 = t3[a2] = i2(f22.name, l2, f22.capture)), o2(f22.name, l2, f22.capture, f22.passive, f22.params)) : l2 !== u22 && (u22.fns = l2, t3[a2] = u22));
    for (a2 in e2) n2(t3[a2]) && (f22 = re2(a2), s2(f22.name, e2[a2], f22.capture));
  }
  function ce(t3, e2, s2) {
    let i2;
    t3 instanceof at && (t3 = t3.data.hook || (t3.data.hook = {}));
    const c2 = t3[e2];
    function a2() {
      s2.apply(this, arguments), v(i2.fns, a2);
    }
    n2(c2) ? i2 = se([a2]) : o(c2.fns) && r(c2.merged) ? (i2 = c2, i2.fns.push(a2)) : i2 = se([c2, a2]), i2.merged = true, t3[e2] = i2;
  }
  function ae(t3, e2, n22, r2, s2) {
    if (o(e2)) {
      if (g(e2, n22)) return t3[n22] = e2[n22], s2 || delete e2[n22], true;
      if (g(e2, r2)) return t3[n22] = e2[r2], s2 || delete e2[r2], true;
    }
    return false;
  }
  function le(t3) {
    return s(t3) ? [ut(t3)] : e(t3) ? fe(t3) : void 0;
  }
  function ue(t3) {
    return o(t3) && o(t3.text) && false === t3.isComment;
  }
  function fe(t3, i2) {
    const c2 = [];
    let a2, l2, u22, f22;
    for (a2 = 0; a2 < t3.length; a2++) l2 = t3[a2], n2(l2) || "boolean" == typeof l2 || (u22 = c2.length - 1, f22 = c2[u22], e(l2) ? l2.length > 0 && (l2 = fe(l2, `${i2 || ""}_${a2}`), ue(l2[0]) && ue(f22) && (c2[u22] = ut(f22.text + l2[0].text), l2.shift()), c2.push.apply(c2, l2)) : s(l2) ? ue(f22) ? c2[u22] = ut(f22.text + l2) : "" !== l2 && c2.push(ut(l2)) : ue(l2) && ue(f22) ? c2[u22] = ut(f22.text + l2.text) : (r(t3._isVList) && o(l2.tag) && n2(l2.key) && o(i2) && (l2.key = `__vlist${i2}_${a2}__`), c2.push(l2)));
    return c2;
  }
  function de(t3, n22) {
    let r2, s2, i2, a2, l2 = null;
    if (e(t3) || "string" == typeof t3) for (l2 = new Array(t3.length), r2 = 0, s2 = t3.length; r2 < s2; r2++) l2[r2] = n22(t3[r2], r2);
    else if ("number" == typeof t3) for (l2 = new Array(t3), r2 = 0; r2 < t3; r2++) l2[r2] = n22(r2 + 1, r2);
    else if (c(t3)) if (rt && t3[Symbol.iterator]) {
      l2 = [];
      const e2 = t3[Symbol.iterator]();
      let o2 = e2.next();
      for (; !o2.done; ) l2.push(n22(o2.value, l2.length)), o2 = e2.next();
    } else for (i2 = Object.keys(t3), l2 = new Array(i2.length), r2 = 0, s2 = i2.length; r2 < s2; r2++) a2 = i2[r2], l2[r2] = n22(t3[a2], a2, r2);
    return o(l2) || (l2 = []), l2._isVList = true, l2;
  }
  function pe(t3, e2, n22, o2) {
    const r2 = this.$scopedSlots[t3];
    let s2;
    r2 ? (n22 = n22 || {}, o2 && (n22 = j(j({}, o2), n22)), s2 = r2(n22) || (i(e2) ? e2() : e2)) : s2 = this.$slots[t3] || (i(e2) ? e2() : e2);
    const c2 = n22 && n22.slot;
    return c2 ? this.$createElement("template", { slot: c2 }, s2) : s2;
  }
  function he(t3) {
    return co(this.$options, "filters", t3) || P;
  }
  function me(t3, n22) {
    return e(t3) ? -1 === t3.indexOf(n22) : t3 !== n22;
  }
  function _e(t3, e2, n22, o2, r2) {
    const s2 = U.keyCodes[e2] || n22;
    return r2 && o2 && !U.keyCodes[e2] ? me(r2, o2) : s2 ? me(s2, t3) : o2 ? O(o2) !== e2 : void 0 === t3;
  }
  function ve(t3, n22, o2, r2, s2) {
    if (o2) {
      if (c(o2)) {
        let i2;
        e(o2) && (o2 = A(o2));
        for (const e2 in o2) {
          if ("class" === e2 || "style" === e2 || _2(e2)) i2 = t3;
          else {
            const o3 = t3.attrs && t3.attrs.type;
            i2 = r2 || U.mustUseProp(n22, o3, e2) ? t3.domProps || (t3.domProps = {}) : t3.attrs || (t3.attrs = {});
          }
          const c2 = w(e2), a2 = O(e2);
          if (!(c2 in i2) && !(a2 in i2) && (i2[e2] = o2[e2], s2)) {
            (t3.on || (t3.on = {}))[`update:${e2}`] = function(t42) {
              o2[e2] = t42;
            };
          }
        }
      }
    }
    return t3;
  }
  function ye(t3, e2) {
    const n22 = this._staticTrees || (this._staticTrees = []);
    let o2 = n22[t3];
    return o2 && !e2 || (o2 = n22[t3] = this.$options.staticRenderFns[t3].call(this._renderProxy, this._c, this), be(o2, `__static__${t3}`, false)), o2;
  }
  function ge(t3, e2, n22) {
    return be(t3, `__once__${e2}${n22 ? `_${n22}` : ""}`, true), t3;
  }
  function be(t3, n22, o2) {
    if (e(t3)) for (let e2 = 0; e2 < t3.length; e2++) t3[e2] && "string" != typeof t3[e2] && $e(t3[e2], `${n22}_${e2}`, o2);
    else $e(t3, n22, o2);
  }
  function $e(t3, e2, n22) {
    t3.isStatic = true, t3.key = e2, t3.isOnce = n22;
  }
  function we(t3, e2) {
    if (e2) {
      if (l(e2)) {
        const n22 = t3.on = t3.on ? j({}, t3.on) : {};
        for (const t42 in e2) {
          const o2 = n22[t42], r2 = e2[t42];
          n22[t42] = o2 ? [].concat(o2, r2) : r2;
        }
      }
    }
    return t3;
  }
  function Ce(t3, n22, o2, r2) {
    n22 = n22 || { $stable: !o2 };
    for (let r3 = 0; r3 < t3.length; r3++) {
      const s2 = t3[r3];
      e(s2) ? Ce(s2, n22, o2) : s2 && (s2.proxy && (s2.fn.proxy = true), n22[s2.key] = s2.fn);
    }
    return r2 && (n22.$key = r2), n22;
  }
  function xe(t3, e2) {
    for (let n22 = 0; n22 < e2.length; n22 += 2) {
      const o2 = e2[n22];
      "string" == typeof o2 && o2 && (t3[e2[n22]] = e2[n22 + 1]);
    }
    return t3;
  }
  function Oe(t3, e2) {
    return "string" == typeof t3 ? e2 + t3 : t3;
  }
  function ke(t3) {
    t3._o = ge, t3._n = h, t3._s = d, t3._l = de, t3._t = pe, t3._q = I, t3._i = D, t3._m = ye, t3._f = he, t3._k = _e, t3._b = ve, t3._v = ut, t3._e = lt, t3._u = Ce, t3._g = we, t3._d = xe, t3._p = Oe;
  }
  function Se(t3, e2) {
    if (!t3 || !t3.length) return {};
    const n22 = {};
    for (let o2 = 0, r2 = t3.length; o2 < r2; o2++) {
      const r3 = t3[o2], s2 = r3.data;
      if (s2 && s2.attrs && s2.attrs.slot && delete s2.attrs.slot, r3.context !== e2 && r3.fnContext !== e2 || !s2 || null == s2.slot) (n22.default || (n22.default = [])).push(r3);
      else {
        const t42 = s2.slot, e3 = n22[t42] || (n22[t42] = []);
        "template" === r3.tag ? e3.push.apply(e3, r3.children || []) : e3.push(r3);
      }
    }
    for (const t42 in n22) n22[t42].every(je) && delete n22[t42];
    return n22;
  }
  function je(t3) {
    return t3.isComment && !t3.asyncFactory || " " === t3.text;
  }
  function Ae(t3) {
    return t3.isComment && t3.asyncFactory;
  }
  function Te(e2, n22, o2, r2) {
    let s2;
    const i2 = Object.keys(o2).length > 0, c2 = n22 ? !!n22.$stable : !i2, a2 = n22 && n22.$key;
    if (n22) {
      if (n22._normalized) return n22._normalized;
      if (c2 && r2 && r2 !== t2 && a2 === r2.$key && !i2 && !r2.$hasNormal) return r2;
      s2 = {};
      for (const t3 in n22) n22[t3] && "$" !== t3[0] && (s2[t3] = Ee(e2, o2, t3, n22[t3]));
    } else s2 = {};
    for (const t3 in o2) t3 in s2 || (s2[t3] = Pe(o2, t3));
    return n22 && Object.isExtensible(n22) && (n22._normalized = s2), V(s2, "$stable", c2), V(s2, "$key", a2), V(s2, "$hasNormal", i2), s2;
  }
  function Ee(t3, n22, o2, r2) {
    const s2 = function() {
      const n3 = it;
      ct(t3);
      let o3 = arguments.length ? r2.apply(null, arguments) : r2({});
      o3 = o3 && "object" == typeof o3 && !e(o3) ? [o3] : le(o3);
      const s3 = o3 && o3[0];
      return ct(n3), o3 && (!s3 || 1 === o3.length && s3.isComment && !Ae(s3)) ? void 0 : o3;
    };
    return r2.proxy && Object.defineProperty(n22, o2, { get: s2, enumerable: true, configurable: true }), s2;
  }
  function Pe(t3, e2) {
    return () => t3[e2];
  }
  function Ie(e2) {
    return { get attrs() {
      if (!e2._attrsProxy) {
        const n22 = e2._attrsProxy = {};
        V(n22, "_v_attr_proxy", true), De(n22, e2.$attrs, t2, e2, "$attrs");
      }
      return e2._attrsProxy;
    }, get listeners() {
      if (!e2._listenersProxy) {
        De(e2._listenersProxy = {}, e2.$listeners, t2, e2, "$listeners");
      }
      return e2._listenersProxy;
    }, get slots() {
      return function(t3) {
        t3._slotsProxy || Me(t3._slotsProxy = {}, t3.$scopedSlots);
        return t3._slotsProxy;
      }(e2);
    }, emit: k(e2.$emit, e2), expose(t3) {
      t3 && Object.keys(t3).forEach((n22) => Ut(e2, t3, n22));
    } };
  }
  function De(t3, e2, n22, o2, r2) {
    let s2 = false;
    for (const i2 in e2) i2 in t3 ? e2[i2] !== n22[i2] && (s2 = true) : (s2 = true, Ne(t3, i2, o2, r2));
    for (const n3 in t3) n3 in e2 || (s2 = true, delete t3[n3]);
    return s2;
  }
  function Ne(t3, e2, n22, o2) {
    Object.defineProperty(t3, e2, { enumerable: true, configurable: true, get: () => n22[o2][e2] });
  }
  function Me(t3, e2) {
    for (const n22 in e2) t3[n22] = e2[n22];
    for (const n22 in t3) n22 in e2 || delete t3[n22];
  }
  function Le() {
    const t3 = it;
    return t3._setupContext || (t3._setupContext = Ie(t3));
  }
  let Re = null;
  function Fe(t3, e2) {
    return (t3.__esModule || rt && "Module" === t3[Symbol.toStringTag]) && (t3 = t3.default), c(t3) ? e2.extend(t3) : t3;
  }
  function Ue(t3) {
    if (e(t3)) for (let e2 = 0; e2 < t3.length; e2++) {
      const n22 = t3[e2];
      if (o(n22) && (o(n22.componentOptions) || Ae(n22))) return n22;
    }
  }
  const Be = 1, Ve = 2;
  function ze(t3, n22, a2, l2, u22, f22) {
    return (e(a2) || s(a2)) && (u22 = l2, l2 = a2, a2 = void 0), r(f22) && (u22 = Ve), function(t42, n3, r2, s2, a3) {
      if (o(r2) && o(r2.__ob__)) return lt();
      o(r2) && o(r2.is) && (n3 = r2.is);
      if (!n3) return lt();
      e(s2) && i(s2[0]) && ((r2 = r2 || {}).scopedSlots = { default: s2[0] }, s2.length = 0);
      a3 === Ve ? s2 = le(s2) : a3 === Be && (s2 = function(t5) {
        for (let n4 = 0; n4 < t5.length; n4++) if (e(t5[n4])) return Array.prototype.concat.apply([], t5);
        return t5;
      }(s2));
      let l3, u3;
      if ("string" == typeof n3) {
        let e2;
        u3 = t42.$vnode && t42.$vnode.ns || U.getTagNamespace(n3), l3 = r2 && r2.pre || !o(e2 = co(t42.$options, "components", n3)) ? new at(n3, r2, s2, void 0, void 0, t42) : Xn(e2, r2, t42, s2, n3);
      } else l3 = Xn(n3, r2, t42, s2);
      return e(l3) ? l3 : o(l3) ? (o(u3) && He(l3, u3), o(r2) && function(t5) {
        c(t5.style) && yn(t5.style);
        c(t5.class) && yn(t5.class);
      }(r2), l3) : lt();
    }(t3, n22, a2, l2, u22);
  }
  function He(t3, e2, s2) {
    if (t3.ns = e2, "foreignObject" === t3.tag && (e2 = void 0, s2 = true), o(t3.children)) for (let i2 = 0, c2 = t3.children.length; i2 < c2; i2++) {
      const c3 = t3.children[i2];
      o(c3.tag) && (n2(c3.ns) || r(s2) && "svg" !== c3.tag) && He(c3, e2, s2);
    }
  }
  function We(t3, e2, n22) {
    vt();
    try {
      if (e2) {
        let o2 = e2;
        for (; o2 = o2.$parent; ) {
          const r2 = o2.$options.errorCaptured;
          if (r2) for (let s2 = 0; s2 < r2.length; s2++) try {
            if (false === r2[s2].call(o2, t3, e2, n22)) return;
          } catch (t42) {
            qe(t42, o2, "errorCaptured hook");
          }
        }
      }
      qe(t3, e2, n22);
    } finally {
      yt();
    }
  }
  function Ke(t3, e2, n22, o2, r2) {
    let s2;
    try {
      s2 = n22 ? t3.apply(e2, n22) : t3.call(e2), s2 && !s2._isVue && f2(s2) && !s2._handled && (s2.catch((t42) => We(t42, o2, r2 + " (Promise/async)")), s2._handled = true);
    } catch (t42) {
      We(t42, o2, r2);
    }
    return s2;
  }
  function qe(t3, e2, n22) {
    Ge(t3);
  }
  function Ge(t3, e2, n22) {
    if (!W || "undefined" == typeof console) throw t3;
    console.error(t3);
  }
  let Ze = false;
  const Je = [];
  let Xe, Qe = false;
  function Ye() {
    Qe = false;
    const t3 = Je.slice(0);
    Je.length = 0;
    for (let e2 = 0; e2 < t3.length; e2++) t3[e2]();
  }
  if ("undefined" != typeof Promise && ot(Promise)) {
    const t3 = Promise.resolve();
    Xe = () => {
      t3.then(Ye), J && setTimeout(T);
    }, Ze = true;
  } else if (q || "undefined" == typeof MutationObserver || !ot(MutationObserver) && "[object MutationObserverConstructor]" !== MutationObserver.toString()) Xe = "undefined" != typeof setImmediate && ot(setImmediate) ? () => {
    setImmediate(Ye);
  } : () => {
    setTimeout(Ye, 0);
  };
  else {
    let t3 = 1;
    const e2 = new MutationObserver(Ye), n22 = document.createTextNode(String(t3));
    e2.observe(n22, { characterData: true }), Xe = () => {
      t3 = (t3 + 1) % 2, n22.data = String(t3);
    }, Ze = true;
  }
  function tn(t3, e2) {
    let n22;
    if (Je.push(() => {
      if (t3) try {
        t3.call(e2);
      } catch (t42) {
        We(t42, e2, "nextTick");
      }
      else n22 && n22(e2);
    }), Qe || (Qe = true, Xe()), !t3 && "undefined" != typeof Promise) return new Promise((t42) => {
      n22 = t42;
    });
  }
  function en(t3) {
    return (e2, n22 = it) => {
      if (n22) return function(t42, e3, n3) {
        const o2 = t42.$options;
        o2[e3] = oo(o2[e3], n3);
      }(n22, t3, e2);
    };
  }
  const nn = en("beforeMount"), on = en("mounted"), rn = en("beforeUpdate"), sn = en("updated"), cn = en("beforeDestroy"), an = en("destroyed"), ln = en("activated"), un = en("deactivated"), fn = en("serverPrefetch"), dn = en("renderTracked"), pn = en("renderTriggered"), hn = en("errorCaptured");
  const mn = "2.7.16";
  var _n = Object.freeze({ __proto__: null, version: mn, defineComponent: function(t3) {
    return t3;
  }, ref: function(t3) {
    return Ft(t3, false);
  }, shallowRef: function(t3) {
    return Ft(t3, true);
  }, isRef: Rt, toRef: Bt, toRefs: function(t3) {
    const n22 = e(t3) ? new Array(t3.length) : {};
    for (const e2 in t3) n22[e2] = Bt(t3, e2);
    return n22;
  }, unref: function(t3) {
    return Rt(t3) ? t3.value : t3;
  }, proxyRefs: function(t3) {
    if (Dt(t3)) return t3;
    const e2 = {}, n22 = Object.keys(t3);
    for (let o2 = 0; o2 < n22.length; o2++) Ut(e2, t3, n22[o2]);
    return e2;
  }, customRef: function(t3) {
    const e2 = new mt(), { get: n22, set: o2 } = t3(() => {
      e2.depend();
    }, () => {
      e2.notify();
    }), r2 = { get value() {
      return n22();
    }, set value(t42) {
      o2(t42);
    } };
    return V(r2, Lt, true), r2;
  }, triggerRef: function(t3) {
    t3.dep && t3.dep.notify();
  }, reactive: function(t3) {
    return It(t3, false), t3;
  }, isReactive: Dt, isReadonly: Mt, isShallow: Nt, isProxy: function(t3) {
    return Dt(t3) || Mt(t3);
  }, shallowReactive: Pt, markRaw: function(t3) {
    return Object.isExtensible(t3) && V(t3, "__v_skip", true), t3;
  }, toRaw: function t22(e2) {
    const n22 = e2 && e2.__v_raw;
    return n22 ? t22(n22) : e2;
  }, readonly: Ht, shallowReadonly: function(t3) {
    return Wt(t3, true);
  }, computed: function(t3, e2) {
    let n22, o2;
    const r2 = i(t3);
    r2 ? (n22 = t3, o2 = T) : (n22 = t3.get, o2 = t3.set);
    const s2 = et() ? null : new wn(it, n22, T, { lazy: true }), c2 = { effect: s2, get value() {
      return s2 ? (s2.dirty && s2.evaluate(), mt.target && s2.depend(), s2.value) : n22();
    }, set value(t42) {
      o2(t42);
    } };
    return V(c2, Lt, true), V(c2, "__v_isReadonly", r2), c2;
  }, watch: function(t3, e2, n22) {
    return Yt(t3, e2, n22);
  }, watchEffect: function(t3, e2) {
    return Yt(t3, null, e2);
  }, watchPostEffect: Xt, watchSyncEffect: function(t3, e2) {
    return Yt(t3, null, { flush: "sync" });
  }, EffectScope: ee, effectScope: function(t3) {
    return new ee(t3);
  }, onScopeDispose: function(t3) {
    te && te.cleanups.push(t3);
  }, getCurrentScope: ne, provide: function(t3, e2) {
    it && (oe(it)[t3] = e2);
  }, inject: function(t3, e2, n22 = false) {
    const o2 = it;
    if (o2) {
      const r2 = o2.$parent && o2.$parent._provided;
      if (r2 && t3 in r2) return r2[t3];
      if (arguments.length > 1) return n22 && i(e2) ? e2.call(o2) : e2;
    }
  }, h: function(t3, e2, n22) {
    return ze(it, t3, e2, n22, 2, true);
  }, getCurrentInstance: function() {
    return it && { proxy: it };
  }, useSlots: function() {
    return Le().slots;
  }, useAttrs: function() {
    return Le().attrs;
  }, useListeners: function() {
    return Le().listeners;
  }, mergeDefaults: function(t3, n22) {
    const o2 = e(t3) ? t3.reduce((t42, e2) => (t42[e2] = {}, t42), {}) : t3;
    for (const t42 in n22) {
      const r2 = o2[t42];
      r2 ? e(r2) || i(r2) ? o2[t42] = { type: r2, default: n22[t42] } : r2.default = n22[t42] : null === r2 && (o2[t42] = { default: n22[t42] });
    }
    return o2;
  }, nextTick: tn, set: At, del: Tt, useCssModule: function(e2 = "$style") {
    {
      if (!it) return t2;
      const n22 = it[e2];
      return n22 || t2;
    }
  }, useCssVars: function(t3) {
    if (!W) return;
    const e2 = it;
    e2 && Xt(() => {
      const n22 = e2.$el, o2 = t3(e2, e2._setupProxy);
      if (n22 && 1 === n22.nodeType) {
        const t42 = n22.style;
        for (const e3 in o2) t42.setProperty(`--${e3}`, o2[e3]);
      }
    });
  }, defineAsyncComponent: function(t3) {
    i(t3) && (t3 = { loader: t3 });
    const { loader: e2, loadingComponent: n22, errorComponent: o2, delay: r2 = 200, timeout: s2, suspensible: c2 = false, onError: a2 } = t3;
    let l2 = null, u22 = 0;
    const f22 = () => {
      let t42;
      return l2 || (t42 = l2 = e2().catch((t5) => {
        if (t5 = t5 instanceof Error ? t5 : new Error(String(t5)), a2) return new Promise((e3, n3) => {
          a2(t5, () => e3((u22++, l2 = null, f22())), () => n3(t5), u22 + 1);
        });
        throw t5;
      }).then((e3) => t42 !== l2 && l2 ? l2 : (e3 && (e3.__esModule || "Module" === e3[Symbol.toStringTag]) && (e3 = e3.default), e3)));
    };
    return () => ({ component: f22(), delay: r2, timeout: s2, error: o2, loading: n22 });
  }, onBeforeMount: nn, onMounted: on, onBeforeUpdate: rn, onUpdated: sn, onBeforeUnmount: cn, onUnmounted: an, onActivated: ln, onDeactivated: un, onServerPrefetch: fn, onRenderTracked: dn, onRenderTriggered: pn, onErrorCaptured: function(t3, e2 = it) {
    hn(t3, e2);
  } });
  const vn = new st();
  function yn(t3) {
    return gn(t3, vn), vn.clear(), t3;
  }
  function gn(t3, n22) {
    let o2, r2;
    const s2 = e(t3);
    if (!(!s2 && !c(t3) || t3.__v_skip || Object.isFrozen(t3) || t3 instanceof at)) {
      if (t3.__ob__) {
        const e2 = t3.__ob__.dep.id;
        if (n22.has(e2)) return;
        n22.add(e2);
      }
      if (s2) for (o2 = t3.length; o2--; ) gn(t3[o2], n22);
      else if (Rt(t3)) gn(t3.value, n22);
      else for (r2 = Object.keys(t3), o2 = r2.length; o2--; ) gn(t3[r2[o2]], n22);
    }
  }
  let bn, $n = 0;
  class wn {
    constructor(t3, e2, n22, o2, r2) {
      !function(t42, e3 = te) {
        e3 && e3.active && e3.effects.push(t42);
      }(this, te && !te._vm ? te : t3 ? t3._scope : void 0), (this.vm = t3) && r2 && (t3._watcher = this), o2 ? (this.deep = !!o2.deep, this.user = !!o2.user, this.lazy = !!o2.lazy, this.sync = !!o2.sync, this.before = o2.before) : this.deep = this.user = this.lazy = this.sync = false, this.cb = n22, this.id = ++$n, this.active = true, this.post = false, this.dirty = this.lazy, this.deps = [], this.newDeps = [], this.depIds = new st(), this.newDepIds = new st(), this.expression = "", i(e2) ? this.getter = e2 : (this.getter = function(t42) {
        if (z.test(t42)) return;
        const e3 = t42.split(".");
        return function(t5) {
          for (let n3 = 0; n3 < e3.length; n3++) {
            if (!t5) return;
            t5 = t5[e3[n3]];
          }
          return t5;
        };
      }(e2), this.getter || (this.getter = T)), this.value = this.lazy ? void 0 : this.get();
    }
    get() {
      let t3;
      vt(this);
      const e2 = this.vm;
      try {
        t3 = this.getter.call(e2, e2);
      } catch (t42) {
        if (!this.user) throw t42;
        We(t42, e2, `getter for watcher "${this.expression}"`);
      } finally {
        this.deep && yn(t3), yt(), this.cleanupDeps();
      }
      return t3;
    }
    addDep(t3) {
      const e2 = t3.id;
      this.newDepIds.has(e2) || (this.newDepIds.add(e2), this.newDeps.push(t3), this.depIds.has(e2) || t3.addSub(this));
    }
    cleanupDeps() {
      let t3 = this.deps.length;
      for (; t3--; ) {
        const e3 = this.deps[t3];
        this.newDepIds.has(e3.id) || e3.removeSub(this);
      }
      let e2 = this.depIds;
      this.depIds = this.newDepIds, this.newDepIds = e2, this.newDepIds.clear(), e2 = this.deps, this.deps = this.newDeps, this.newDeps = e2, this.newDeps.length = 0;
    }
    update() {
      this.lazy ? this.dirty = true : this.sync ? this.run() : zn(this);
    }
    run() {
      if (this.active) {
        const t3 = this.get();
        if (t3 !== this.value || c(t3) || this.deep) {
          const e2 = this.value;
          if (this.value = t3, this.user) {
            const n22 = `callback for watcher "${this.expression}"`;
            Ke(this.cb, this.vm, [t3, e2], this.vm, n22);
          } else this.cb.call(this.vm, t3, e2);
        }
      }
    }
    evaluate() {
      this.value = this.get(), this.dirty = false;
    }
    depend() {
      let t3 = this.deps.length;
      for (; t3--; ) this.deps[t3].depend();
    }
    teardown() {
      if (this.vm && !this.vm._isBeingDestroyed && v(this.vm._scope.effects, this), this.active) {
        let t3 = this.deps.length;
        for (; t3--; ) this.deps[t3].removeSub(this);
        this.active = false, this.onStop && this.onStop();
      }
    }
  }
  function Cn(t3, e2) {
    bn.$on(t3, e2);
  }
  function xn(t3, e2) {
    bn.$off(t3, e2);
  }
  function On(t3, e2) {
    const n22 = bn;
    return function o2() {
      null !== e2.apply(null, arguments) && n22.$off(t3, o2);
    };
  }
  function kn(t3, e2, n22) {
    bn = t3, ie(e2, n22 || {}, Cn, xn, On, t3), bn = void 0;
  }
  let Sn = null;
  function jn(t3) {
    const e2 = Sn;
    return Sn = t3, () => {
      Sn = e2;
    };
  }
  function An(t3) {
    for (; t3 && (t3 = t3.$parent); ) if (t3._inactive) return true;
    return false;
  }
  function Tn(t3, e2) {
    if (e2) {
      if (t3._directInactive = false, An(t3)) return;
    } else if (t3._directInactive) return;
    if (t3._inactive || null === t3._inactive) {
      t3._inactive = false;
      for (let e3 = 0; e3 < t3.$children.length; e3++) Tn(t3.$children[e3]);
      Pn(t3, "activated");
    }
  }
  function En(t3, e2) {
    if (!(e2 && (t3._directInactive = true, An(t3)) || t3._inactive)) {
      t3._inactive = true;
      for (let e3 = 0; e3 < t3.$children.length; e3++) En(t3.$children[e3]);
      Pn(t3, "deactivated");
    }
  }
  function Pn(t3, e2, n22, o2 = true) {
    vt();
    const r2 = it, s2 = ne();
    o2 && ct(t3);
    const i2 = t3.$options[e2], c2 = `${e2} hook`;
    if (i2) for (let e3 = 0, o3 = i2.length; e3 < o3; e3++) Ke(i2[e3], t3, null, t3, c2);
    t3._hasHookEvent && t3.$emit("hook:" + e2), o2 && (ct(r2), s2 && s2.on()), yt();
  }
  const In = [], Dn = [];
  let Nn = {}, Mn = false, Ln = false, Rn = 0;
  let Fn = 0, Un = Date.now;
  if (W && !q) {
    const t3 = window.performance;
    t3 && "function" == typeof t3.now && Un() > document.createEvent("Event").timeStamp && (Un = () => t3.now());
  }
  const Bn = (t3, e2) => {
    if (t3.post) {
      if (!e2.post) return 1;
    } else if (e2.post) return -1;
    return t3.id - e2.id;
  };
  function Vn() {
    let t3, e2;
    for (Fn = Un(), Ln = true, In.sort(Bn), Rn = 0; Rn < In.length; Rn++) t3 = In[Rn], t3.before && t3.before(), e2 = t3.id, Nn[e2] = null, t3.run();
    const n22 = Dn.slice(), o2 = In.slice();
    Rn = In.length = Dn.length = 0, Nn = {}, Mn = Ln = false, function(t42) {
      for (let e3 = 0; e3 < t42.length; e3++) t42[e3]._inactive = true, Tn(t42[e3], true);
    }(n22), function(t42) {
      let e3 = t42.length;
      for (; e3--; ) {
        const n3 = t42[e3], o3 = n3.vm;
        o3 && o3._watcher === n3 && o3._isMounted && !o3._isDestroyed && Pn(o3, "updated");
      }
    }(o2), ht();
  }
  function zn(t3) {
    const e2 = t3.id;
    if (null == Nn[e2] && (t3 !== mt.target || !t3.noRecurse)) {
      if (Nn[e2] = true, Ln) {
        let e3 = In.length - 1;
        for (; e3 > Rn && In[e3].id > t3.id; ) e3--;
        In.splice(e3 + 1, 0, t3);
      } else In.push(t3);
      Mn || (Mn = true, tn(Vn));
    }
  }
  function Hn(t3, e2) {
    if (t3) {
      const n22 = /* @__PURE__ */ Object.create(null), o2 = rt ? Reflect.ownKeys(t3) : Object.keys(t3);
      for (let r2 = 0; r2 < o2.length; r2++) {
        const s2 = o2[r2];
        if ("__ob__" === s2) continue;
        const c2 = t3[s2].from;
        if (c2 in e2._provided) n22[s2] = e2._provided[c2];
        else if ("default" in t3[s2]) {
          const o3 = t3[s2].default;
          n22[s2] = i(o3) ? o3.call(e2) : o3;
        }
      }
      return n22;
    }
  }
  function Wn(n22, o2, s2, i2, c2) {
    const a2 = c2.options;
    let l2;
    g(i2, "_uid") ? (l2 = Object.create(i2), l2._original = i2) : (l2 = i2, i2 = i2._original);
    const u22 = r(a2._compiled), f22 = !u22;
    this.data = n22, this.props = o2, this.children = s2, this.parent = i2, this.listeners = n22.on || t2, this.injections = Hn(a2.inject, i2), this.slots = () => (this.$slots || Te(i2, n22.scopedSlots, this.$slots = Se(s2, i2)), this.$slots), Object.defineProperty(this, "scopedSlots", { enumerable: true, get() {
      return Te(i2, n22.scopedSlots, this.slots());
    } }), u22 && (this.$options = a2, this.$slots = this.slots(), this.$scopedSlots = Te(i2, n22.scopedSlots, this.$slots)), a2._scopeId ? this._c = (t3, n3, o3, r2) => {
      const s3 = ze(l2, t3, n3, o3, r2, f22);
      return s3 && !e(s3) && (s3.fnScopeId = a2._scopeId, s3.fnContext = i2), s3;
    } : this._c = (t3, e2, n3, o3) => ze(l2, t3, e2, n3, o3, f22);
  }
  function Kn(t3, e2, n22, o2, r2) {
    const s2 = ft(t3);
    return s2.fnContext = n22, s2.fnOptions = o2, e2.slot && ((s2.data || (s2.data = {})).slot = e2.slot), s2;
  }
  function qn(t3, e2) {
    for (const n22 in e2) t3[w(n22)] = e2[n22];
  }
  function Gn(t3) {
    return t3.name || t3.__name || t3._componentTag;
  }
  ke(Wn.prototype);
  const Zn = { init(t3, e2) {
    if (t3.componentInstance && !t3.componentInstance._isDestroyed && t3.data.keepAlive) {
      const e3 = t3;
      Zn.prepatch(e3, e3);
    } else {
      (t3.componentInstance = function(t42, e3) {
        const n22 = { _isComponent: true, _parentVnode: t42, parent: e3 }, r2 = t42.data.inlineTemplate;
        o(r2) && (n22.render = r2.render, n22.staticRenderFns = r2.staticRenderFns);
        return new t42.componentOptions.Ctor(n22);
      }(t3, Sn)).$mount(e2 ? t3.elm : void 0, e2);
    }
  }, prepatch(e2, n22) {
    const o2 = n22.componentOptions;
    !function(e3, n3, o3, r2, s2) {
      const i2 = r2.data.scopedSlots, c2 = e3.$scopedSlots, a2 = !!(i2 && !i2.$stable || c2 !== t2 && !c2.$stable || i2 && e3.$scopedSlots.$key !== i2.$key || !i2 && e3.$scopedSlots.$key);
      let l2 = !!(s2 || e3.$options._renderChildren || a2);
      const u22 = e3.$vnode;
      e3.$options._parentVnode = r2, e3.$vnode = r2, e3._vnode && (e3._vnode.parent = r2), e3.$options._renderChildren = s2;
      const f22 = r2.data.attrs || t2;
      e3._attrsProxy && De(e3._attrsProxy, f22, u22.data && u22.data.attrs || t2, e3, "$attrs") && (l2 = true), e3.$attrs = f22, o3 = o3 || t2;
      const d2 = e3.$options._parentListeners;
      if (e3._listenersProxy && De(e3._listenersProxy, o3, d2 || t2, e3, "$listeners"), e3.$listeners = e3.$options._parentListeners = o3, kn(e3, o3, d2), n3 && e3.$options.props) {
        xt(false);
        const t3 = e3._props, o4 = e3.$options._propKeys || [];
        for (let r3 = 0; r3 < o4.length; r3++) {
          const s3 = o4[r3], i3 = e3.$options.props;
          t3[s3] = ao(s3, i3, n3, e3);
        }
        xt(true), e3.$options.propsData = n3;
      }
      l2 && (e3.$slots = Se(s2, r2.context), e3.$forceUpdate());
    }(n22.componentInstance = e2.componentInstance, o2.propsData, o2.listeners, n22, o2.children);
  }, insert(t3) {
    const { context: e2, componentInstance: n22 } = t3;
    var o2;
    n22._isMounted || (n22._isMounted = true, Pn(n22, "mounted")), t3.data.keepAlive && (e2._isMounted ? ((o2 = n22)._inactive = false, Dn.push(o2)) : Tn(n22, true));
  }, destroy(t3) {
    const { componentInstance: e2 } = t3;
    e2._isDestroyed || (t3.data.keepAlive ? En(e2, true) : e2.$destroy());
  } }, Jn = Object.keys(Zn);
  function Xn(s2, i2, a2, l2, u22) {
    if (n2(s2)) return;
    const d2 = a2.$options._base;
    if (c(s2) && (s2 = d2.extend(s2)), "function" != typeof s2) return;
    let p2;
    if (n2(s2.cid) && (p2 = s2, s2 = function(t3, e2) {
      if (r(t3.error) && o(t3.errorComp)) return t3.errorComp;
      if (o(t3.resolved)) return t3.resolved;
      const s3 = Re;
      if (s3 && o(t3.owners) && -1 === t3.owners.indexOf(s3) && t3.owners.push(s3), r(t3.loading) && o(t3.loadingComp)) return t3.loadingComp;
      if (s3 && !o(t3.owners)) {
        const r2 = t3.owners = [s3];
        let i3 = true, a3 = null, l3 = null;
        s3.$on("hook:destroyed", () => v(r2, s3));
        const u3 = (t42) => {
          for (let t5 = 0, e3 = r2.length; t5 < e3; t5++) r2[t5].$forceUpdate();
          t42 && (r2.length = 0, null !== a3 && (clearTimeout(a3), a3 = null), null !== l3 && (clearTimeout(l3), l3 = null));
        }, d3 = N((n22) => {
          t3.resolved = Fe(n22, e2), i3 ? r2.length = 0 : u3(true);
        }), p3 = N((e3) => {
          o(t3.errorComp) && (t3.error = true, u3(true));
        }), h3 = t3(d3, p3);
        return c(h3) && (f2(h3) ? n2(t3.resolved) && h3.then(d3, p3) : f2(h3.component) && (h3.component.then(d3, p3), o(h3.error) && (t3.errorComp = Fe(h3.error, e2)), o(h3.loading) && (t3.loadingComp = Fe(h3.loading, e2), 0 === h3.delay ? t3.loading = true : a3 = setTimeout(() => {
          a3 = null, n2(t3.resolved) && n2(t3.error) && (t3.loading = true, u3(false));
        }, h3.delay || 200)), o(h3.timeout) && (l3 = setTimeout(() => {
          l3 = null, n2(t3.resolved) && p3(null);
        }, h3.timeout)))), i3 = false, t3.loading ? t3.loadingComp : t3.resolved;
      }
    }(p2, d2), void 0 === s2)) return function(t3, e2, n22, o2, r2) {
      const s3 = lt();
      return s3.asyncFactory = t3, s3.asyncMeta = { data: e2, context: n22, children: o2, tag: r2 }, s3;
    }(p2, i2, a2, l2, u22);
    i2 = i2 || {}, Co(s2), o(i2.model) && function(t3, n22) {
      const r2 = t3.model && t3.model.prop || "value", s3 = t3.model && t3.model.event || "input";
      (n22.attrs || (n22.attrs = {}))[r2] = n22.model.value;
      const i3 = n22.on || (n22.on = {}), c2 = i3[s3], a3 = n22.model.callback;
      o(c2) ? (e(c2) ? -1 === c2.indexOf(a3) : c2 !== a3) && (i3[s3] = [a3].concat(c2)) : i3[s3] = a3;
    }(s2.options, i2);
    const h2 = function(t3, e2, r2) {
      const s3 = e2.options.props;
      if (n2(s3)) return;
      const i3 = {}, { attrs: c2, props: a3 } = t3;
      if (o(c2) || o(a3)) for (const t42 in s3) {
        const e3 = O(t42);
        ae(i3, a3, t42, e3, true) || ae(i3, c2, t42, e3, false);
      }
      return i3;
    }(i2, s2);
    if (r(s2.options.functional)) return function(n22, r2, s3, i3, c2) {
      const a3 = n22.options, l3 = {}, u3 = a3.props;
      if (o(u3)) for (const e2 in u3) l3[e2] = ao(e2, u3, r2 || t2);
      else o(s3.attrs) && qn(l3, s3.attrs), o(s3.props) && qn(l3, s3.props);
      const f22 = new Wn(s3, l3, c2, i3, n22), d3 = a3.render.call(null, f22._c, f22);
      if (d3 instanceof at) return Kn(d3, s3, f22.parent, a3);
      if (e(d3)) {
        const t3 = le(d3) || [], e2 = new Array(t3.length);
        for (let n3 = 0; n3 < t3.length; n3++) e2[n3] = Kn(t3[n3], s3, f22.parent, a3);
        return e2;
      }
    }(s2, h2, i2, a2, l2);
    const m2 = i2.on;
    if (i2.on = i2.nativeOn, r(s2.options.abstract)) {
      const t3 = i2.slot;
      i2 = {}, t3 && (i2.slot = t3);
    }
    !function(t3) {
      const e2 = t3.hook || (t3.hook = {});
      for (let t42 = 0; t42 < Jn.length; t42++) {
        const n22 = Jn[t42], o2 = e2[n22], r2 = Zn[n22];
        o2 === r2 || o2 && o2._merged || (e2[n22] = o2 ? Qn(r2, o2) : r2);
      }
    }(i2);
    const _22 = Gn(s2.options) || u22;
    return new at(`vue-component-${s2.cid}${_22 ? `-${_22}` : ""}`, i2, void 0, void 0, void 0, a2, { Ctor: s2, propsData: h2, listeners: m2, tag: u22, children: l2 }, p2);
  }
  function Qn(t3, e2) {
    const n22 = (n3, o2) => {
      t3(n3, o2), e2(n3, o2);
    };
    return n22._merged = true, n22;
  }
  let Yn = T;
  const to = U.optionMergeStrategies;
  function eo(t3, e2, n22 = true) {
    if (!e2) return t3;
    let o2, r2, s2;
    const i2 = rt ? Reflect.ownKeys(e2) : Object.keys(e2);
    for (let c2 = 0; c2 < i2.length; c2++) o2 = i2[c2], "__ob__" !== o2 && (r2 = t3[o2], s2 = e2[o2], n22 && g(t3, o2) ? r2 !== s2 && l(r2) && l(s2) && eo(r2, s2) : At(t3, o2, s2));
    return t3;
  }
  function no2(t3, e2, n22) {
    return n22 ? function() {
      const o2 = i(e2) ? e2.call(n22, n22) : e2, r2 = i(t3) ? t3.call(n22, n22) : t3;
      return o2 ? eo(o2, r2) : r2;
    } : e2 ? t3 ? function() {
      return eo(i(e2) ? e2.call(this, this) : e2, i(t3) ? t3.call(this, this) : t3);
    } : e2 : t3;
  }
  function oo(t3, n22) {
    const o2 = n22 ? t3 ? t3.concat(n22) : e(n22) ? n22 : [n22] : t3;
    return o2 ? function(t42) {
      const e2 = [];
      for (let n3 = 0; n3 < t42.length; n3++) -1 === e2.indexOf(t42[n3]) && e2.push(t42[n3]);
      return e2;
    }(o2) : o2;
  }
  function ro(t3, e2, n22, o2) {
    const r2 = Object.create(t3 || null);
    return e2 ? j(r2, e2) : r2;
  }
  to.data = function(t3, e2, n22) {
    return n22 ? no2(t3, e2, n22) : e2 && "function" != typeof e2 ? t3 : no2(t3, e2);
  }, F.forEach((t3) => {
    to[t3] = oo;
  }), R.forEach(function(t3) {
    to[t3 + "s"] = ro;
  }), to.watch = function(t3, n22, o2, r2) {
    if (t3 === Q && (t3 = void 0), n22 === Q && (n22 = void 0), !n22) return Object.create(t3 || null);
    if (!t3) return n22;
    const s2 = {};
    j(s2, t3);
    for (const t42 in n22) {
      let o3 = s2[t42];
      const r3 = n22[t42];
      o3 && !e(o3) && (o3 = [o3]), s2[t42] = o3 ? o3.concat(r3) : e(r3) ? r3 : [r3];
    }
    return s2;
  }, to.props = to.methods = to.inject = to.computed = function(t3, e2, n22, o2) {
    if (!t3) return e2;
    const r2 = /* @__PURE__ */ Object.create(null);
    return j(r2, t3), e2 && j(r2, e2), r2;
  }, to.provide = function(t3, e2) {
    return t3 ? function() {
      const n22 = /* @__PURE__ */ Object.create(null);
      return eo(n22, i(t3) ? t3.call(this) : t3), e2 && eo(n22, i(e2) ? e2.call(this) : e2, false), n22;
    } : e2;
  };
  const so = function(t3, e2) {
    return void 0 === e2 ? t3 : e2;
  };
  function io(t3, n22, o2) {
    if (i(n22) && (n22 = n22.options), function(t42, n3) {
      const o3 = t42.props;
      if (!o3) return;
      const r3 = {};
      let s3, i2, c3;
      if (e(o3)) for (s3 = o3.length; s3--; ) i2 = o3[s3], "string" == typeof i2 && (c3 = w(i2), r3[c3] = { type: null });
      else if (l(o3)) for (const t5 in o3) i2 = o3[t5], c3 = w(t5), r3[c3] = l(i2) ? i2 : { type: i2 };
      t42.props = r3;
    }(n22), function(t42, n3) {
      const o3 = t42.inject;
      if (!o3) return;
      const r3 = t42.inject = {};
      if (e(o3)) for (let t5 = 0; t5 < o3.length; t5++) r3[o3[t5]] = { from: o3[t5] };
      else if (l(o3)) for (const t5 in o3) {
        const e2 = o3[t5];
        r3[t5] = l(e2) ? j({ from: t5 }, e2) : { from: e2 };
      }
    }(n22), function(t42) {
      const e2 = t42.directives;
      if (e2) for (const t5 in e2) {
        const n3 = e2[t5];
        i(n3) && (e2[t5] = { bind: n3, update: n3 });
      }
    }(n22), !n22._base && (n22.extends && (t3 = io(t3, n22.extends, o2)), n22.mixins)) for (let e2 = 0, r3 = n22.mixins.length; e2 < r3; e2++) t3 = io(t3, n22.mixins[e2], o2);
    const r2 = {};
    let s2;
    for (s2 in t3) c2(s2);
    for (s2 in n22) g(t3, s2) || c2(s2);
    function c2(e2) {
      const s3 = to[e2] || so;
      r2[e2] = s3(t3[e2], n22[e2], o2, e2);
    }
    return r2;
  }
  function co(t3, e2, n22, o2) {
    if ("string" != typeof n22) return;
    const r2 = t3[e2];
    if (g(r2, n22)) return r2[n22];
    const s2 = w(n22);
    if (g(r2, s2)) return r2[s2];
    const i2 = C(s2);
    if (g(r2, i2)) return r2[i2];
    return r2[n22] || r2[s2] || r2[i2];
  }
  function ao(t3, e2, n22, o2) {
    const r2 = e2[t3], s2 = !g(n22, t3);
    let c2 = n22[t3];
    const a2 = po(Boolean, r2.type);
    if (a2 > -1) {
      if (s2 && !g(r2, "default")) c2 = false;
      else if ("" === c2 || c2 === O(t3)) {
        const t42 = po(String, r2.type);
        (t42 < 0 || a2 < t42) && (c2 = true);
      }
    }
    if (void 0 === c2) {
      c2 = function(t42, e4, n3) {
        if (!g(e4, "default")) return;
        const o3 = e4.default;
        if (t42 && t42.$options.propsData && void 0 === t42.$options.propsData[n3] && void 0 !== t42._props[n3]) return t42._props[n3];
        return i(o3) && "Function" !== uo(e4.type) ? o3.call(t42) : o3;
      }(o2, r2, t3);
      const e3 = Ct;
      xt(true), St(c2), xt(e3);
    }
    return c2;
  }
  const lo = /^\s*function (\w+)/;
  function uo(t3) {
    const e2 = t3 && t3.toString().match(lo);
    return e2 ? e2[1] : "";
  }
  function fo(t3, e2) {
    return uo(t3) === uo(e2);
  }
  function po(t3, n22) {
    if (!e(n22)) return fo(n22, t3) ? 0 : -1;
    for (let e2 = 0, o2 = n22.length; e2 < o2; e2++) if (fo(n22[e2], t3)) return e2;
    return -1;
  }
  const ho = { enumerable: true, configurable: true, get: T, set: T };
  function mo(t3, e2, n22) {
    ho.get = function() {
      return this[e2][n22];
    }, ho.set = function(t42) {
      this[e2][n22] = t42;
    }, Object.defineProperty(t3, n22, ho);
  }
  function _o(t3) {
    const n22 = t3.$options;
    if (n22.props && function(t42, e2) {
      const n3 = t42.$options.propsData || {}, o2 = t42._props = Pt({}), r2 = t42.$options._propKeys = [], s2 = !t42.$parent;
      s2 || xt(false);
      for (const s3 in e2) {
        r2.push(s3);
        jt(o2, s3, ao(s3, e2, n3, t42), void 0, true), s3 in t42 || mo(t42, "_props", s3);
      }
      xt(true);
    }(t3, n22.props), function(t42) {
      const e2 = t42.$options, n3 = e2.setup;
      if (n3) {
        const o2 = t42._setupContext = Ie(t42);
        ct(t42), vt();
        const r2 = Ke(n3, null, [t42._props || Pt({}), o2], t42, "setup");
        if (yt(), ct(), i(r2)) e2.render = r2;
        else if (c(r2)) if (t42._setupState = r2, r2.__sfc) {
          const e3 = t42._setupProxy = {};
          for (const t5 in r2) "__sfc" !== t5 && Ut(e3, r2, t5);
        } else for (const e3 in r2) B(e3) || Ut(t42, r2, e3);
      }
    }(t3), n22.methods && function(t42, e2) {
      t42.$options.props;
      for (const n3 in e2) t42[n3] = "function" != typeof e2[n3] ? T : k(e2[n3], t42);
    }(t3, n22.methods), n22.data) !function(t42) {
      let e2 = t42.$options.data;
      e2 = t42._data = i(e2) ? function(t5, e3) {
        vt();
        try {
          return t5.call(e3, e3);
        } catch (t6) {
          return We(t6, e3, "data()"), {};
        } finally {
          yt();
        }
      }(e2, t42) : e2 || {}, l(e2) || (e2 = {});
      const n3 = Object.keys(e2), o2 = t42.$options.props;
      t42.$options.methods;
      let r2 = n3.length;
      for (; r2--; ) {
        const e3 = n3[r2];
        o2 && g(o2, e3) || B(e3) || mo(t42, "_data", e3);
      }
      const s2 = St(e2);
      s2 && s2.vmCount++;
    }(t3);
    else {
      const e2 = St(t3._data = {});
      e2 && e2.vmCount++;
    }
    n22.computed && function(t42, e2) {
      const n3 = t42._computedWatchers = /* @__PURE__ */ Object.create(null), o2 = et();
      for (const r2 in e2) {
        const s2 = e2[r2], c2 = i(s2) ? s2 : s2.get;
        o2 || (n3[r2] = new wn(t42, c2 || T, T, vo)), r2 in t42 || yo(t42, r2, s2);
      }
    }(t3, n22.computed), n22.watch && n22.watch !== Q && function(t42, n3) {
      for (const o2 in n3) {
        const r2 = n3[o2];
        if (e(r2)) for (let e2 = 0; e2 < r2.length; e2++) $o(t42, o2, r2[e2]);
        else $o(t42, o2, r2);
      }
    }(t3, n22.watch);
  }
  const vo = { lazy: true };
  function yo(t3, e2, n22) {
    const o2 = !et();
    i(n22) ? (ho.get = o2 ? go(e2) : bo(n22), ho.set = T) : (ho.get = n22.get ? o2 && false !== n22.cache ? go(e2) : bo(n22.get) : T, ho.set = n22.set || T), Object.defineProperty(t3, e2, ho);
  }
  function go(t3) {
    return function() {
      const e2 = this._computedWatchers && this._computedWatchers[t3];
      if (e2) return e2.dirty && e2.evaluate(), mt.target && e2.depend(), e2.value;
    };
  }
  function bo(t3) {
    return function() {
      return t3.call(this, this);
    };
  }
  function $o(t3, e2, n22, o2) {
    return l(n22) && (o2 = n22, n22 = n22.handler), "string" == typeof n22 && (n22 = t3[n22]), t3.$watch(e2, n22, o2);
  }
  let wo = 0;
  function Co(t3) {
    let e2 = t3.options;
    if (t3.super) {
      const n22 = Co(t3.super);
      if (n22 !== t3.superOptions) {
        t3.superOptions = n22;
        const o2 = function(t42) {
          let e3;
          const n3 = t42.options, o3 = t42.sealedOptions;
          for (const t5 in n3) n3[t5] !== o3[t5] && (e3 || (e3 = {}), e3[t5] = n3[t5]);
          return e3;
        }(t3);
        o2 && j(t3.extendOptions, o2), e2 = t3.options = io(n22, t3.extendOptions), e2.name && (e2.components[e2.name] = t3);
      }
    }
    return e2;
  }
  function xo(t3) {
    this._init(t3);
  }
  function Oo(t3) {
    t3.cid = 0;
    let e2 = 1;
    t3.extend = function(t42) {
      t42 = t42 || {};
      const n22 = this, o2 = n22.cid, r2 = t42._Ctor || (t42._Ctor = {});
      if (r2[o2]) return r2[o2];
      const s2 = Gn(t42) || Gn(n22.options), i2 = function(t5) {
        this._init(t5);
      };
      return (i2.prototype = Object.create(n22.prototype)).constructor = i2, i2.cid = e2++, i2.options = io(n22.options, t42), i2.super = n22, i2.options.props && function(t5) {
        const e3 = t5.options.props;
        for (const n3 in e3) mo(t5.prototype, "_props", n3);
      }(i2), i2.options.computed && function(t5) {
        const e3 = t5.options.computed;
        for (const n3 in e3) yo(t5.prototype, n3, e3[n3]);
      }(i2), i2.extend = n22.extend, i2.mixin = n22.mixin, i2.use = n22.use, R.forEach(function(t5) {
        i2[t5] = n22[t5];
      }), s2 && (i2.options.components[s2] = i2), i2.superOptions = n22.options, i2.extendOptions = t42, i2.sealedOptions = j({}, i2.options), r2[o2] = i2, i2;
    };
  }
  function ko(t3) {
    return t3 && (Gn(t3.Ctor.options) || t3.tag);
  }
  function So(t3, n22) {
    return e(t3) ? t3.indexOf(n22) > -1 : "string" == typeof t3 ? t3.split(",").indexOf(n22) > -1 : (o2 = t3, "[object RegExp]" === a.call(o2) && t3.test(n22));
    var o2;
  }
  function jo(t3, e2) {
    const { cache: n22, keys: o2, _vnode: r2, $vnode: s2 } = t3;
    for (const t42 in n22) {
      const s3 = n22[t42];
      if (s3) {
        const i2 = s3.name;
        i2 && !e2(i2) && Ao(n22, t42, o2, r2);
      }
    }
    s2.componentOptions.children = void 0;
  }
  function Ao(t3, e2, n22, o2) {
    const r2 = t3[e2];
    !r2 || o2 && r2.tag === o2.tag || r2.componentInstance.$destroy(), t3[e2] = null, v(n22, e2);
  }
  !function(e2) {
    e2.prototype._init = function(e3) {
      const n22 = this;
      n22._uid = wo++, n22._isVue = true, n22.__v_skip = true, n22._scope = new ee(true), n22._scope.parent = void 0, n22._scope._vm = true, e3 && e3._isComponent ? function(t3, e4) {
        const n3 = t3.$options = Object.create(t3.constructor.options), o2 = e4._parentVnode;
        n3.parent = e4.parent, n3._parentVnode = o2;
        const r2 = o2.componentOptions;
        n3.propsData = r2.propsData, n3._parentListeners = r2.listeners, n3._renderChildren = r2.children, n3._componentTag = r2.tag, e4.render && (n3.render = e4.render, n3.staticRenderFns = e4.staticRenderFns);
      }(n22, e3) : n22.$options = io(Co(n22.constructor), e3 || {}, n22), n22._renderProxy = n22, n22._self = n22, function(t3) {
        const e4 = t3.$options;
        let n3 = e4.parent;
        if (n3 && !e4.abstract) {
          for (; n3.$options.abstract && n3.$parent; ) n3 = n3.$parent;
          n3.$children.push(t3);
        }
        t3.$parent = n3, t3.$root = n3 ? n3.$root : t3, t3.$children = [], t3.$refs = {}, t3._provided = n3 ? n3._provided : /* @__PURE__ */ Object.create(null), t3._watcher = null, t3._inactive = null, t3._directInactive = false, t3._isMounted = false, t3._isDestroyed = false, t3._isBeingDestroyed = false;
      }(n22), function(t3) {
        t3._events = /* @__PURE__ */ Object.create(null), t3._hasHookEvent = false;
        const e4 = t3.$options._parentListeners;
        e4 && kn(t3, e4);
      }(n22), function(e4) {
        e4._vnode = null, e4._staticTrees = null;
        const n3 = e4.$options, o2 = e4.$vnode = n3._parentVnode, r2 = o2 && o2.context;
        e4.$slots = Se(n3._renderChildren, r2), e4.$scopedSlots = o2 ? Te(e4.$parent, o2.data.scopedSlots, e4.$slots) : t2, e4._c = (t3, n4, o3, r3) => ze(e4, t3, n4, o3, r3, false), e4.$createElement = (t3, n4, o3, r3) => ze(e4, t3, n4, o3, r3, true);
        const s2 = o2 && o2.data;
        jt(e4, "$attrs", s2 && s2.attrs || t2, null, true), jt(e4, "$listeners", n3._parentListeners || t2, null, true);
      }(n22), Pn(n22, "beforeCreate", void 0, false), function(t3) {
        const e4 = Hn(t3.$options.inject, t3);
        e4 && (xt(false), Object.keys(e4).forEach((n3) => {
          jt(t3, n3, e4[n3]);
        }), xt(true));
      }(n22), _o(n22), function(t3) {
        const e4 = t3.$options.provide;
        if (e4) {
          const n3 = i(e4) ? e4.call(t3) : e4;
          if (!c(n3)) return;
          const o2 = oe(t3), r2 = rt ? Reflect.ownKeys(n3) : Object.keys(n3);
          for (let t42 = 0; t42 < r2.length; t42++) {
            const e5 = r2[t42];
            Object.defineProperty(o2, e5, Object.getOwnPropertyDescriptor(n3, e5));
          }
        }
      }(n22), Pn(n22, "created"), n22.$options.el && n22.$mount(n22.$options.el);
    };
  }(xo), function(t3) {
    const e2 = { get: function() {
      return this._data;
    } }, n22 = { get: function() {
      return this._props;
    } };
    Object.defineProperty(t3.prototype, "$data", e2), Object.defineProperty(t3.prototype, "$props", n22), t3.prototype.$set = At, t3.prototype.$delete = Tt, t3.prototype.$watch = function(t42, e3, n3) {
      const o2 = this;
      if (l(e3)) return $o(o2, t42, e3, n3);
      (n3 = n3 || {}).user = true;
      const r2 = new wn(o2, t42, e3, n3);
      if (n3.immediate) {
        const t5 = `callback for immediate watcher "${r2.expression}"`;
        vt(), Ke(e3, o2, [r2.value], o2, t5), yt();
      }
      return function() {
        r2.teardown();
      };
    };
  }(xo), function(t3) {
    const n22 = /^hook:/;
    t3.prototype.$on = function(t42, o2) {
      const r2 = this;
      if (e(t42)) for (let e2 = 0, n3 = t42.length; e2 < n3; e2++) r2.$on(t42[e2], o2);
      else (r2._events[t42] || (r2._events[t42] = [])).push(o2), n22.test(t42) && (r2._hasHookEvent = true);
      return r2;
    }, t3.prototype.$once = function(t42, e2) {
      const n3 = this;
      function o2() {
        n3.$off(t42, o2), e2.apply(n3, arguments);
      }
      return o2.fn = e2, n3.$on(t42, o2), n3;
    }, t3.prototype.$off = function(t42, n3) {
      const o2 = this;
      if (!arguments.length) return o2._events = /* @__PURE__ */ Object.create(null), o2;
      if (e(t42)) {
        for (let e2 = 0, r3 = t42.length; e2 < r3; e2++) o2.$off(t42[e2], n3);
        return o2;
      }
      const r2 = o2._events[t42];
      if (!r2) return o2;
      if (!n3) return o2._events[t42] = null, o2;
      let s2, i2 = r2.length;
      for (; i2--; ) if (s2 = r2[i2], s2 === n3 || s2.fn === n3) {
        r2.splice(i2, 1);
        break;
      }
      return o2;
    }, t3.prototype.$emit = function(t42) {
      const e2 = this;
      let n3 = e2._events[t42];
      if (n3) {
        n3 = n3.length > 1 ? S(n3) : n3;
        const o2 = S(arguments, 1), r2 = `event handler for "${t42}"`;
        for (let t5 = 0, s2 = n3.length; t5 < s2; t5++) Ke(n3[t5], e2, o2, e2, r2);
      }
      return e2;
    };
  }(xo), function(t3) {
    t3.prototype._update = function(t42, e2) {
      const n22 = this, o2 = n22.$el, r2 = n22._vnode, s2 = jn(n22);
      n22._vnode = t42, n22.$el = r2 ? n22.__patch__(r2, t42) : n22.__patch__(n22.$el, t42, e2, false), s2(), o2 && (o2.__vue__ = null), n22.$el && (n22.$el.__vue__ = n22);
      let i2 = n22;
      for (; i2 && i2.$vnode && i2.$parent && i2.$vnode === i2.$parent._vnode; ) i2.$parent.$el = i2.$el, i2 = i2.$parent;
    }, t3.prototype.$forceUpdate = function() {
      const t42 = this;
      t42._watcher && t42._watcher.update();
    }, t3.prototype.$destroy = function() {
      const t42 = this;
      if (t42._isBeingDestroyed) return;
      Pn(t42, "beforeDestroy"), t42._isBeingDestroyed = true;
      const e2 = t42.$parent;
      !e2 || e2._isBeingDestroyed || t42.$options.abstract || v(e2.$children, t42), t42._scope.stop(), t42._data.__ob__ && t42._data.__ob__.vmCount--, t42._isDestroyed = true, t42.__patch__(t42._vnode, null), Pn(t42, "destroyed"), t42.$off(), t42.$el && (t42.$el.__vue__ = null), t42.$vnode && (t42.$vnode.parent = null);
    };
  }(xo), function(t3) {
    ke(t3.prototype), t3.prototype.$nextTick = function(t42) {
      return tn(t42, this);
    }, t3.prototype._render = function() {
      const t42 = this, { render: n22, _parentVnode: o2 } = t42.$options;
      o2 && t42._isMounted && (t42.$scopedSlots = Te(t42.$parent, o2.data.scopedSlots, t42.$slots, t42.$scopedSlots), t42._slotsProxy && Me(t42._slotsProxy, t42.$scopedSlots)), t42.$vnode = o2;
      const r2 = it, s2 = Re;
      let i2;
      try {
        ct(t42), Re = t42, i2 = n22.call(t42._renderProxy, t42.$createElement);
      } catch (e2) {
        We(e2, t42, "render"), i2 = t42._vnode;
      } finally {
        Re = s2, ct(r2);
      }
      return e(i2) && 1 === i2.length && (i2 = i2[0]), i2 instanceof at || (i2 = lt()), i2.parent = o2, i2;
    };
  }(xo);
  const To = [String, RegExp, Array];
  var Eo = { KeepAlive: { name: "keep-alive", abstract: true, props: { include: To, exclude: To, max: [String, Number] }, methods: { cacheVNode() {
    const { cache: t3, keys: e2, vnodeToCache: n22, keyToCache: o2 } = this;
    if (n22) {
      const { tag: r2, componentInstance: s2, componentOptions: i2 } = n22;
      t3[o2] = { name: ko(i2), tag: r2, componentInstance: s2 }, e2.push(o2), this.max && e2.length > parseInt(this.max) && Ao(t3, e2[0], e2, this._vnode), this.vnodeToCache = null;
    }
  } }, created() {
    this.cache = /* @__PURE__ */ Object.create(null), this.keys = [];
  }, destroyed() {
    for (const t3 in this.cache) Ao(this.cache, t3, this.keys);
  }, mounted() {
    this.cacheVNode(), this.$watch("include", (t3) => {
      jo(this, (e2) => So(t3, e2));
    }), this.$watch("exclude", (t3) => {
      jo(this, (e2) => !So(t3, e2));
    });
  }, updated() {
    this.cacheVNode();
  }, render() {
    const t3 = this.$slots.default, e2 = Ue(t3), n22 = e2 && e2.componentOptions;
    if (n22) {
      const t42 = ko(n22), { include: o2, exclude: r2 } = this;
      if (o2 && (!t42 || !So(o2, t42)) || r2 && t42 && So(r2, t42)) return e2;
      const { cache: s2, keys: i2 } = this, c2 = null == e2.key ? n22.Ctor.cid + (n22.tag ? `::${n22.tag}` : "") : e2.key;
      s2[c2] ? (e2.componentInstance = s2[c2].componentInstance, v(i2, c2), i2.push(c2)) : (this.vnodeToCache = e2, this.keyToCache = c2), e2.data.keepAlive = true;
    }
    return e2 || t3 && t3[0];
  } } };
  !function(t3) {
    const e2 = { get: () => U };
    Object.defineProperty(t3, "config", e2), t3.util = { warn: Yn, extend: j, mergeOptions: io, defineReactive: jt }, t3.set = At, t3.delete = Tt, t3.nextTick = tn, t3.observable = (t42) => (St(t42), t42), t3.options = /* @__PURE__ */ Object.create(null), R.forEach((e3) => {
      t3.options[e3 + "s"] = /* @__PURE__ */ Object.create(null);
    }), t3.options._base = t3, j(t3.options.components, Eo), function(t42) {
      t42.use = function(t5) {
        const e3 = this._installedPlugins || (this._installedPlugins = []);
        if (e3.indexOf(t5) > -1) return this;
        const n22 = S(arguments, 1);
        return n22.unshift(this), i(t5.install) ? t5.install.apply(t5, n22) : i(t5) && t5.apply(null, n22), e3.push(t5), this;
      };
    }(t3), function(t42) {
      t42.mixin = function(t5) {
        return this.options = io(this.options, t5), this;
      };
    }(t3), Oo(t3), function(t42) {
      R.forEach((e3) => {
        t42[e3] = function(t5, n22) {
          return n22 ? ("component" === e3 && l(n22) && (n22.name = n22.name || t5, n22 = this.options._base.extend(n22)), "directive" === e3 && i(n22) && (n22 = { bind: n22, update: n22 }), this.options[e3 + "s"][t5] = n22, n22) : this.options[e3 + "s"][t5];
        };
      });
    }(t3);
  }(xo), Object.defineProperty(xo.prototype, "$isServer", { get: et }), Object.defineProperty(xo.prototype, "$ssrContext", { get() {
    return this.$vnode && this.$vnode.ssrContext;
  } }), Object.defineProperty(xo, "FunctionalRenderContext", { value: Wn }), xo.version = mn;
  const Po = m("style,class"), Io = m("input,textarea,option,select,progress"), Do = m("contenteditable,draggable,spellcheck"), No = m("events,caret,typing,plaintext-only"), Mo = (t3, e2) => Bo(e2) || "false" === e2 ? "false" : "contenteditable" === t3 && No(e2) ? e2 : "true", Lo = m("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"), Ro = "http://www.w3.org/1999/xlink", Fo = (t3) => ":" === t3.charAt(5) && "xlink" === t3.slice(0, 5), Uo = (t3) => Fo(t3) ? t3.slice(6, t3.length) : "", Bo = (t3) => null == t3 || false === t3;
  function Vo(t3) {
    let e2 = t3.data, n22 = t3, r2 = t3;
    for (; o(r2.componentInstance); ) r2 = r2.componentInstance._vnode, r2 && r2.data && (e2 = zo(r2.data, e2));
    for (; o(n22 = n22.parent); ) n22 && n22.data && (e2 = zo(e2, n22.data));
    return function(t42, e3) {
      if (o(t42) || o(e3)) return Ho(t42, Wo(e3));
      return "";
    }(e2.staticClass, e2.class);
  }
  function zo(t3, e2) {
    return { staticClass: Ho(t3.staticClass, e2.staticClass), class: o(t3.class) ? [t3.class, e2.class] : e2.class };
  }
  function Ho(t3, e2) {
    return t3 ? e2 ? t3 + " " + e2 : t3 : e2 || "";
  }
  function Wo(t3) {
    return Array.isArray(t3) ? function(t42) {
      let e2, n22 = "";
      for (let r2 = 0, s2 = t42.length; r2 < s2; r2++) o(e2 = Wo(t42[r2])) && "" !== e2 && (n22 && (n22 += " "), n22 += e2);
      return n22;
    }(t3) : c(t3) ? function(t42) {
      let e2 = "";
      for (const n22 in t42) t42[n22] && (e2 && (e2 += " "), e2 += n22);
      return e2;
    }(t3) : "string" == typeof t3 ? t3 : "";
  }
  const Ko = { svg: "http://www.w3.org/2000/svg", math: "http://www.w3.org/1998/Math/MathML" }, qo = m("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"), Go = m("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", true), Zo = (t3) => qo(t3) || Go(t3);
  const Jo = /* @__PURE__ */ Object.create(null);
  const Xo = m("text,number,password,search,email,tel,url");
  var Qo = Object.freeze({ __proto__: null, createElement: function(t3, e2) {
    const n22 = document.createElement(t3);
    return "select" !== t3 || e2.data && e2.data.attrs && void 0 !== e2.data.attrs.multiple && n22.setAttribute("multiple", "multiple"), n22;
  }, createElementNS: function(t3, e2) {
    return document.createElementNS(Ko[t3], e2);
  }, createTextNode: function(t3) {
    return document.createTextNode(t3);
  }, createComment: function(t3) {
    return document.createComment(t3);
  }, insertBefore: function(t3, e2, n22) {
    t3.insertBefore(e2, n22);
  }, removeChild: function(t3, e2) {
    t3.removeChild(e2);
  }, appendChild: function(t3, e2) {
    t3.appendChild(e2);
  }, parentNode: function(t3) {
    return t3.parentNode;
  }, nextSibling: function(t3) {
    return t3.nextSibling;
  }, tagName: function(t3) {
    return t3.tagName;
  }, setTextContent: function(t3, e2) {
    t3.textContent = e2;
  }, setStyleScope: function(t3, e2) {
    t3.setAttribute(e2, "");
  } }), Yo = { create(t3, e2) {
    tr(e2);
  }, update(t3, e2) {
    t3.data.ref !== e2.data.ref && (tr(t3, true), tr(e2));
  }, destroy(t3) {
    tr(t3, true);
  } };
  function tr(t3, n22) {
    const r2 = t3.data.ref;
    if (!o(r2)) return;
    const s2 = t3.context, c2 = t3.componentInstance || t3.elm, a2 = n22 ? null : c2, l2 = n22 ? void 0 : c2;
    if (i(r2)) return void Ke(r2, s2, [a2], s2, "template ref function");
    const u22 = t3.data.refInFor, f22 = "string" == typeof r2 || "number" == typeof r2, d2 = Rt(r2), p2 = s2.$refs;
    if (f22 || d2) {
      if (u22) {
        const t42 = f22 ? p2[r2] : r2.value;
        n22 ? e(t42) && v(t42, c2) : e(t42) ? t42.includes(c2) || t42.push(c2) : f22 ? (p2[r2] = [c2], er(s2, r2, p2[r2])) : r2.value = [c2];
      } else if (f22) {
        if (n22 && p2[r2] !== c2) return;
        p2[r2] = l2, er(s2, r2, a2);
      } else if (d2) {
        if (n22 && r2.value !== c2) return;
        r2.value = a2;
      }
    }
  }
  function er({ _setupState: t3 }, e2, n22) {
    t3 && g(t3, e2) && (Rt(t3[e2]) ? t3[e2].value = n22 : t3[e2] = n22);
  }
  const nr = new at("", {}, []), or = ["create", "activate", "update", "remove", "destroy"];
  function rr(t3, e2) {
    return t3.key === e2.key && t3.asyncFactory === e2.asyncFactory && (t3.tag === e2.tag && t3.isComment === e2.isComment && o(t3.data) === o(e2.data) && function(t42, e3) {
      if ("input" !== t42.tag) return true;
      let n22;
      const r2 = o(n22 = t42.data) && o(n22 = n22.attrs) && n22.type, s2 = o(n22 = e3.data) && o(n22 = n22.attrs) && n22.type;
      return r2 === s2 || Xo(r2) && Xo(s2);
    }(t3, e2) || r(t3.isAsyncPlaceholder) && n2(e2.asyncFactory.error));
  }
  function sr(t3, e2, n22) {
    let r2, s2;
    const i2 = {};
    for (r2 = e2; r2 <= n22; ++r2) s2 = t3[r2].key, o(s2) && (i2[s2] = r2);
    return i2;
  }
  var ir = { create: cr, update: cr, destroy: function(t3) {
    cr(t3, nr);
  } };
  function cr(t3, e2) {
    (t3.data.directives || e2.data.directives) && function(t42, e3) {
      const n22 = t42 === nr, o2 = e3 === nr, r2 = lr(t42.data.directives, t42.context), s2 = lr(e3.data.directives, e3.context), i2 = [], c2 = [];
      let a2, l2, u22;
      for (a2 in s2) l2 = r2[a2], u22 = s2[a2], l2 ? (u22.oldValue = l2.value, u22.oldArg = l2.arg, fr(u22, "update", e3, t42), u22.def && u22.def.componentUpdated && c2.push(u22)) : (fr(u22, "bind", e3, t42), u22.def && u22.def.inserted && i2.push(u22));
      if (i2.length) {
        const o3 = () => {
          for (let n3 = 0; n3 < i2.length; n3++) fr(i2[n3], "inserted", e3, t42);
        };
        n22 ? ce(e3, "insert", o3) : o3();
      }
      c2.length && ce(e3, "postpatch", () => {
        for (let n3 = 0; n3 < c2.length; n3++) fr(c2[n3], "componentUpdated", e3, t42);
      });
      if (!n22) for (a2 in r2) s2[a2] || fr(r2[a2], "unbind", t42, t42, o2);
    }(t3, e2);
  }
  const ar = /* @__PURE__ */ Object.create(null);
  function lr(t3, e2) {
    const n22 = /* @__PURE__ */ Object.create(null);
    if (!t3) return n22;
    let o2, r2;
    for (o2 = 0; o2 < t3.length; o2++) {
      if (r2 = t3[o2], r2.modifiers || (r2.modifiers = ar), n22[ur(r2)] = r2, e2._setupState && e2._setupState.__sfc) {
        const t42 = r2.def || co(e2, "_setupState", "v-" + r2.name);
        r2.def = "function" == typeof t42 ? { bind: t42, update: t42 } : t42;
      }
      r2.def = r2.def || co(e2.$options, "directives", r2.name);
    }
    return n22;
  }
  function ur(t3) {
    return t3.rawName || `${t3.name}.${Object.keys(t3.modifiers || {}).join(".")}`;
  }
  function fr(t3, e2, n22, o2, r2) {
    const s2 = t3.def && t3.def[e2];
    if (s2) try {
      s2(n22.elm, t3, n22, o2, r2);
    } catch (o3) {
      We(o3, n22.context, `directive ${t3.name} ${e2} hook`);
    }
  }
  var dr = [Yo, ir];
  function pr(t3, e2) {
    const s2 = e2.componentOptions;
    if (o(s2) && false === s2.Ctor.options.inheritAttrs) return;
    if (n2(t3.data.attrs) && n2(e2.data.attrs)) return;
    let i2, c2, a2;
    const l2 = e2.elm, u22 = t3.data.attrs || {};
    let f22 = e2.data.attrs || {};
    for (i2 in (o(f22.__ob__) || r(f22._v_attr_proxy)) && (f22 = e2.data.attrs = j({}, f22)), f22) c2 = f22[i2], a2 = u22[i2], a2 !== c2 && hr(l2, i2, c2, e2.data.pre);
    for (i2 in (q || Z) && f22.value !== u22.value && hr(l2, "value", f22.value), u22) n2(f22[i2]) && (Fo(i2) ? l2.removeAttributeNS(Ro, Uo(i2)) : Do(i2) || l2.removeAttribute(i2));
  }
  function hr(t3, e2, n22, o2) {
    o2 || t3.tagName.indexOf("-") > -1 ? mr(t3, e2, n22) : Lo(e2) ? Bo(n22) ? t3.removeAttribute(e2) : (n22 = "allowfullscreen" === e2 && "EMBED" === t3.tagName ? "true" : e2, t3.setAttribute(e2, n22)) : Do(e2) ? t3.setAttribute(e2, Mo(e2, n22)) : Fo(e2) ? Bo(n22) ? t3.removeAttributeNS(Ro, Uo(e2)) : t3.setAttributeNS(Ro, e2, n22) : mr(t3, e2, n22);
  }
  function mr(t3, e2, n22) {
    if (Bo(n22)) t3.removeAttribute(e2);
    else {
      if (q && !G && "TEXTAREA" === t3.tagName && "placeholder" === e2 && "" !== n22 && !t3.__ieph) {
        const e3 = (n3) => {
          n3.stopImmediatePropagation(), t3.removeEventListener("input", e3);
        };
        t3.addEventListener("input", e3), t3.__ieph = true;
      }
      t3.setAttribute(e2, n22);
    }
  }
  var _r = { create: pr, update: pr };
  function vr(t3, e2) {
    const r2 = e2.elm, s2 = e2.data, i2 = t3.data;
    if (n2(s2.staticClass) && n2(s2.class) && (n2(i2) || n2(i2.staticClass) && n2(i2.class))) return;
    let c2 = Vo(e2);
    const a2 = r2._transitionClasses;
    o(a2) && (c2 = Ho(c2, Wo(a2))), c2 !== r2._prevClass && (r2.setAttribute("class", c2), r2._prevClass = c2);
  }
  var yr = { create: vr, update: vr };
  const gr = "__r", br = "__c";
  let $r;
  function wr(t3, e2, n22) {
    const o2 = $r;
    return function r2() {
      null !== e2.apply(null, arguments) && Or(t3, r2, n22, o2);
    };
  }
  const Cr = Ze && !(X && Number(X[1]) <= 53);
  function xr(t3, e2, n22, o2) {
    if (Cr) {
      const t42 = Fn, n3 = e2;
      e2 = n3._wrapper = function(e3) {
        if (e3.target === e3.currentTarget || e3.timeStamp >= t42 || e3.timeStamp <= 0 || e3.target.ownerDocument !== document) return n3.apply(this, arguments);
      };
    }
    $r.addEventListener(t3, e2, tt ? { capture: n22, passive: o2 } : n22);
  }
  function Or(t3, e2, n22, o2) {
    (o2 || $r).removeEventListener(t3, e2._wrapper || e2, n22);
  }
  function kr(t3, e2) {
    if (n2(t3.data.on) && n2(e2.data.on)) return;
    const r2 = e2.data.on || {}, s2 = t3.data.on || {};
    $r = e2.elm || t3.elm, function(t42) {
      if (o(t42[gr])) {
        const e3 = q ? "change" : "input";
        t42[e3] = [].concat(t42[gr], t42[e3] || []), delete t42[gr];
      }
      o(t42[br]) && (t42.change = [].concat(t42[br], t42.change || []), delete t42[br]);
    }(r2), ie(r2, s2, xr, Or, wr, e2.context), $r = void 0;
  }
  var Sr = { create: kr, update: kr, destroy: (t3) => kr(t3, nr) };
  let jr;
  function Ar(t3, e2) {
    if (n2(t3.data.domProps) && n2(e2.data.domProps)) return;
    let s2, i2;
    const c2 = e2.elm, a2 = t3.data.domProps || {};
    let l2 = e2.data.domProps || {};
    for (s2 in (o(l2.__ob__) || r(l2._v_attr_proxy)) && (l2 = e2.data.domProps = j({}, l2)), a2) s2 in l2 || (c2[s2] = "");
    for (s2 in l2) {
      if (i2 = l2[s2], "textContent" === s2 || "innerHTML" === s2) {
        if (e2.children && (e2.children.length = 0), i2 === a2[s2]) continue;
        1 === c2.childNodes.length && c2.removeChild(c2.childNodes[0]);
      }
      if ("value" === s2 && "PROGRESS" !== c2.tagName) {
        c2._value = i2;
        const t42 = n2(i2) ? "" : String(i2);
        Tr(c2, t42) && (c2.value = t42);
      } else if ("innerHTML" === s2 && Go(c2.tagName) && n2(c2.innerHTML)) {
        jr = jr || document.createElement("div"), jr.innerHTML = `<svg>${i2}</svg>`;
        const t42 = jr.firstChild;
        for (; c2.firstChild; ) c2.removeChild(c2.firstChild);
        for (; t42.firstChild; ) c2.appendChild(t42.firstChild);
      } else if (i2 !== a2[s2]) try {
        c2[s2] = i2;
      } catch (t42) {
      }
    }
  }
  function Tr(t3, e2) {
    return !t3.composing && ("OPTION" === t3.tagName || function(t42, e3) {
      let n22 = true;
      try {
        n22 = document.activeElement !== t42;
      } catch (t5) {
      }
      return n22 && t42.value !== e3;
    }(t3, e2) || function(t42, e3) {
      const n22 = t42.value, r2 = t42._vModifiers;
      if (o(r2)) {
        if (r2.number) return h(n22) !== h(e3);
        if (r2.trim) return n22.trim() !== e3.trim();
      }
      return n22 !== e3;
    }(t3, e2));
  }
  var Er = { create: Ar, update: Ar };
  const Pr = b(function(t3) {
    const e2 = {}, n22 = /:(.+)/;
    return t3.split(/;(?![^(]*\))/g).forEach(function(t42) {
      if (t42) {
        const o2 = t42.split(n22);
        o2.length > 1 && (e2[o2[0].trim()] = o2[1].trim());
      }
    }), e2;
  });
  function Ir(t3) {
    const e2 = Dr(t3.style);
    return t3.staticStyle ? j(t3.staticStyle, e2) : e2;
  }
  function Dr(t3) {
    return Array.isArray(t3) ? A(t3) : "string" == typeof t3 ? Pr(t3) : t3;
  }
  const Nr = /^--/, Mr = /\s*!important$/, Lr = (t3, e2, n22) => {
    if (Nr.test(e2)) t3.style.setProperty(e2, n22);
    else if (Mr.test(n22)) t3.style.setProperty(O(e2), n22.replace(Mr, ""), "important");
    else {
      const o2 = Ur(e2);
      if (Array.isArray(n22)) for (let e3 = 0, r2 = n22.length; e3 < r2; e3++) t3.style[o2] = n22[e3];
      else t3.style[o2] = n22;
    }
  }, Rr = ["Webkit", "Moz", "ms"];
  let Fr;
  const Ur = b(function(t3) {
    if (Fr = Fr || document.createElement("div").style, "filter" !== (t3 = w(t3)) && t3 in Fr) return t3;
    const e2 = t3.charAt(0).toUpperCase() + t3.slice(1);
    for (let t42 = 0; t42 < Rr.length; t42++) {
      const n22 = Rr[t42] + e2;
      if (n22 in Fr) return n22;
    }
  });
  function Br(t3, e2) {
    const r2 = e2.data, s2 = t3.data;
    if (n2(r2.staticStyle) && n2(r2.style) && n2(s2.staticStyle) && n2(s2.style)) return;
    let i2, c2;
    const a2 = e2.elm, l2 = s2.staticStyle, u22 = s2.normalizedStyle || s2.style || {}, f22 = l2 || u22, d2 = Dr(e2.data.style) || {};
    e2.data.normalizedStyle = o(d2.__ob__) ? j({}, d2) : d2;
    const p2 = function(t42, e3) {
      const n22 = {};
      let o2;
      {
        let e4 = t42;
        for (; e4.componentInstance; ) e4 = e4.componentInstance._vnode, e4 && e4.data && (o2 = Ir(e4.data)) && j(n22, o2);
      }
      (o2 = Ir(t42.data)) && j(n22, o2);
      let r3 = t42;
      for (; r3 = r3.parent; ) r3.data && (o2 = Ir(r3.data)) && j(n22, o2);
      return n22;
    }(e2);
    for (c2 in f22) n2(p2[c2]) && Lr(a2, c2, "");
    for (c2 in p2) i2 = p2[c2], Lr(a2, c2, null == i2 ? "" : i2);
  }
  var Vr = { create: Br, update: Br };
  const zr = /\s+/;
  function Hr(t3, e2) {
    if (e2 && (e2 = e2.trim())) if (t3.classList) e2.indexOf(" ") > -1 ? e2.split(zr).forEach((e3) => t3.classList.add(e3)) : t3.classList.add(e2);
    else {
      const n22 = ` ${t3.getAttribute("class") || ""} `;
      n22.indexOf(" " + e2 + " ") < 0 && t3.setAttribute("class", (n22 + e2).trim());
    }
  }
  function Wr(t3, e2) {
    if (e2 && (e2 = e2.trim())) if (t3.classList) e2.indexOf(" ") > -1 ? e2.split(zr).forEach((e3) => t3.classList.remove(e3)) : t3.classList.remove(e2), t3.classList.length || t3.removeAttribute("class");
    else {
      let n22 = ` ${t3.getAttribute("class") || ""} `;
      const o2 = " " + e2 + " ";
      for (; n22.indexOf(o2) >= 0; ) n22 = n22.replace(o2, " ");
      n22 = n22.trim(), n22 ? t3.setAttribute("class", n22) : t3.removeAttribute("class");
    }
  }
  function Kr(t3) {
    if (t3) {
      if ("object" == typeof t3) {
        const e2 = {};
        return false !== t3.css && j(e2, qr(t3.name || "v")), j(e2, t3), e2;
      }
      return "string" == typeof t3 ? qr(t3) : void 0;
    }
  }
  const qr = b((t3) => ({ enterClass: `${t3}-enter`, enterToClass: `${t3}-enter-to`, enterActiveClass: `${t3}-enter-active`, leaveClass: `${t3}-leave`, leaveToClass: `${t3}-leave-to`, leaveActiveClass: `${t3}-leave-active` })), Gr = W && !G, Zr = "transition", Jr = "animation";
  let Xr = "transition", Qr = "transitionend", Yr = "animation", ts = "animationend";
  Gr && (void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend && (Xr = "WebkitTransition", Qr = "webkitTransitionEnd"), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend && (Yr = "WebkitAnimation", ts = "webkitAnimationEnd"));
  const es = W ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : (t3) => t3();
  function ns(t3) {
    es(() => {
      es(t3);
    });
  }
  function os(t3, e2) {
    const n22 = t3._transitionClasses || (t3._transitionClasses = []);
    n22.indexOf(e2) < 0 && (n22.push(e2), Hr(t3, e2));
  }
  function rs(t3, e2) {
    t3._transitionClasses && v(t3._transitionClasses, e2), Wr(t3, e2);
  }
  function ss(t3, e2, n22) {
    const { type: o2, timeout: r2, propCount: s2 } = cs(t3, e2);
    if (!o2) return n22();
    const i2 = o2 === Zr ? Qr : ts;
    let c2 = 0;
    const a2 = () => {
      t3.removeEventListener(i2, l2), n22();
    }, l2 = (e3) => {
      e3.target === t3 && ++c2 >= s2 && a2();
    };
    setTimeout(() => {
      c2 < s2 && a2();
    }, r2 + 1), t3.addEventListener(i2, l2);
  }
  const is = /\b(transform|all)(,|$)/;
  function cs(t3, e2) {
    const n22 = window.getComputedStyle(t3), o2 = (n22[Xr + "Delay"] || "").split(", "), r2 = (n22[Xr + "Duration"] || "").split(", "), s2 = as(o2, r2), i2 = (n22[Yr + "Delay"] || "").split(", "), c2 = (n22[Yr + "Duration"] || "").split(", "), a2 = as(i2, c2);
    let l2, u22 = 0, f22 = 0;
    e2 === Zr ? s2 > 0 && (l2 = Zr, u22 = s2, f22 = r2.length) : e2 === Jr ? a2 > 0 && (l2 = Jr, u22 = a2, f22 = c2.length) : (u22 = Math.max(s2, a2), l2 = u22 > 0 ? s2 > a2 ? Zr : Jr : null, f22 = l2 ? l2 === Zr ? r2.length : c2.length : 0);
    return { type: l2, timeout: u22, propCount: f22, hasTransform: l2 === Zr && is.test(n22[Xr + "Property"]) };
  }
  function as(t3, e2) {
    for (; t3.length < e2.length; ) t3 = t3.concat(t3);
    return Math.max.apply(null, e2.map((e3, n22) => ls(e3) + ls(t3[n22])));
  }
  function ls(t3) {
    return 1e3 * Number(t3.slice(0, -1).replace(",", "."));
  }
  function us(t3, e2) {
    const r2 = t3.elm;
    o(r2._leaveCb) && (r2._leaveCb.cancelled = true, r2._leaveCb());
    const s2 = Kr(t3.data.transition);
    if (n2(s2)) return;
    if (o(r2._enterCb) || 1 !== r2.nodeType) return;
    const { css: a2, type: l2, enterClass: u22, enterToClass: f22, enterActiveClass: d2, appearClass: p2, appearToClass: m2, appearActiveClass: _22, beforeEnter: v2, enter: y2, afterEnter: g2, enterCancelled: b2, beforeAppear: $2, appear: w2, afterAppear: C2, appearCancelled: x2, duration: O2 } = s2;
    let k2 = Sn, S2 = Sn.$vnode;
    for (; S2 && S2.parent; ) k2 = S2.context, S2 = S2.parent;
    const j2 = !k2._isMounted || !t3.isRootInsert;
    if (j2 && !w2 && "" !== w2) return;
    const A2 = j2 && p2 ? p2 : u22, T2 = j2 && _22 ? _22 : d2, E2 = j2 && m2 ? m2 : f22, P2 = j2 && $2 || v2, I2 = j2 && i(w2) ? w2 : y2, D2 = j2 && C2 || g2, M2 = j2 && x2 || b2, L2 = h(c(O2) ? O2.enter : O2), R2 = false !== a2 && !G, F2 = ps(I2), U2 = r2._enterCb = N(() => {
      R2 && (rs(r2, E2), rs(r2, T2)), U2.cancelled ? (R2 && rs(r2, A2), M2 && M2(r2)) : D2 && D2(r2), r2._enterCb = null;
    });
    t3.data.show || ce(t3, "insert", () => {
      const e3 = r2.parentNode, n22 = e3 && e3._pending && e3._pending[t3.key];
      n22 && n22.tag === t3.tag && n22.elm._leaveCb && n22.elm._leaveCb(), I2 && I2(r2, U2);
    }), P2 && P2(r2), R2 && (os(r2, A2), os(r2, T2), ns(() => {
      rs(r2, A2), U2.cancelled || (os(r2, E2), F2 || (ds(L2) ? setTimeout(U2, L2) : ss(r2, l2, U2)));
    })), t3.data.show && (e2 && e2(), I2 && I2(r2, U2)), R2 || F2 || U2();
  }
  function fs(t3, e2) {
    const r2 = t3.elm;
    o(r2._enterCb) && (r2._enterCb.cancelled = true, r2._enterCb());
    const s2 = Kr(t3.data.transition);
    if (n2(s2) || 1 !== r2.nodeType) return e2();
    if (o(r2._leaveCb)) return;
    const { css: i2, type: a2, leaveClass: l2, leaveToClass: u22, leaveActiveClass: f22, beforeLeave: d2, leave: p2, afterLeave: m2, leaveCancelled: _22, delayLeave: v2, duration: y2 } = s2, g2 = false !== i2 && !G, b2 = ps(p2), $2 = h(c(y2) ? y2.leave : y2), w2 = r2._leaveCb = N(() => {
      r2.parentNode && r2.parentNode._pending && (r2.parentNode._pending[t3.key] = null), g2 && (rs(r2, u22), rs(r2, f22)), w2.cancelled ? (g2 && rs(r2, l2), _22 && _22(r2)) : (e2(), m2 && m2(r2)), r2._leaveCb = null;
    });
    function C2() {
      w2.cancelled || (!t3.data.show && r2.parentNode && ((r2.parentNode._pending || (r2.parentNode._pending = {}))[t3.key] = t3), d2 && d2(r2), g2 && (os(r2, l2), os(r2, f22), ns(() => {
        rs(r2, l2), w2.cancelled || (os(r2, u22), b2 || (ds($2) ? setTimeout(w2, $2) : ss(r2, a2, w2)));
      })), p2 && p2(r2, w2), g2 || b2 || w2());
    }
    v2 ? v2(C2) : C2();
  }
  function ds(t3) {
    return "number" == typeof t3 && !isNaN(t3);
  }
  function ps(t3) {
    if (n2(t3)) return false;
    const e2 = t3.fns;
    return o(e2) ? ps(Array.isArray(e2) ? e2[0] : e2) : (t3._length || t3.length) > 1;
  }
  function hs(t3, e2) {
    true !== e2.data.show && us(e2);
  }
  const ms = function(t3) {
    let i2, c2;
    const a2 = {}, { modules: l2, nodeOps: u22 } = t3;
    for (i2 = 0; i2 < or.length; ++i2) for (a2[or[i2]] = [], c2 = 0; c2 < l2.length; ++c2) o(l2[c2][or[i2]]) && a2[or[i2]].push(l2[c2][or[i2]]);
    function f22(t42) {
      const e2 = u22.parentNode(t42);
      o(e2) && u22.removeChild(e2, t42);
    }
    function d2(t42, e2, n22, s2, i3, c3, l3) {
      if (o(t42.elm) && o(c3) && (t42 = c3[l3] = ft(t42)), t42.isRootInsert = !i3, function(t5, e3, n3, s3) {
        let i4 = t5.data;
        if (o(i4)) {
          const c4 = o(t5.componentInstance) && i4.keepAlive;
          if (o(i4 = i4.hook) && o(i4 = i4.init) && i4(t5, false), o(t5.componentInstance)) return p2(t5, e3), h2(n3, t5.elm, s3), r(c4) && function(t6, e4, n4, r2) {
            let s4, i5 = t6;
            for (; i5.componentInstance; ) if (i5 = i5.componentInstance._vnode, o(s4 = i5.data) && o(s4 = s4.transition)) {
              for (s4 = 0; s4 < a2.activate.length; ++s4) a2.activate[s4](nr, i5);
              e4.push(i5);
              break;
            }
            h2(n4, t6.elm, r2);
          }(t5, e3, n3, s3), true;
        }
      }(t42, e2, n22, s2)) return;
      const f3 = t42.data, d3 = t42.children, m2 = t42.tag;
      o(m2) ? (t42.elm = t42.ns ? u22.createElementNS(t42.ns, m2) : u22.createElement(m2, t42), g2(t42), _22(t42, d3, e2), o(f3) && y2(t42, e2), h2(n22, t42.elm, s2)) : r(t42.isComment) ? (t42.elm = u22.createComment(t42.text), h2(n22, t42.elm, s2)) : (t42.elm = u22.createTextNode(t42.text), h2(n22, t42.elm, s2));
    }
    function p2(t42, e2) {
      o(t42.data.pendingInsert) && (e2.push.apply(e2, t42.data.pendingInsert), t42.data.pendingInsert = null), t42.elm = t42.componentInstance.$el, v2(t42) ? (y2(t42, e2), g2(t42)) : (tr(t42), e2.push(t42));
    }
    function h2(t42, e2, n22) {
      o(t42) && (o(n22) ? u22.parentNode(n22) === t42 && u22.insertBefore(t42, e2, n22) : u22.appendChild(t42, e2));
    }
    function _22(t42, n22, o2) {
      if (e(n22)) for (let e2 = 0; e2 < n22.length; ++e2) d2(n22[e2], o2, t42.elm, null, true, n22, e2);
      else s(t42.text) && u22.appendChild(t42.elm, u22.createTextNode(String(t42.text)));
    }
    function v2(t42) {
      for (; t42.componentInstance; ) t42 = t42.componentInstance._vnode;
      return o(t42.tag);
    }
    function y2(t42, e2) {
      for (let e3 = 0; e3 < a2.create.length; ++e3) a2.create[e3](nr, t42);
      i2 = t42.data.hook, o(i2) && (o(i2.create) && i2.create(nr, t42), o(i2.insert) && e2.push(t42));
    }
    function g2(t42) {
      let e2;
      if (o(e2 = t42.fnScopeId)) u22.setStyleScope(t42.elm, e2);
      else {
        let n22 = t42;
        for (; n22; ) o(e2 = n22.context) && o(e2 = e2.$options._scopeId) && u22.setStyleScope(t42.elm, e2), n22 = n22.parent;
      }
      o(e2 = Sn) && e2 !== t42.context && e2 !== t42.fnContext && o(e2 = e2.$options._scopeId) && u22.setStyleScope(t42.elm, e2);
    }
    function b2(t42, e2, n22, o2, r2, s2) {
      for (; o2 <= r2; ++o2) d2(n22[o2], s2, t42, e2, false, n22, o2);
    }
    function $2(t42) {
      let e2, n22;
      const r2 = t42.data;
      if (o(r2)) for (o(e2 = r2.hook) && o(e2 = e2.destroy) && e2(t42), e2 = 0; e2 < a2.destroy.length; ++e2) a2.destroy[e2](t42);
      if (o(e2 = t42.children)) for (n22 = 0; n22 < t42.children.length; ++n22) $2(t42.children[n22]);
    }
    function w2(t42, e2, n22) {
      for (; e2 <= n22; ++e2) {
        const n3 = t42[e2];
        o(n3) && (o(n3.tag) ? (C2(n3), $2(n3)) : f22(n3.elm));
      }
    }
    function C2(t42, e2) {
      if (o(e2) || o(t42.data)) {
        let n22;
        const r2 = a2.remove.length + 1;
        for (o(e2) ? e2.listeners += r2 : e2 = function(t5, e3) {
          function n3() {
            0 == --n3.listeners && f22(t5);
          }
          return n3.listeners = e3, n3;
        }(t42.elm, r2), o(n22 = t42.componentInstance) && o(n22 = n22._vnode) && o(n22.data) && C2(n22, e2), n22 = 0; n22 < a2.remove.length; ++n22) a2.remove[n22](t42, e2);
        o(n22 = t42.data.hook) && o(n22 = n22.remove) ? n22(t42, e2) : e2();
      } else f22(t42.elm);
    }
    function x2(t42, e2, n22, r2) {
      for (let s2 = n22; s2 < r2; s2++) {
        const n3 = e2[s2];
        if (o(n3) && rr(t42, n3)) return s2;
      }
    }
    function O2(t42, e2, s2, i3, c3, l3) {
      if (t42 === e2) return;
      o(e2.elm) && o(i3) && (e2 = i3[c3] = ft(e2));
      const f3 = e2.elm = t42.elm;
      if (r(t42.isAsyncPlaceholder)) return void (o(e2.asyncFactory.resolved) ? j2(t42.elm, e2, s2) : e2.isAsyncPlaceholder = true);
      if (r(e2.isStatic) && r(t42.isStatic) && e2.key === t42.key && (r(e2.isCloned) || r(e2.isOnce))) return void (e2.componentInstance = t42.componentInstance);
      let p3;
      const h3 = e2.data;
      o(h3) && o(p3 = h3.hook) && o(p3 = p3.prepatch) && p3(t42, e2);
      const m2 = t42.children, _3 = e2.children;
      if (o(h3) && v2(e2)) {
        for (p3 = 0; p3 < a2.update.length; ++p3) a2.update[p3](t42, e2);
        o(p3 = h3.hook) && o(p3 = p3.update) && p3(t42, e2);
      }
      n2(e2.text) ? o(m2) && o(_3) ? m2 !== _3 && function(t5, e3, r2, s3, i4) {
        let c4, a3, l4, f4, p4 = 0, h4 = 0, m3 = e3.length - 1, _4 = e3[0], v3 = e3[m3], y3 = r2.length - 1, g3 = r2[0], $3 = r2[y3];
        const C3 = !i4;
        for (; p4 <= m3 && h4 <= y3; ) n2(_4) ? _4 = e3[++p4] : n2(v3) ? v3 = e3[--m3] : rr(_4, g3) ? (O2(_4, g3, s3, r2, h4), _4 = e3[++p4], g3 = r2[++h4]) : rr(v3, $3) ? (O2(v3, $3, s3, r2, y3), v3 = e3[--m3], $3 = r2[--y3]) : rr(_4, $3) ? (O2(_4, $3, s3, r2, y3), C3 && u22.insertBefore(t5, _4.elm, u22.nextSibling(v3.elm)), _4 = e3[++p4], $3 = r2[--y3]) : rr(v3, g3) ? (O2(v3, g3, s3, r2, h4), C3 && u22.insertBefore(t5, v3.elm, _4.elm), v3 = e3[--m3], g3 = r2[++h4]) : (n2(c4) && (c4 = sr(e3, p4, m3)), a3 = o(g3.key) ? c4[g3.key] : x2(g3, e3, p4, m3), n2(a3) ? d2(g3, s3, t5, _4.elm, false, r2, h4) : (l4 = e3[a3], rr(l4, g3) ? (O2(l4, g3, s3, r2, h4), e3[a3] = void 0, C3 && u22.insertBefore(t5, l4.elm, _4.elm)) : d2(g3, s3, t5, _4.elm, false, r2, h4)), g3 = r2[++h4]);
        p4 > m3 ? (f4 = n2(r2[y3 + 1]) ? null : r2[y3 + 1].elm, b2(t5, f4, r2, h4, y3, s3)) : h4 > y3 && w2(e3, p4, m3);
      }(f3, m2, _3, s2, l3) : o(_3) ? (o(t42.text) && u22.setTextContent(f3, ""), b2(f3, null, _3, 0, _3.length - 1, s2)) : o(m2) ? w2(m2, 0, m2.length - 1) : o(t42.text) && u22.setTextContent(f3, "") : t42.text !== e2.text && u22.setTextContent(f3, e2.text), o(h3) && o(p3 = h3.hook) && o(p3 = p3.postpatch) && p3(t42, e2);
    }
    function k2(t42, e2, n22) {
      if (r(n22) && o(t42.parent)) t42.parent.data.pendingInsert = e2;
      else for (let t5 = 0; t5 < e2.length; ++t5) e2[t5].data.hook.insert(e2[t5]);
    }
    const S2 = m("attrs,class,staticClass,staticStyle,key");
    function j2(t42, e2, n22, s2) {
      let i3;
      const { tag: c3, data: a3, children: l3 } = e2;
      if (s2 = s2 || a3 && a3.pre, e2.elm = t42, r(e2.isComment) && o(e2.asyncFactory)) return e2.isAsyncPlaceholder = true, true;
      if (o(a3) && (o(i3 = a3.hook) && o(i3 = i3.init) && i3(e2, true), o(i3 = e2.componentInstance))) return p2(e2, n22), true;
      if (o(c3)) {
        if (o(l3)) if (t42.hasChildNodes()) if (o(i3 = a3) && o(i3 = i3.domProps) && o(i3 = i3.innerHTML)) {
          if (i3 !== t42.innerHTML) return false;
        } else {
          let e3 = true, o2 = t42.firstChild;
          for (let t5 = 0; t5 < l3.length; t5++) {
            if (!o2 || !j2(o2, l3[t5], n22, s2)) {
              e3 = false;
              break;
            }
            o2 = o2.nextSibling;
          }
          if (!e3 || o2) return false;
        }
        else _22(e2, l3, n22);
        if (o(a3)) {
          let t5 = false;
          for (const o2 in a3) if (!S2(o2)) {
            t5 = true, y2(e2, n22);
            break;
          }
          !t5 && a3.class && yn(a3.class);
        }
      } else t42.data !== e2.text && (t42.data = e2.text);
      return true;
    }
    return function(t42, e2, s2, i3) {
      if (n2(e2)) return void (o(t42) && $2(t42));
      let c3 = false;
      const l3 = [];
      if (n2(t42)) c3 = true, d2(e2, l3);
      else {
        const n22 = o(t42.nodeType);
        if (!n22 && rr(t42, e2)) O2(t42, e2, l3, null, null, i3);
        else {
          if (n22) {
            if (1 === t42.nodeType && t42.hasAttribute(L) && (t42.removeAttribute(L), s2 = true), r(s2) && j2(t42, e2, l3)) return k2(e2, l3, true), t42;
            f3 = t42, t42 = new at(u22.tagName(f3).toLowerCase(), {}, [], void 0, f3);
          }
          const i4 = t42.elm, c4 = u22.parentNode(i4);
          if (d2(e2, l3, i4._leaveCb ? null : c4, u22.nextSibling(i4)), o(e2.parent)) {
            let t5 = e2.parent;
            const n3 = v2(e2);
            for (; t5; ) {
              for (let e3 = 0; e3 < a2.destroy.length; ++e3) a2.destroy[e3](t5);
              if (t5.elm = e2.elm, n3) {
                for (let e4 = 0; e4 < a2.create.length; ++e4) a2.create[e4](nr, t5);
                const e3 = t5.data.hook.insert;
                if (e3.merged) {
                  const t6 = e3.fns.slice(1);
                  for (let e4 = 0; e4 < t6.length; e4++) t6[e4]();
                }
              } else tr(t5);
              t5 = t5.parent;
            }
          }
          o(c4) ? w2([t42], 0, 0) : o(t42.tag) && $2(t42);
        }
      }
      var f3;
      return k2(e2, l3, c3), e2.elm;
    };
  }({ nodeOps: Qo, modules: [_r, yr, Sr, Er, Vr, W ? { create: hs, activate: hs, remove(t3, e2) {
    true !== t3.data.show ? fs(t3, e2) : e2();
  } } : {}].concat(dr) });
  G && document.addEventListener("selectionchange", () => {
    const t3 = document.activeElement;
    t3 && t3.vmodel && Cs(t3, "input");
  });
  const _s = { inserted(t3, e2, n22, o2) {
    "select" === n22.tag ? (o2.elm && !o2.elm._vOptions ? ce(n22, "postpatch", () => {
      _s.componentUpdated(t3, e2, n22);
    }) : vs(t3, e2, n22.context), t3._vOptions = [].map.call(t3.options, bs)) : ("textarea" === n22.tag || Xo(t3.type)) && (t3._vModifiers = e2.modifiers, e2.modifiers.lazy || (t3.addEventListener("compositionstart", $s), t3.addEventListener("compositionend", ws), t3.addEventListener("change", ws), G && (t3.vmodel = true)));
  }, componentUpdated(t3, e2, n22) {
    if ("select" === n22.tag) {
      vs(t3, e2, n22.context);
      const o2 = t3._vOptions, r2 = t3._vOptions = [].map.call(t3.options, bs);
      if (r2.some((t42, e3) => !I(t42, o2[e3]))) {
        (t3.multiple ? e2.value.some((t42) => gs(t42, r2)) : e2.value !== e2.oldValue && gs(e2.value, r2)) && Cs(t3, "change");
      }
    }
  } };
  function vs(t3, e2, n22) {
    ys(t3, e2), (q || Z) && setTimeout(() => {
      ys(t3, e2);
    }, 0);
  }
  function ys(t3, e2, n22) {
    const o2 = e2.value, r2 = t3.multiple;
    if (r2 && !Array.isArray(o2)) return;
    let s2, i2;
    for (let e3 = 0, n3 = t3.options.length; e3 < n3; e3++) if (i2 = t3.options[e3], r2) s2 = D(o2, bs(i2)) > -1, i2.selected !== s2 && (i2.selected = s2);
    else if (I(bs(i2), o2)) return void (t3.selectedIndex !== e3 && (t3.selectedIndex = e3));
    r2 || (t3.selectedIndex = -1);
  }
  function gs(t3, e2) {
    return e2.every((e3) => !I(e3, t3));
  }
  function bs(t3) {
    return "_value" in t3 ? t3._value : t3.value;
  }
  function $s(t3) {
    t3.target.composing = true;
  }
  function ws(t3) {
    t3.target.composing && (t3.target.composing = false, Cs(t3.target, "input"));
  }
  function Cs(t3, e2) {
    const n22 = document.createEvent("HTMLEvents");
    n22.initEvent(e2, true, true), t3.dispatchEvent(n22);
  }
  function xs(t3) {
    return !t3.componentInstance || t3.data && t3.data.transition ? t3 : xs(t3.componentInstance._vnode);
  }
  var Os = { bind(t3, { value: e2 }, n22) {
    const o2 = (n22 = xs(n22)).data && n22.data.transition, r2 = t3.__vOriginalDisplay = "none" === t3.style.display ? "" : t3.style.display;
    e2 && o2 ? (n22.data.show = true, us(n22, () => {
      t3.style.display = r2;
    })) : t3.style.display = e2 ? r2 : "none";
  }, update(t3, { value: e2, oldValue: n22 }, o2) {
    if (!e2 == !n22) return;
    (o2 = xs(o2)).data && o2.data.transition ? (o2.data.show = true, e2 ? us(o2, () => {
      t3.style.display = t3.__vOriginalDisplay;
    }) : fs(o2, () => {
      t3.style.display = "none";
    })) : t3.style.display = e2 ? t3.__vOriginalDisplay : "none";
  }, unbind(t3, e2, n22, o2, r2) {
    r2 || (t3.style.display = t3.__vOriginalDisplay);
  } }, ks = { model: _s, show: Os };
  const Ss = { name: String, appear: Boolean, css: Boolean, mode: String, type: String, enterClass: String, leaveClass: String, enterToClass: String, leaveToClass: String, enterActiveClass: String, leaveActiveClass: String, appearClass: String, appearActiveClass: String, appearToClass: String, duration: [Number, String, Object] };
  function js(t3) {
    const e2 = t3 && t3.componentOptions;
    return e2 && e2.Ctor.options.abstract ? js(Ue(e2.children)) : t3;
  }
  function As(t3) {
    const e2 = {}, n22 = t3.$options;
    for (const o3 in n22.propsData) e2[o3] = t3[o3];
    const o2 = n22._parentListeners;
    for (const t42 in o2) e2[w(t42)] = o2[t42];
    return e2;
  }
  function Ts(t3, e2) {
    if (/\d-keep-alive$/.test(e2.tag)) return t3("keep-alive", { props: e2.componentOptions.propsData });
  }
  const Es = (t3) => t3.tag || Ae(t3), Ps = (t3) => "show" === t3.name;
  var Is = { name: "transition", props: Ss, abstract: true, render(t3) {
    let e2 = this.$slots.default;
    if (!e2) return;
    if (e2 = e2.filter(Es), !e2.length) return;
    const n22 = this.mode, o2 = e2[0];
    if (function(t42) {
      for (; t42 = t42.parent; ) if (t42.data.transition) return true;
    }(this.$vnode)) return o2;
    const r2 = js(o2);
    if (!r2) return o2;
    if (this._leaving) return Ts(t3, o2);
    const i2 = `__transition-${this._uid}-`;
    r2.key = null == r2.key ? r2.isComment ? i2 + "comment" : i2 + r2.tag : s(r2.key) ? 0 === String(r2.key).indexOf(i2) ? r2.key : i2 + r2.key : r2.key;
    const c2 = (r2.data || (r2.data = {})).transition = As(this), a2 = this._vnode, l2 = js(a2);
    if (r2.data.directives && r2.data.directives.some(Ps) && (r2.data.show = true), l2 && l2.data && !function(t42, e3) {
      return e3.key === t42.key && e3.tag === t42.tag;
    }(r2, l2) && !Ae(l2) && (!l2.componentInstance || !l2.componentInstance._vnode.isComment)) {
      const e3 = l2.data.transition = j({}, c2);
      if ("out-in" === n22) return this._leaving = true, ce(e3, "afterLeave", () => {
        this._leaving = false, this.$forceUpdate();
      }), Ts(t3, o2);
      if ("in-out" === n22) {
        if (Ae(r2)) return a2;
        let t42;
        const n3 = () => {
          t42();
        };
        ce(c2, "afterEnter", n3), ce(c2, "enterCancelled", n3), ce(e3, "delayLeave", (e4) => {
          t42 = e4;
        });
      }
    }
    return o2;
  } };
  const Ds = j({ tag: String, moveClass: String }, Ss);
  delete Ds.mode;
  var Ns = { props: Ds, beforeMount() {
    const t3 = this._update;
    this._update = (e2, n22) => {
      const o2 = jn(this);
      this.__patch__(this._vnode, this.kept, false, true), this._vnode = this.kept, o2(), t3.call(this, e2, n22);
    };
  }, render(t3) {
    const e2 = this.tag || this.$vnode.data.tag || "span", n22 = /* @__PURE__ */ Object.create(null), o2 = this.prevChildren = this.children, r2 = this.$slots.default || [], s2 = this.children = [], i2 = As(this);
    for (let t42 = 0; t42 < r2.length; t42++) {
      const e3 = r2[t42];
      e3.tag && null != e3.key && 0 !== String(e3.key).indexOf("__vlist") && (s2.push(e3), n22[e3.key] = e3, (e3.data || (e3.data = {})).transition = i2);
    }
    if (o2) {
      const r3 = [], s3 = [];
      for (let t42 = 0; t42 < o2.length; t42++) {
        const e3 = o2[t42];
        e3.data.transition = i2, e3.data.pos = e3.elm.getBoundingClientRect(), n22[e3.key] ? r3.push(e3) : s3.push(e3);
      }
      this.kept = t3(e2, null, r3), this.removed = s3;
    }
    return t3(e2, null, s2);
  }, updated() {
    const t3 = this.prevChildren, e2 = this.moveClass || (this.name || "v") + "-move";
    t3.length && this.hasMove(t3[0].elm, e2) && (t3.forEach(Ms), t3.forEach(Ls), t3.forEach(Rs), this._reflow = document.body.offsetHeight, t3.forEach((t42) => {
      if (t42.data.moved) {
        const n22 = t42.elm, o2 = n22.style;
        os(n22, e2), o2.transform = o2.WebkitTransform = o2.transitionDuration = "", n22.addEventListener(Qr, n22._moveCb = function t5(o3) {
          o3 && o3.target !== n22 || o3 && !/transform$/.test(o3.propertyName) || (n22.removeEventListener(Qr, t5), n22._moveCb = null, rs(n22, e2));
        });
      }
    }));
  }, methods: { hasMove(t3, e2) {
    if (!Gr) return false;
    if (this._hasMove) return this._hasMove;
    const n22 = t3.cloneNode();
    t3._transitionClasses && t3._transitionClasses.forEach((t42) => {
      Wr(n22, t42);
    }), Hr(n22, e2), n22.style.display = "none", this.$el.appendChild(n22);
    const o2 = cs(n22);
    return this.$el.removeChild(n22), this._hasMove = o2.hasTransform;
  } } };
  function Ms(t3) {
    t3.elm._moveCb && t3.elm._moveCb(), t3.elm._enterCb && t3.elm._enterCb();
  }
  function Ls(t3) {
    t3.data.newPos = t3.elm.getBoundingClientRect();
  }
  function Rs(t3) {
    const e2 = t3.data.pos, n22 = t3.data.newPos, o2 = e2.left - n22.left, r2 = e2.top - n22.top;
    if (o2 || r2) {
      t3.data.moved = true;
      const e3 = t3.elm.style;
      e3.transform = e3.WebkitTransform = `translate(${o2}px,${r2}px)`, e3.transitionDuration = "0s";
    }
  }
  var Fs = { Transition: Is, TransitionGroup: Ns };
  xo.config.mustUseProp = (t3, e2, n22) => "value" === n22 && Io(t3) && "button" !== e2 || "selected" === n22 && "option" === t3 || "checked" === n22 && "input" === t3 || "muted" === n22 && "video" === t3, xo.config.isReservedTag = Zo, xo.config.isReservedAttr = Po, xo.config.getTagNamespace = function(t3) {
    return Go(t3) ? "svg" : "math" === t3 ? "math" : void 0;
  }, xo.config.isUnknownElement = function(t3) {
    if (!W) return true;
    if (Zo(t3)) return false;
    if (t3 = t3.toLowerCase(), null != Jo[t3]) return Jo[t3];
    const e2 = document.createElement(t3);
    return t3.indexOf("-") > -1 ? Jo[t3] = e2.constructor === window.HTMLUnknownElement || e2.constructor === window.HTMLElement : Jo[t3] = /HTMLUnknownElement/.test(e2.toString());
  }, j(xo.options.directives, ks), j(xo.options.components, Fs), xo.prototype.__patch__ = W ? ms : T, xo.prototype.$mount = function(t3, e2) {
    return function(t42, e3, n22) {
      let o2;
      t42.$el = e3, t42.$options.render || (t42.$options.render = lt), Pn(t42, "beforeMount"), o2 = () => {
        t42._update(t42._render(), n22);
      }, new wn(t42, o2, T, { before() {
        t42._isMounted && !t42._isDestroyed && Pn(t42, "beforeUpdate");
      } }, true), n22 = false;
      const r2 = t42._preWatchers;
      if (r2) for (let t5 = 0; t5 < r2.length; t5++) r2[t5].run();
      return null == t42.$vnode && (t42._isMounted = true, Pn(t42, "mounted")), t42;
    }(this, t3 = t3 && W ? function(t42) {
      if ("string" == typeof t42) {
        return document.querySelector(t42) || document.createElement("div");
      }
      return t42;
    }(t3) : void 0, e2);
  }, W && setTimeout(() => {
  }, 0), j(xo, _n), vue_runtime_common_prod.exports = xo;
  return vue_runtime_common_prod.exports;
}
var hasRequiredVue_runtime_common;
function requireVue_runtime_common() {
  if (hasRequiredVue_runtime_common) return vue_runtime_common.exports;
  hasRequiredVue_runtime_common = 1;
  {
    vue_runtime_common.exports = /* @__PURE__ */ requireVue_runtime_common_prod();
  }
  return vue_runtime_common.exports;
}
/*! vue-grid-layout - 2.4.0 | (c) 2015, 2022  Gustavo Santos (JBay Solutions) <gustavo.santos@jbaysolutions.com> (http://www.jbaysolutions.com) | https://github.com/jbaysolutions/vue-grid-layout */
var hasRequiredVueGridLayout_common;
function requireVueGridLayout_common() {
  if (hasRequiredVueGridLayout_common) return vueGridLayout_common.exports;
  hasRequiredVueGridLayout_common = 1;
  (function(module) {
    module.exports = /******/
    function(modules2) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        var module2 = installedModules[moduleId] = {
          /******/
          i: moduleId,
          /******/
          l: false,
          /******/
          exports: {}
          /******/
        };
        modules2[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.l = true;
        return module2.exports;
      }
      __webpack_require__.m = modules2;
      __webpack_require__.c = installedModules;
      __webpack_require__.d = function(exports, name, getter) {
        if (!__webpack_require__.o(exports, name)) {
          Object.defineProperty(exports, name, { enumerable: true, get: getter });
        }
      };
      __webpack_require__.r = function(exports) {
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
          Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
        }
        Object.defineProperty(exports, "__esModule", { value: true });
      };
      __webpack_require__.t = function(value, mode) {
        if (mode & 1) value = __webpack_require__(value);
        if (mode & 8) return value;
        if (mode & 4 && typeof value === "object" && value && value.__esModule) return value;
        var ns = /* @__PURE__ */ Object.create(null);
        __webpack_require__.r(ns);
        Object.defineProperty(ns, "default", { enumerable: true, value });
        if (mode & 2 && typeof value != "string") for (var key in value) __webpack_require__.d(ns, key, function(key2) {
          return value[key2];
        }.bind(null, key));
        return ns;
      };
      __webpack_require__.n = function(module2) {
        var getter = module2 && module2.__esModule ? (
          /******/
          function getDefault() {
            return module2["default"];
          }
        ) : (
          /******/
          function getModuleExports() {
            return module2;
          }
        );
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      __webpack_require__.p = "";
      return __webpack_require__(__webpack_require__.s = "fb15");
    }({
      /***/
      "01f9": (
        /***/
        function(module2, exports, __webpack_require__) {
          var LIBRARY = __webpack_require__("2d00");
          var $export = __webpack_require__("5ca1");
          var redefine = __webpack_require__("2aba");
          var hide = __webpack_require__("32e9");
          var Iterators = __webpack_require__("84f2");
          var $iterCreate = __webpack_require__("41a0");
          var setToStringTag = __webpack_require__("7f20");
          var getPrototypeOf2 = __webpack_require__("38fd");
          var ITERATOR = __webpack_require__("2b4c")("iterator");
          var BUGGY = !([].keys && "next" in [].keys());
          var FF_ITERATOR = "@@iterator";
          var KEYS = "keys";
          var VALUES = "values";
          var returnThis = function() {
            return this;
          };
          module2.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
            $iterCreate(Constructor, NAME, next);
            var getMethod = function(kind) {
              if (!BUGGY && kind in proto) return proto[kind];
              switch (kind) {
                case KEYS:
                  return function keys() {
                    return new Constructor(this, kind);
                  };
                case VALUES:
                  return function values() {
                    return new Constructor(this, kind);
                  };
              }
              return function entries2() {
                return new Constructor(this, kind);
              };
            };
            var TAG = NAME + " Iterator";
            var DEF_VALUES = DEFAULT == VALUES;
            var VALUES_BUG = false;
            var proto = Base.prototype;
            var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
            var $default = $native || getMethod(DEFAULT);
            var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : void 0;
            var $anyNative = NAME == "Array" ? proto.entries || $native : $native;
            var methods, key, IteratorPrototype;
            if ($anyNative) {
              IteratorPrototype = getPrototypeOf2($anyNative.call(new Base()));
              if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
                setToStringTag(IteratorPrototype, TAG, true);
                if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != "function") hide(IteratorPrototype, ITERATOR, returnThis);
              }
            }
            if (DEF_VALUES && $native && $native.name !== VALUES) {
              VALUES_BUG = true;
              $default = function values() {
                return $native.call(this);
              };
            }
            if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
              hide(proto, ITERATOR, $default);
            }
            Iterators[NAME] = $default;
            Iterators[TAG] = returnThis;
            if (DEFAULT) {
              methods = {
                values: DEF_VALUES ? $default : getMethod(VALUES),
                keys: IS_SET ? $default : getMethod(KEYS),
                entries: $entries
              };
              if (FORCED) for (key in methods) {
                if (!(key in proto)) redefine(proto, key, methods[key]);
              }
              else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
            }
            return methods;
          };
        }
      ),
      /***/
      "02f4": (
        /***/
        function(module2, exports, __webpack_require__) {
          var toInteger = __webpack_require__("4588");
          var defined = __webpack_require__("be13");
          module2.exports = function(TO_STRING) {
            return function(that, pos) {
              var s = String(defined(that));
              var i = toInteger(pos);
              var l = s.length;
              var a, b;
              if (i < 0 || i >= l) return TO_STRING ? "" : void 0;
              a = s.charCodeAt(i);
              return a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
            };
          };
        }
      ),
      /***/
      "0390": (
        /***/
        function(module2, exports, __webpack_require__) {
          var at = __webpack_require__("02f4")(true);
          module2.exports = function(S, index2, unicode) {
            return index2 + (unicode ? at(S, index2).length : 1);
          };
        }
      ),
      /***/
      "0bfb": (
        /***/
        function(module2, exports, __webpack_require__) {
          var anObject = __webpack_require__("cb7c");
          module2.exports = function() {
            var that = anObject(this);
            var result = "";
            if (that.global) result += "g";
            if (that.ignoreCase) result += "i";
            if (that.multiline) result += "m";
            if (that.unicode) result += "u";
            if (that.sticky) result += "y";
            return result;
          };
        }
      ),
      /***/
      "0d58": (
        /***/
        function(module2, exports, __webpack_require__) {
          var $keys = __webpack_require__("ce10");
          var enumBugKeys = __webpack_require__("e11e");
          module2.exports = Object.keys || function keys(O) {
            return $keys(O, enumBugKeys);
          };
        }
      ),
      /***/
      "1156": (
        /***/
        function(module2, exports, __webpack_require__) {
          var content = __webpack_require__("ad20");
          if (typeof content === "string") content = [[module2.i, content, ""]];
          if (content.locals) module2.exports = content.locals;
          var add2 = __webpack_require__("499e").default;
          add2("c1ec597e", content, true, { "sourceMap": false, "shadowMode": false });
        }
      ),
      /***/
      "11e9": (
        /***/
        function(module2, exports, __webpack_require__) {
          var pIE = __webpack_require__("52a7");
          var createDesc = __webpack_require__("4630");
          var toIObject = __webpack_require__("6821");
          var toPrimitive = __webpack_require__("6a99");
          var has2 = __webpack_require__("69a8");
          var IE8_DOM_DEFINE = __webpack_require__("c69a");
          var gOPD = Object.getOwnPropertyDescriptor;
          exports.f = __webpack_require__("9e1e") ? gOPD : function getOwnPropertyDescriptor2(O, P) {
            O = toIObject(O);
            P = toPrimitive(P, true);
            if (IE8_DOM_DEFINE) try {
              return gOPD(O, P);
            } catch (e) {
            }
            if (has2(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
          };
        }
      ),
      /***/
      "1495": (
        /***/
        function(module2, exports, __webpack_require__) {
          var dP = __webpack_require__("86cc");
          var anObject = __webpack_require__("cb7c");
          var getKeys = __webpack_require__("0d58");
          module2.exports = __webpack_require__("9e1e") ? Object.defineProperties : function defineProperties(O, Properties) {
            anObject(O);
            var keys = getKeys(Properties);
            var length = keys.length;
            var i = 0;
            var P;
            while (length > i) dP.f(O, P = keys[i++], Properties[P]);
            return O;
          };
        }
      ),
      /***/
      "18d2": (
        /***/
        function(module2, exports, __webpack_require__) {
          var browserDetector = __webpack_require__("18e9");
          module2.exports = function(options) {
            options = options || {};
            var reporter = options.reporter;
            var batchProcessor = options.batchProcessor;
            var getState = options.stateHandler.getState;
            if (!reporter) {
              throw new Error("Missing required dependency: reporter.");
            }
            function addListener(element, listener) {
              function listenerProxy() {
                listener(element);
              }
              if (browserDetector.isIE(8)) {
                getState(element).object = {
                  proxy: listenerProxy
                };
                element.attachEvent("onresize", listenerProxy);
              } else {
                var object = getObject(element);
                if (!object) {
                  throw new Error("Element is not detectable by this strategy.");
                }
                object.contentDocument.defaultView.addEventListener("resize", listenerProxy);
              }
            }
            function buildCssTextString(rules) {
              var seperator = options.important ? " !important; " : "; ";
              return (rules.join(seperator) + seperator).trim();
            }
            function makeDetectable(options2, element, callback) {
              if (!callback) {
                callback = element;
                element = options2;
                options2 = null;
              }
              options2 = options2 || {};
              options2.debug;
              function injectObject(element2, callback2) {
                var OBJECT_STYLE = buildCssTextString(["display: block", "position: absolute", "top: 0", "left: 0", "width: 100%", "height: 100%", "border: none", "padding: 0", "margin: 0", "opacity: 0", "z-index: -1000", "pointer-events: none"]);
                var positionCheckPerformed = false;
                var style2 = window.getComputedStyle(element2);
                var width = element2.offsetWidth;
                var height = element2.offsetHeight;
                getState(element2).startSize = {
                  width,
                  height
                };
                function mutateDom() {
                  function alterPositionStyles() {
                    if (style2.position === "static") {
                      element2.style.setProperty("position", "relative", options2.important ? "important" : "");
                      var removeRelativeStyles = function(reporter2, element3, style22, property) {
                        function getNumericalValue(value2) {
                          return value2.replace(/[^-\d\.]/g, "");
                        }
                        var value = style22[property];
                        if (value !== "auto" && getNumericalValue(value) !== "0") {
                          reporter2.warn("An element that is positioned static has style." + property + "=" + value + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + property + " will be set to 0. Element: ", element3);
                          element3.style.setProperty(property, "0", options2.important ? "important" : "");
                        }
                      };
                      removeRelativeStyles(reporter, element2, style2, "top");
                      removeRelativeStyles(reporter, element2, style2, "right");
                      removeRelativeStyles(reporter, element2, style2, "bottom");
                      removeRelativeStyles(reporter, element2, style2, "left");
                    }
                  }
                  function onObjectLoad() {
                    if (!positionCheckPerformed) {
                      alterPositionStyles();
                    }
                    function getDocument(element3, callback3) {
                      if (!element3.contentDocument) {
                        var state = getState(element3);
                        if (state.checkForObjectDocumentTimeoutId) {
                          window.clearTimeout(state.checkForObjectDocumentTimeoutId);
                        }
                        state.checkForObjectDocumentTimeoutId = setTimeout(function checkForObjectDocument() {
                          state.checkForObjectDocumentTimeoutId = 0;
                          getDocument(element3, callback3);
                        }, 100);
                        return;
                      }
                      callback3(element3.contentDocument);
                    }
                    var objectElement = this;
                    getDocument(objectElement, function onObjectDocumentReady(objectDocument) {
                      callback2(element2);
                    });
                  }
                  if (style2.position !== "") {
                    alterPositionStyles();
                    positionCheckPerformed = true;
                  }
                  var object = document.createElement("object");
                  object.style.cssText = OBJECT_STYLE;
                  object.tabIndex = -1;
                  object.type = "text/html";
                  object.setAttribute("aria-hidden", "true");
                  object.onload = onObjectLoad;
                  if (!browserDetector.isIE()) {
                    object.data = "about:blank";
                  }
                  if (!getState(element2)) {
                    return;
                  }
                  element2.appendChild(object);
                  getState(element2).object = object;
                  if (browserDetector.isIE()) {
                    object.data = "about:blank";
                  }
                }
                if (batchProcessor) {
                  batchProcessor.add(mutateDom);
                } else {
                  mutateDom();
                }
              }
              if (browserDetector.isIE(8)) {
                callback(element);
              } else {
                injectObject(element, callback);
              }
            }
            function getObject(element) {
              return getState(element).object;
            }
            function uninstall(element) {
              if (!getState(element)) {
                return;
              }
              var object = getObject(element);
              if (!object) {
                return;
              }
              if (browserDetector.isIE(8)) {
                element.detachEvent("onresize", object.proxy);
              } else {
                element.removeChild(object);
              }
              if (getState(element).checkForObjectDocumentTimeoutId) {
                window.clearTimeout(getState(element).checkForObjectDocumentTimeoutId);
              }
              delete getState(element).object;
            }
            return {
              makeDetectable,
              addListener,
              uninstall
            };
          };
        }
      ),
      /***/
      "18e9": (
        /***/
        function(module2, exports, __webpack_require__) {
          var detector = module2.exports = {};
          detector.isIE = function(version2) {
            function isAnyIeVersion() {
              var agent = navigator.userAgent.toLowerCase();
              return agent.indexOf("msie") !== -1 || agent.indexOf("trident") !== -1 || agent.indexOf(" edge/") !== -1;
            }
            if (!isAnyIeVersion()) {
              return false;
            }
            if (!version2) {
              return true;
            }
            var ieVersion = function() {
              var undef, v = 3, div = document.createElement("div"), all3 = div.getElementsByTagName("i");
              do {
                div.innerHTML = "<!--[if gt IE " + ++v + "]><i></i><![endif]-->";
              } while (all3[0]);
              return v > 4 ? v : undef;
            }();
            return version2 === ieVersion;
          };
          detector.isLegacyOpera = function() {
            return !!window.opera;
          };
        }
      ),
      /***/
      "1ca7": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return getDocumentDir;
          });
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return addWindowEventListener;
          });
          __webpack_require__.d(__webpack_exports__, "c", function() {
            return removeWindowEventListener;
          });
          var currentDir = "auto";
          function hasDocument() {
            return typeof document !== "undefined";
          }
          function hasWindow() {
            return typeof window !== "undefined";
          }
          function getDocumentDir() {
            if (!hasDocument()) {
              return currentDir;
            }
            var direction = typeof document.dir !== "undefined" ? document.dir : document.getElementsByTagName("html")[0].getAttribute("dir");
            return direction;
          }
          function addWindowEventListener(event, callback) {
            if (!hasWindow) {
              callback();
              return;
            }
            window.addEventListener(event, callback);
          }
          function removeWindowEventListener(event, callback) {
            if (!hasWindow) {
              return;
            }
            window.removeEventListener(event, callback);
          }
        }
      ),
      /***/
      "214f": (
        /***/
        function(module2, exports, __webpack_require__) {
          __webpack_require__("b0c5");
          var redefine = __webpack_require__("2aba");
          var hide = __webpack_require__("32e9");
          var fails = __webpack_require__("79e5");
          var defined = __webpack_require__("be13");
          var wks = __webpack_require__("2b4c");
          var regexpExec = __webpack_require__("520a");
          var SPECIES = wks("species");
          var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
            var re2 = /./;
            re2.exec = function() {
              var result = [];
              result.groups = { a: "7" };
              return result;
            };
            return "".replace(re2, "$<a>") !== "7";
          });
          var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function() {
            var re2 = /(?:)/;
            var originalExec = re2.exec;
            re2.exec = function() {
              return originalExec.apply(this, arguments);
            };
            var result = "ab".split(re2);
            return result.length === 2 && result[0] === "a" && result[1] === "b";
          }();
          module2.exports = function(KEY, length, exec) {
            var SYMBOL = wks(KEY);
            var DELEGATES_TO_SYMBOL = !fails(function() {
              var O = {};
              O[SYMBOL] = function() {
                return 7;
              };
              return ""[KEY](O) != 7;
            });
            var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function() {
              var execCalled = false;
              var re2 = /a/;
              re2.exec = function() {
                execCalled = true;
                return null;
              };
              if (KEY === "split") {
                re2.constructor = {};
                re2.constructor[SPECIES] = function() {
                  return re2;
                };
              }
              re2[SYMBOL]("");
              return !execCalled;
            }) : void 0;
            if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === "replace" && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === "split" && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
              var nativeRegExpMethod = /./[SYMBOL];
              var fns = exec(
                defined,
                SYMBOL,
                ""[KEY],
                function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
                  if (regexp.exec === regexpExec) {
                    if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                      return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
                    }
                    return { done: true, value: nativeMethod.call(str, regexp, arg2) };
                  }
                  return { done: false };
                }
              );
              var strfn = fns[0];
              var rxfn = fns[1];
              redefine(String.prototype, KEY, strfn);
              hide(
                RegExp.prototype,
                SYMBOL,
                length == 2 ? function(string, arg) {
                  return rxfn.call(string, this, arg);
                } : function(string) {
                  return rxfn.call(string, this);
                }
              );
            }
          };
        }
      ),
      /***/
      "230e": (
        /***/
        function(module2, exports, __webpack_require__) {
          var isObject2 = __webpack_require__("d3f4");
          var document2 = __webpack_require__("7726").document;
          var is = isObject2(document2) && isObject2(document2.createElement);
          module2.exports = function(it) {
            return is ? document2.createElement(it) : {};
          };
        }
      ),
      /***/
      "2350": (
        /***/
        function(module2, exports) {
          module2.exports = function(useSourceMap) {
            var list = [];
            list.toString = function toString3() {
              return this.map(function(item) {
                var content = cssWithMappingToString(item, useSourceMap);
                if (item[2]) {
                  return "@media " + item[2] + "{" + content + "}";
                } else {
                  return content;
                }
              }).join("");
            };
            list.i = function(modules2, mediaQuery) {
              if (typeof modules2 === "string")
                modules2 = [[null, modules2, ""]];
              var alreadyImportedModules = {};
              for (var i = 0; i < this.length; i++) {
                var id = this[i][0];
                if (typeof id === "number")
                  alreadyImportedModules[id] = true;
              }
              for (i = 0; i < modules2.length; i++) {
                var item = modules2[i];
                if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
                  if (mediaQuery && !item[2]) {
                    item[2] = mediaQuery;
                  } else if (mediaQuery) {
                    item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
                  }
                  list.push(item);
                }
              }
            };
            return list;
          };
          function cssWithMappingToString(item, useSourceMap) {
            var content = item[1] || "";
            var cssMapping = item[3];
            if (!cssMapping) {
              return content;
            }
            if (useSourceMap && typeof btoa === "function") {
              var sourceMapping = toComment(cssMapping);
              var sourceURLs = cssMapping.sources.map(function(source) {
                return "/*# sourceURL=" + cssMapping.sourceRoot + source + " */";
              });
              return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
            }
            return [content].join("\n");
          }
          function toComment(sourceMap) {
            var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
            var data = "sourceMappingURL=data:application/json;charset=utf-8;base64," + base64;
            return "/*# " + data + " */";
          }
        }
      ),
      /***/
      "23c6": (
        /***/
        function(module2, exports, __webpack_require__) {
          var cof = __webpack_require__("2d95");
          var TAG = __webpack_require__("2b4c")("toStringTag");
          var ARG = cof(/* @__PURE__ */ function() {
            return arguments;
          }()) == "Arguments";
          var tryGet = function(it, key) {
            try {
              return it[key];
            } catch (e) {
            }
          };
          module2.exports = function(it) {
            var O, T, B;
            return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T = tryGet(O = Object(it), TAG)) == "string" ? T : ARG ? cof(O) : (B = cof(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B;
          };
        }
      ),
      /***/
      "2621": (
        /***/
        function(module2, exports) {
          exports.f = Object.getOwnPropertySymbols;
        }
      ),
      /***/
      "2877": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return normalizeComponent2;
          });
          function normalizeComponent2(scriptExports, render66, staticRenderFns2, functionalTemplate, injectStyles, scopeId, moduleIdentifier, shadowMode) {
            var options = typeof scriptExports === "function" ? scriptExports.options : scriptExports;
            if (render66) {
              options.render = render66;
              options.staticRenderFns = staticRenderFns2;
              options._compiled = true;
            }
            if (functionalTemplate) {
              options.functional = true;
            }
            if (scopeId) {
              options._scopeId = "data-v-" + scopeId;
            }
            var hook;
            if (moduleIdentifier) {
              hook = function(context) {
                context = context || // cached call
                this.$vnode && this.$vnode.ssrContext || // stateful
                this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
                if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
                  context = __VUE_SSR_CONTEXT__;
                }
                if (injectStyles) {
                  injectStyles.call(this, context);
                }
                if (context && context._registeredComponents) {
                  context._registeredComponents.add(moduleIdentifier);
                }
              };
              options._ssrRegister = hook;
            } else if (injectStyles) {
              hook = shadowMode ? function() {
                injectStyles.call(
                  this,
                  (options.functional ? this.parent : this).$root.$options.shadowRoot
                );
              } : injectStyles;
            }
            if (hook) {
              if (options.functional) {
                options._injectStyles = hook;
                var originalRender = options.render;
                options.render = function renderWithStyleInjection(h, context) {
                  hook.call(context);
                  return originalRender(h, context);
                };
              } else {
                var existing = options.beforeCreate;
                options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
              }
            }
            return {
              exports: scriptExports,
              options
            };
          }
        }
      ),
      /***/
      "2aba": (
        /***/
        function(module2, exports, __webpack_require__) {
          var global2 = __webpack_require__("7726");
          var hide = __webpack_require__("32e9");
          var has2 = __webpack_require__("69a8");
          var SRC = __webpack_require__("ca5a")("src");
          var $toString = __webpack_require__("fa5b");
          var TO_STRING = "toString";
          var TPL = ("" + $toString).split(TO_STRING);
          __webpack_require__("8378").inspectSource = function(it) {
            return $toString.call(it);
          };
          (module2.exports = function(O, key, val, safe) {
            var isFunction2 = typeof val == "function";
            if (isFunction2) has2(val, "name") || hide(val, "name", key);
            if (O[key] === val) return;
            if (isFunction2) has2(val, SRC) || hide(val, SRC, O[key] ? "" + O[key] : TPL.join(String(key)));
            if (O === global2) {
              O[key] = val;
            } else if (!safe) {
              delete O[key];
              hide(O, key, val);
            } else if (O[key]) {
              O[key] = val;
            } else {
              hide(O, key, val);
            }
          })(Function.prototype, TO_STRING, function toString3() {
            return typeof this == "function" && this[SRC] || $toString.call(this);
          });
        }
      ),
      /***/
      "2aeb": (
        /***/
        function(module2, exports, __webpack_require__) {
          var anObject = __webpack_require__("cb7c");
          var dPs = __webpack_require__("1495");
          var enumBugKeys = __webpack_require__("e11e");
          var IE_PROTO = __webpack_require__("613b")("IE_PROTO");
          var Empty = function() {
          };
          var PROTOTYPE = "prototype";
          var createDict = function() {
            var iframe = __webpack_require__("230e")("iframe");
            var i = enumBugKeys.length;
            var lt = "<";
            var gt = ">";
            var iframeDocument;
            iframe.style.display = "none";
            __webpack_require__("fab2").appendChild(iframe);
            iframe.src = "javascript:";
            iframeDocument = iframe.contentWindow.document;
            iframeDocument.open();
            iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
            iframeDocument.close();
            createDict = iframeDocument.F;
            while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
            return createDict();
          };
          module2.exports = Object.create || function create2(O, Properties) {
            var result;
            if (O !== null) {
              Empty[PROTOTYPE] = anObject(O);
              result = new Empty();
              Empty[PROTOTYPE] = null;
              result[IE_PROTO] = O;
            } else result = createDict();
            return Properties === void 0 ? result : dPs(result, Properties);
          };
        }
      ),
      /***/
      "2af9": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          (function(global2) {
            __webpack_require__.d(__webpack_exports__, "d", function() {
              return install2;
            });
            __webpack_require__("7f7f");
            __webpack_require__("cadf");
            __webpack_require__("456d");
            __webpack_require__("ac6a");
            var _GridItem_vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("bc21");
            __webpack_require__.d(__webpack_exports__, "a", function() {
              return _GridItem_vue__WEBPACK_IMPORTED_MODULE_4__["a"];
            });
            var _GridLayout_vue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("37c8");
            __webpack_require__.d(__webpack_exports__, "b", function() {
              return _GridLayout_vue__WEBPACK_IMPORTED_MODULE_5__["a"];
            });
            var VueGridLayout = {
              // ResponsiveGridLayout,
              GridLayout: _GridLayout_vue__WEBPACK_IMPORTED_MODULE_5__[
                /* default */
                "a"
              ],
              GridItem: _GridItem_vue__WEBPACK_IMPORTED_MODULE_4__[
                /* default */
                "a"
              ]
            };
            function install2(Vue2) {
              if (install2.installed) return;
              install2.installed = true;
              Object.keys(VueGridLayout).forEach(function(name) {
                Vue2.component(name, VueGridLayout[name]);
              });
            }
            var plugin2 = {
              install: install2
            };
            var GlobalVue2 = null;
            if (typeof window !== "undefined") {
              GlobalVue2 = window.Vue;
            } else if (typeof global2 !== "undefined") {
              GlobalVue2 = global2.Vue;
            }
            if (GlobalVue2) {
              GlobalVue2.use(plugin2);
            }
            __webpack_exports__["c"] = VueGridLayout;
          }).call(this, __webpack_require__("c8ba"));
        }
      ),
      /***/
      "2b4c": (
        /***/
        function(module2, exports, __webpack_require__) {
          var store = __webpack_require__("5537")("wks");
          var uid2 = __webpack_require__("ca5a");
          var Symbol2 = __webpack_require__("7726").Symbol;
          var USE_SYMBOL = typeof Symbol2 == "function";
          var $exports = module2.exports = function(name) {
            return store[name] || (store[name] = USE_SYMBOL && Symbol2[name] || (USE_SYMBOL ? Symbol2 : uid2)("Symbol." + name));
          };
          $exports.store = store;
        }
      ),
      /***/
      "2cef": (
        /***/
        function(module2, exports, __webpack_require__) {
          module2.exports = function() {
            var idCount = 1;
            function generate() {
              return idCount++;
            }
            return {
              generate
            };
          };
        }
      ),
      /***/
      "2d00": (
        /***/
        function(module2, exports) {
          module2.exports = false;
        }
      ),
      /***/
      "2d95": (
        /***/
        function(module2, exports) {
          var toString3 = {}.toString;
          module2.exports = function(it) {
            return toString3.call(it).slice(8, -1);
          };
        }
      ),
      /***/
      "2f21": (
        /***/
        function(module2, exports, __webpack_require__) {
          var fails = __webpack_require__("79e5");
          module2.exports = function(method, arg) {
            return !!method && fails(function() {
              arg ? method.call(null, function() {
              }, 1) : method.call(null);
            });
          };
        }
      ),
      /***/
      "32e9": (
        /***/
        function(module2, exports, __webpack_require__) {
          var dP = __webpack_require__("86cc");
          var createDesc = __webpack_require__("4630");
          module2.exports = __webpack_require__("9e1e") ? function(object, key, value) {
            return dP.f(object, key, createDesc(1, value));
          } : function(object, key, value) {
            object[key] = value;
            return object;
          };
        }
      ),
      /***/
      "37c8": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          var render66 = function() {
            var _vm = this;
            var _h = _vm.$createElement;
            var _c = _vm._self._c || _h;
            return _c("div", { ref: "item", staticClass: "vue-grid-layout", style: _vm.mergedStyle }, [_vm._t("default"), _c("grid-item", { directives: [{ name: "show", rawName: "v-show", value: _vm.isDragging, expression: "isDragging" }], staticClass: "vue-grid-placeholder", attrs: { "x": _vm.placeholder.x, "y": _vm.placeholder.y, "w": _vm.placeholder.w, "h": _vm.placeholder.h, "i": _vm.placeholder.i } })], 2);
          };
          var staticRenderFns2 = [];
          __webpack_require__("8e6e");
          __webpack_require__("cadf");
          __webpack_require__("456d");
          __webpack_require__("f751");
          __webpack_require__("fca0");
          __webpack_require__("ac6a");
          var defineProperty = __webpack_require__("ade3");
          __webpack_require__("c5f6");
          var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
          var external_commonjs_vue_commonjs2_vue_root_Vue_default = /* @__PURE__ */ __webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);
          var utils2 = __webpack_require__("a2b6");
          var responsiveUtils = __webpack_require__("97a7");
          var GridItem = __webpack_require__("bc21");
          var DOM = __webpack_require__("1ca7");
          function ownKeys2(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly) symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target2) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              if (i % 2) {
                ownKeys2(Object(source), true).forEach(function(key) {
                  Object(defineProperty[
                    "a"
                    /* default */
                  ])(target2, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys2(Object(source)).forEach(function(key) {
                  Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }
            return target2;
          }
          var elementResizeDetectorMaker = __webpack_require__("eec4");
          var GridLayoutvue_type_script_lang_js_ = {
            name: "GridLayout",
            provide: function provide() {
              return {
                eventBus: null,
                layout: this
              };
            },
            components: {
              GridItem: GridItem[
                "a"
                /* default */
              ]
            },
            props: {
              // If true, the container height swells and contracts to fit contents
              autoSize: {
                type: Boolean,
                default: true
              },
              colNum: {
                type: Number,
                default: 12
              },
              rowHeight: {
                type: Number,
                default: 150
              },
              maxRows: {
                type: Number,
                default: Infinity
              },
              margin: {
                type: Array,
                default: function _default() {
                  return [10, 10];
                }
              },
              isDraggable: {
                type: Boolean,
                default: true
              },
              isResizable: {
                type: Boolean,
                default: true
              },
              isMirrored: {
                type: Boolean,
                default: false
              },
              isBounded: {
                type: Boolean,
                default: false
              },
              useCssTransforms: {
                type: Boolean,
                default: true
              },
              verticalCompact: {
                type: Boolean,
                default: true
              },
              restoreOnDrag: {
                type: Boolean,
                default: false
              },
              layout: {
                type: Array,
                required: true
              },
              responsive: {
                type: Boolean,
                default: false
              },
              responsiveLayouts: {
                type: Object,
                default: function _default() {
                  return {};
                }
              },
              transformScale: {
                type: Number,
                default: 1
              },
              breakpoints: {
                type: Object,
                default: function _default() {
                  return {
                    lg: 1200,
                    md: 996,
                    sm: 768,
                    xs: 480,
                    xxs: 0
                  };
                }
              },
              cols: {
                type: Object,
                default: function _default() {
                  return {
                    lg: 12,
                    md: 10,
                    sm: 6,
                    xs: 4,
                    xxs: 2
                  };
                }
              },
              preventCollision: {
                type: Boolean,
                default: false
              },
              useStyleCursor: {
                type: Boolean,
                default: true
              }
            },
            data: function data() {
              return {
                width: null,
                mergedStyle: {},
                lastLayoutLength: 0,
                isDragging: false,
                placeholder: {
                  x: 0,
                  y: 0,
                  w: 0,
                  h: 0,
                  i: -1
                },
                layouts: {},
                // array to store all layouts from different breakpoints
                lastBreakpoint: null,
                // store last active breakpoint
                originalLayout: null
                // store original Layout
              };
            },
            created: function created() {
              var self2 = this;
              self2.resizeEventHandler = function(eventType, i, x, y, h, w) {
                self2.resizeEvent(eventType, i, x, y, h, w);
              };
              self2.dragEventHandler = function(eventType, i, x, y, h, w) {
                self2.dragEvent(eventType, i, x, y, h, w);
              };
              self2._provided.eventBus = new external_commonjs_vue_commonjs2_vue_root_Vue_default.a();
              self2.eventBus = self2._provided.eventBus;
              self2.eventBus.$on("resizeEvent", self2.resizeEventHandler);
              self2.eventBus.$on("dragEvent", self2.dragEventHandler);
              self2.$emit("layout-created", self2.layout);
            },
            beforeDestroy: function beforeDestroy2() {
              this.eventBus.$off("resizeEvent", this.resizeEventHandler);
              this.eventBus.$off("dragEvent", this.dragEventHandler);
              this.eventBus.$destroy();
              Object(DOM[
                "c"
                /* removeWindowEventListener */
              ])("resize", this.onWindowResize);
              if (this.erd) {
                this.erd.uninstall(this.$refs.item);
              }
            },
            beforeMount: function beforeMount() {
              this.$emit("layout-before-mount", this.layout);
            },
            mounted: function mounted2() {
              this.$emit("layout-mounted", this.layout);
              this.$nextTick(function() {
                Object(utils2[
                  "l"
                  /* validateLayout */
                ])(this.layout);
                this.originalLayout = this.layout;
                var self2 = this;
                this.$nextTick(function() {
                  self2.initResponsiveFeatures();
                  self2.onWindowResize();
                  Object(DOM[
                    "a"
                    /* addWindowEventListener */
                  ])("resize", self2.onWindowResize);
                  Object(utils2[
                    "c"
                    /* compact */
                  ])(self2.layout, self2.verticalCompact);
                  self2.$emit("layout-updated", self2.layout);
                  self2.updateHeight();
                  self2.$nextTick(function() {
                    this.erd = elementResizeDetectorMaker({
                      strategy: "scroll",
                      //<- For ultra performance.
                      // See https://github.com/wnr/element-resize-detector/issues/110 about callOnAdd.
                      callOnAdd: false
                    });
                    this.erd.listenTo(self2.$refs.item, function() {
                      self2.onWindowResize();
                    });
                  });
                });
              });
            },
            watch: {
              width: function width(newval, oldval) {
                var self2 = this;
                this.$nextTick(function() {
                  var _this = this;
                  this.eventBus.$emit("updateWidth", this.width);
                  if (oldval === null) {
                    this.$nextTick(function() {
                      _this.$emit("layout-ready", self2.layout);
                    });
                  }
                  this.updateHeight();
                });
              },
              layout: function layout() {
                this.layoutUpdate();
              },
              colNum: function colNum(val) {
                this.eventBus.$emit("setColNum", val);
              },
              rowHeight: function rowHeight() {
                this.eventBus.$emit("setRowHeight", this.rowHeight);
              },
              isDraggable: function isDraggable() {
                this.eventBus.$emit("setDraggable", this.isDraggable);
              },
              isResizable: function isResizable() {
                this.eventBus.$emit("setResizable", this.isResizable);
              },
              isBounded: function isBounded() {
                this.eventBus.$emit("setBounded", this.isBounded);
              },
              transformScale: function transformScale() {
                this.eventBus.$emit("setTransformScale", this.transformScale);
              },
              responsive: function responsive() {
                if (!this.responsive) {
                  this.$emit("update:layout", this.originalLayout);
                  this.eventBus.$emit("setColNum", this.colNum);
                }
                this.onWindowResize();
              },
              maxRows: function maxRows() {
                this.eventBus.$emit("setMaxRows", this.maxRows);
              },
              margin: function margin() {
                this.updateHeight();
              }
            },
            methods: {
              layoutUpdate: function layoutUpdate() {
                if (this.layout !== void 0 && this.originalLayout !== null) {
                  if (this.layout.length !== this.originalLayout.length) {
                    var diff = this.findDifference(this.layout, this.originalLayout);
                    if (diff.length > 0) {
                      if (this.layout.length > this.originalLayout.length) {
                        this.originalLayout = this.originalLayout.concat(diff);
                      } else {
                        this.originalLayout = this.originalLayout.filter(function(obj) {
                          return !diff.some(function(obj2) {
                            return obj.i === obj2.i;
                          });
                        });
                      }
                    }
                    this.lastLayoutLength = this.layout.length;
                    this.initResponsiveFeatures();
                  }
                  Object(utils2[
                    "c"
                    /* compact */
                  ])(this.layout, this.verticalCompact);
                  this.eventBus.$emit("updateWidth", this.width);
                  this.updateHeight();
                  this.$emit("layout-updated", this.layout);
                }
              },
              updateHeight: function updateHeight() {
                this.mergedStyle = {
                  height: this.containerHeight()
                };
              },
              onWindowResize: function onWindowResize() {
                if (this.$refs !== null && this.$refs.item !== null && this.$refs.item !== void 0) {
                  this.width = this.$refs.item.offsetWidth;
                }
                this.eventBus.$emit("resizeEvent");
              },
              containerHeight: function containerHeight() {
                if (!this.autoSize) return;
                var containerHeight2 = Object(utils2[
                  "a"
                  /* bottom */
                ])(this.layout) * (this.rowHeight + this.margin[1]) + this.margin[1] + "px";
                return containerHeight2;
              },
              dragEvent: function dragEvent(eventName, id, x, y, h, w) {
                var l = Object(utils2[
                  "f"
                  /* getLayoutItem */
                ])(this.layout, id);
                if (l === void 0 || l === null) {
                  l = {
                    x: 0,
                    y: 0
                  };
                }
                if (eventName === "dragstart" && !this.verticalCompact) {
                  this.positionsBeforeDrag = this.layout.reduce(function(result, _ref) {
                    var i = _ref.i, x2 = _ref.x, y2 = _ref.y;
                    return _objectSpread(_objectSpread({}, result), {}, Object(defineProperty[
                      "a"
                      /* default */
                    ])({}, i, {
                      x: x2,
                      y: y2
                    }));
                  }, {});
                }
                if (eventName === "dragmove" || eventName === "dragstart") {
                  this.placeholder.i = id;
                  this.placeholder.x = l.x;
                  this.placeholder.y = l.y;
                  this.placeholder.w = w;
                  this.placeholder.h = h;
                  this.$nextTick(function() {
                    this.isDragging = true;
                  });
                  this.eventBus.$emit("updateWidth", this.width);
                } else {
                  this.$nextTick(function() {
                    this.isDragging = false;
                  });
                }
                this.layout = Object(utils2[
                  "g"
                  /* moveElement */
                ])(this.layout, l, x, y, true, this.preventCollision);
                if (this.restoreOnDrag) {
                  l.static = true;
                  Object(utils2[
                    "c"
                    /* compact */
                  ])(this.layout, this.verticalCompact, this.positionsBeforeDrag);
                  l.static = false;
                } else {
                  Object(utils2[
                    "c"
                    /* compact */
                  ])(this.layout, this.verticalCompact);
                }
                this.eventBus.$emit("compact");
                this.updateHeight();
                if (eventName === "dragend") {
                  delete this.positionsBeforeDrag;
                  this.$emit("layout-updated", this.layout);
                }
              },
              resizeEvent: function resizeEvent(eventName, id, x, y, h, w) {
                var l = Object(utils2[
                  "f"
                  /* getLayoutItem */
                ])(this.layout, id);
                if (l === void 0 || l === null) {
                  l = {
                    h: 0,
                    w: 0
                  };
                }
                var hasCollisions;
                if (this.preventCollision) {
                  var collisions = Object(utils2[
                    "e"
                    /* getAllCollisions */
                  ])(this.layout, _objectSpread(_objectSpread({}, l), {}, {
                    w,
                    h
                  })).filter(function(layoutItem) {
                    return layoutItem.i !== l.i;
                  });
                  hasCollisions = collisions.length > 0;
                  if (hasCollisions) {
                    var leastX = Infinity, leastY = Infinity;
                    collisions.forEach(function(layoutItem) {
                      if (layoutItem.x > l.x) leastX = Math.min(leastX, layoutItem.x);
                      if (layoutItem.y > l.y) leastY = Math.min(leastY, layoutItem.y);
                    });
                    if (Number.isFinite(leastX)) l.w = leastX - l.x;
                    if (Number.isFinite(leastY)) l.h = leastY - l.y;
                  }
                }
                if (!hasCollisions) {
                  l.w = w;
                  l.h = h;
                }
                if (eventName === "resizestart" || eventName === "resizemove") {
                  this.placeholder.i = id;
                  this.placeholder.x = x;
                  this.placeholder.y = y;
                  this.placeholder.w = l.w;
                  this.placeholder.h = l.h;
                  this.$nextTick(function() {
                    this.isDragging = true;
                  });
                  this.eventBus.$emit("updateWidth", this.width);
                } else {
                  this.$nextTick(function() {
                    this.isDragging = false;
                  });
                }
                if (this.responsive) this.responsiveGridLayout();
                Object(utils2[
                  "c"
                  /* compact */
                ])(this.layout, this.verticalCompact);
                this.eventBus.$emit("compact");
                this.updateHeight();
                if (eventName === "resizeend") this.$emit("layout-updated", this.layout);
              },
              // finds or generates new layouts for set breakpoints
              responsiveGridLayout: function responsiveGridLayout() {
                var newBreakpoint = Object(responsiveUtils[
                  "b"
                  /* getBreakpointFromWidth */
                ])(this.breakpoints, this.width);
                var newCols = Object(responsiveUtils[
                  "c"
                  /* getColsFromBreakpoint */
                ])(newBreakpoint, this.cols);
                if (this.lastBreakpoint != null && !this.layouts[this.lastBreakpoint]) this.layouts[this.lastBreakpoint] = Object(utils2[
                  "b"
                  /* cloneLayout */
                ])(this.layout);
                var layout = Object(responsiveUtils[
                  "a"
                  /* findOrGenerateResponsiveLayout */
                ])(this.originalLayout, this.layouts, this.breakpoints, newBreakpoint, this.lastBreakpoint, newCols, this.verticalCompact);
                this.layouts[newBreakpoint] = layout;
                if (this.lastBreakpoint !== newBreakpoint) {
                  this.$emit("breakpoint-changed", newBreakpoint, layout);
                }
                this.$emit("update:layout", layout);
                this.lastBreakpoint = newBreakpoint;
                this.eventBus.$emit("setColNum", Object(responsiveUtils[
                  "c"
                  /* getColsFromBreakpoint */
                ])(newBreakpoint, this.cols));
              },
              // clear all responsive layouts
              initResponsiveFeatures: function initResponsiveFeatures() {
                this.layouts = Object.assign({}, this.responsiveLayouts);
              },
              // find difference in layouts
              findDifference: function findDifference(layout, originalLayout) {
                var uniqueResultOne = layout.filter(function(obj) {
                  return !originalLayout.some(function(obj2) {
                    return obj.i === obj2.i;
                  });
                });
                var uniqueResultTwo = originalLayout.filter(function(obj) {
                  return !layout.some(function(obj2) {
                    return obj.i === obj2.i;
                  });
                });
                return uniqueResultOne.concat(uniqueResultTwo);
              }
            }
          };
          var components_GridLayoutvue_type_script_lang_js_ = GridLayoutvue_type_script_lang_js_;
          __webpack_require__("e279");
          var componentNormalizer = __webpack_require__("2877");
          var component = Object(componentNormalizer[
            "a"
            /* default */
          ])(
            components_GridLayoutvue_type_script_lang_js_,
            render66,
            staticRenderFns2,
            false,
            null,
            null,
            null
          );
          __webpack_exports__["a"] = component.exports;
        }
      ),
      /***/
      "38fd": (
        /***/
        function(module2, exports, __webpack_require__) {
          var has2 = __webpack_require__("69a8");
          var toObject2 = __webpack_require__("4bf8");
          var IE_PROTO = __webpack_require__("613b")("IE_PROTO");
          var ObjectProto = Object.prototype;
          module2.exports = Object.getPrototypeOf || function(O) {
            O = toObject2(O);
            if (has2(O, IE_PROTO)) return O[IE_PROTO];
            if (typeof O.constructor == "function" && O instanceof O.constructor) {
              return O.constructor.prototype;
            }
            return O instanceof Object ? ObjectProto : null;
          };
        }
      ),
      /***/
      "41a0": (
        /***/
        function(module2, exports, __webpack_require__) {
          var create2 = __webpack_require__("2aeb");
          var descriptor = __webpack_require__("4630");
          var setToStringTag = __webpack_require__("7f20");
          var IteratorPrototype = {};
          __webpack_require__("32e9")(IteratorPrototype, __webpack_require__("2b4c")("iterator"), function() {
            return this;
          });
          module2.exports = function(Constructor, NAME, next) {
            Constructor.prototype = create2(IteratorPrototype, { next: descriptor(1, next) });
            setToStringTag(Constructor, NAME + " Iterator");
          };
        }
      ),
      /***/
      "456d": (
        /***/
        function(module2, exports, __webpack_require__) {
          var toObject2 = __webpack_require__("4bf8");
          var $keys = __webpack_require__("0d58");
          __webpack_require__("5eda")("keys", function() {
            return function keys(it) {
              return $keys(toObject2(it));
            };
          });
        }
      ),
      /***/
      "4588": (
        /***/
        function(module2, exports) {
          var ceil = Math.ceil;
          var floor = Math.floor;
          module2.exports = function(it) {
            return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
          };
        }
      ),
      /***/
      "4630": (
        /***/
        function(module2, exports) {
          module2.exports = function(bitmap, value) {
            return {
              enumerable: !(bitmap & 1),
              configurable: !(bitmap & 2),
              writable: !(bitmap & 4),
              value
            };
          };
        }
      ),
      /***/
      "4917": (
        /***/
        function(module2, exports, __webpack_require__) {
          var anObject = __webpack_require__("cb7c");
          var toLength = __webpack_require__("9def");
          var advanceStringIndex = __webpack_require__("0390");
          var regExpExec = __webpack_require__("5f1b");
          __webpack_require__("214f")("match", 1, function(defined, MATCH, $match, maybeCallNative) {
            return [
              // `String.prototype.match` method
              // https://tc39.github.io/ecma262/#sec-string.prototype.match
              function match(regexp) {
                var O = defined(this);
                var fn = regexp == void 0 ? void 0 : regexp[MATCH];
                return fn !== void 0 ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
              },
              // `RegExp.prototype[@@match]` method
              // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
              function(regexp) {
                var res = maybeCallNative($match, regexp, this);
                if (res.done) return res.value;
                var rx = anObject(regexp);
                var S = String(this);
                if (!rx.global) return regExpExec(rx, S);
                var fullUnicode = rx.unicode;
                rx.lastIndex = 0;
                var A = [];
                var n2 = 0;
                var result;
                while ((result = regExpExec(rx, S)) !== null) {
                  var matchStr = String(result[0]);
                  A[n2] = matchStr;
                  if (matchStr === "") rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
                  n2++;
                }
                return n2 === 0 ? null : A;
              }
            ];
          });
        }
      ),
      /***/
      "499e": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          __webpack_require__.r(__webpack_exports__);
          __webpack_require__.d(__webpack_exports__, "default", function() {
            return (
              /* binding */
              addStylesClient
            );
          });
          function listToStyles(parentId, list) {
            var styles = [];
            var newStyles = {};
            for (var i = 0; i < list.length; i++) {
              var item = list[i];
              var id = item[0];
              var css = item[1];
              var media = item[2];
              var sourceMap = item[3];
              var part = {
                id: parentId + ":" + i,
                css,
                media,
                sourceMap
              };
              if (!newStyles[id]) {
                styles.push(newStyles[id] = { id, parts: [part] });
              } else {
                newStyles[id].parts.push(part);
              }
            }
            return styles;
          }
          var hasDocument = typeof document !== "undefined";
          if (typeof DEBUG !== "undefined" && DEBUG) {
            if (!hasDocument) {
              throw new Error(
                "vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
              );
            }
          }
          var stylesInDom = {
            /*
              [id: number]: {
                id: number,
                refs: number,
                parts: Array<(obj?: StyleObjectPart) => void>
              }
            */
          };
          var head = hasDocument && (document.head || document.getElementsByTagName("head")[0]);
          var singletonElement = null;
          var singletonCounter = 0;
          var isProduction = false;
          var noop2 = function() {
          };
          var options = null;
          var ssrIdKey = "data-vue-ssr-id";
          var isOldIE = typeof navigator !== "undefined" && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase());
          function addStylesClient(parentId, list, _isProduction, _options) {
            isProduction = _isProduction;
            options = _options || {};
            var styles = listToStyles(parentId, list);
            addStylesToDom(styles);
            return function update(newList) {
              var mayRemove = [];
              for (var i = 0; i < styles.length; i++) {
                var item = styles[i];
                var domStyle = stylesInDom[item.id];
                domStyle.refs--;
                mayRemove.push(domStyle);
              }
              if (newList) {
                styles = listToStyles(parentId, newList);
                addStylesToDom(styles);
              } else {
                styles = [];
              }
              for (var i = 0; i < mayRemove.length; i++) {
                var domStyle = mayRemove[i];
                if (domStyle.refs === 0) {
                  for (var j = 0; j < domStyle.parts.length; j++) {
                    domStyle.parts[j]();
                  }
                  delete stylesInDom[domStyle.id];
                }
              }
            };
          }
          function addStylesToDom(styles) {
            for (var i = 0; i < styles.length; i++) {
              var item = styles[i];
              var domStyle = stylesInDom[item.id];
              if (domStyle) {
                domStyle.refs++;
                for (var j = 0; j < domStyle.parts.length; j++) {
                  domStyle.parts[j](item.parts[j]);
                }
                for (; j < item.parts.length; j++) {
                  domStyle.parts.push(addStyle(item.parts[j]));
                }
                if (domStyle.parts.length > item.parts.length) {
                  domStyle.parts.length = item.parts.length;
                }
              } else {
                var parts = [];
                for (var j = 0; j < item.parts.length; j++) {
                  parts.push(addStyle(item.parts[j]));
                }
                stylesInDom[item.id] = { id: item.id, refs: 1, parts };
              }
            }
          }
          function createStyleElement() {
            var styleElement = document.createElement("style");
            styleElement.type = "text/css";
            head.appendChild(styleElement);
            return styleElement;
          }
          function addStyle(obj) {
            var update, remove2;
            var styleElement = document.querySelector("style[" + ssrIdKey + '~="' + obj.id + '"]');
            if (styleElement) {
              if (isProduction) {
                return noop2;
              } else {
                styleElement.parentNode.removeChild(styleElement);
              }
            }
            if (isOldIE) {
              var styleIndex = singletonCounter++;
              styleElement = singletonElement || (singletonElement = createStyleElement());
              update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
              remove2 = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
            } else {
              styleElement = createStyleElement();
              update = applyToTag.bind(null, styleElement);
              remove2 = function() {
                styleElement.parentNode.removeChild(styleElement);
              };
            }
            update(obj);
            return function updateStyle2(newObj) {
              if (newObj) {
                if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
                  return;
                }
                update(obj = newObj);
              } else {
                remove2();
              }
            };
          }
          var replaceText = /* @__PURE__ */ function() {
            var textStore = [];
            return function(index2, replacement) {
              textStore[index2] = replacement;
              return textStore.filter(Boolean).join("\n");
            };
          }();
          function applyToSingletonTag(styleElement, index2, remove2, obj) {
            var css = remove2 ? "" : obj.css;
            if (styleElement.styleSheet) {
              styleElement.styleSheet.cssText = replaceText(index2, css);
            } else {
              var cssNode = document.createTextNode(css);
              var childNodes = styleElement.childNodes;
              if (childNodes[index2]) styleElement.removeChild(childNodes[index2]);
              if (childNodes.length) {
                styleElement.insertBefore(cssNode, childNodes[index2]);
              } else {
                styleElement.appendChild(cssNode);
              }
            }
          }
          function applyToTag(styleElement, obj) {
            var css = obj.css;
            var media = obj.media;
            var sourceMap = obj.sourceMap;
            if (media) {
              styleElement.setAttribute("media", media);
            }
            if (options.ssrId) {
              styleElement.setAttribute(ssrIdKey, obj.id);
            }
            if (sourceMap) {
              css += "\n/*# sourceURL=" + sourceMap.sources[0] + " */";
              css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
            }
            if (styleElement.styleSheet) {
              styleElement.styleSheet.cssText = css;
            } else {
              while (styleElement.firstChild) {
                styleElement.removeChild(styleElement.firstChild);
              }
              styleElement.appendChild(document.createTextNode(css));
            }
          }
        }
      ),
      /***/
      "49ad": (
        /***/
        function(module2, exports, __webpack_require__) {
          module2.exports = function(idHandler) {
            var eventListeners = {};
            function getListeners(element) {
              var id = idHandler.get(element);
              if (id === void 0) {
                return [];
              }
              return eventListeners[id] || [];
            }
            function addListener(element, listener) {
              var id = idHandler.get(element);
              if (!eventListeners[id]) {
                eventListeners[id] = [];
              }
              eventListeners[id].push(listener);
            }
            function removeListener(element, listener) {
              var listeners = getListeners(element);
              for (var i = 0, len = listeners.length; i < len; ++i) {
                if (listeners[i] === listener) {
                  listeners.splice(i, 1);
                  break;
                }
              }
            }
            function removeAllListeners(element) {
              var listeners = getListeners(element);
              if (!listeners) {
                return;
              }
              listeners.length = 0;
            }
            return {
              get: getListeners,
              add: addListener,
              removeListener,
              removeAllListeners
            };
          };
        }
      ),
      /***/
      "4bf8": (
        /***/
        function(module2, exports, __webpack_require__) {
          var defined = __webpack_require__("be13");
          module2.exports = function(it) {
            return Object(defined(it));
          };
        }
      ),
      /***/
      "5058": (
        /***/
        function(module2, exports, __webpack_require__) {
          module2.exports = function(options) {
            var idGenerator = options.idGenerator;
            var getState = options.stateHandler.getState;
            function getId(element) {
              var state = getState(element);
              if (state && state.id !== void 0) {
                return state.id;
              }
              return null;
            }
            function setId(element) {
              var state = getState(element);
              if (!state) {
                throw new Error("setId required the element to have a resize detection state.");
              }
              var id = idGenerator.generate();
              state.id = id;
              return id;
            }
            return {
              get: getId,
              set: setId
            };
          };
        }
      ),
      /***/
      "50bf": (
        /***/
        function(module2, exports, __webpack_require__) {
          var utils2 = module2.exports = {};
          utils2.getOption = getOption;
          function getOption(options, name, defaultValue) {
            var value = options[name];
            if ((value === void 0 || value === null) && defaultValue !== void 0) {
              return defaultValue;
            }
            return value;
          }
        }
      ),
      /***/
      "520a": (
        /***/
        function(module2, exports, __webpack_require__) {
          var regexpFlags = __webpack_require__("0bfb");
          var nativeExec = RegExp.prototype.exec;
          var nativeReplace = String.prototype.replace;
          var patchedExec = nativeExec;
          var LAST_INDEX = "lastIndex";
          var UPDATES_LAST_INDEX_WRONG = function() {
            var re1 = /a/, re2 = /b*/g;
            nativeExec.call(re1, "a");
            nativeExec.call(re2, "a");
            return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
          }();
          var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
          var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;
          if (PATCH) {
            patchedExec = function exec(str) {
              var re2 = this;
              var lastIndex, reCopy, match, i;
              if (NPCG_INCLUDED) {
                reCopy = new RegExp("^" + re2.source + "$(?!\\s)", regexpFlags.call(re2));
              }
              if (UPDATES_LAST_INDEX_WRONG) lastIndex = re2[LAST_INDEX];
              match = nativeExec.call(re2, str);
              if (UPDATES_LAST_INDEX_WRONG && match) {
                re2[LAST_INDEX] = re2.global ? match.index + match[0].length : lastIndex;
              }
              if (NPCG_INCLUDED && match && match.length > 1) {
                nativeReplace.call(match[0], reCopy, function() {
                  for (i = 1; i < arguments.length - 2; i++) {
                    if (arguments[i] === void 0) match[i] = void 0;
                  }
                });
              }
              return match;
            };
          }
          module2.exports = patchedExec;
        }
      ),
      /***/
      "52a7": (
        /***/
        function(module2, exports) {
          exports.f = {}.propertyIsEnumerable;
        }
      ),
      /***/
      "5537": (
        /***/
        function(module2, exports, __webpack_require__) {
          var core = __webpack_require__("8378");
          var global2 = __webpack_require__("7726");
          var SHARED = "__core-js_shared__";
          var store = global2[SHARED] || (global2[SHARED] = {});
          (module2.exports = function(key, value) {
            return store[key] || (store[key] = value !== void 0 ? value : {});
          })("versions", []).push({
            version: core.version,
            mode: __webpack_require__("2d00") ? "pure" : "global",
            copyright: "© 2020 Denis Pushkarev (zloirock.ru)"
          });
        }
      ),
      /***/
      "55dd": (
        /***/
        function(module2, exports, __webpack_require__) {
          var $export = __webpack_require__("5ca1");
          var aFunction = __webpack_require__("d8e8");
          var toObject2 = __webpack_require__("4bf8");
          var fails = __webpack_require__("79e5");
          var $sort = [].sort;
          var test2 = [1, 2, 3];
          $export($export.P + $export.F * (fails(function() {
            test2.sort(void 0);
          }) || !fails(function() {
            test2.sort(null);
          }) || !__webpack_require__("2f21")($sort)), "Array", {
            // 22.1.3.25 Array.prototype.sort(comparefn)
            sort: function sort(comparefn) {
              return comparefn === void 0 ? $sort.call(toObject2(this)) : $sort.call(toObject2(this), aFunction(comparefn));
            }
          });
        }
      ),
      /***/
      "5be5": (
        /***/
        function(module2, exports, __webpack_require__) {
          module2.exports = function(options) {
            var getState = options.stateHandler.getState;
            function isDetectable(element) {
              var state = getState(element);
              return state && !!state.isDetectable;
            }
            function markAsDetectable(element) {
              getState(element).isDetectable = true;
            }
            function isBusy(element) {
              return !!getState(element).busy;
            }
            function markBusy(element, busy) {
              getState(element).busy = !!busy;
            }
            return {
              isDetectable,
              markAsDetectable,
              isBusy,
              markBusy
            };
          };
        }
      ),
      /***/
      "5ca1": (
        /***/
        function(module2, exports, __webpack_require__) {
          var global2 = __webpack_require__("7726");
          var core = __webpack_require__("8378");
          var hide = __webpack_require__("32e9");
          var redefine = __webpack_require__("2aba");
          var ctx = __webpack_require__("9b43");
          var PROTOTYPE = "prototype";
          var $export = function(type, name, source) {
            var IS_FORCED = type & $export.F;
            var IS_GLOBAL = type & $export.G;
            var IS_STATIC = type & $export.S;
            var IS_PROTO = type & $export.P;
            var IS_BIND = type & $export.B;
            var target2 = IS_GLOBAL ? global2 : IS_STATIC ? global2[name] || (global2[name] = {}) : (global2[name] || {})[PROTOTYPE];
            var exports2 = IS_GLOBAL ? core : core[name] || (core[name] = {});
            var expProto = exports2[PROTOTYPE] || (exports2[PROTOTYPE] = {});
            var key, own, out, exp;
            if (IS_GLOBAL) source = name;
            for (key in source) {
              own = !IS_FORCED && target2 && target2[key] !== void 0;
              out = (own ? target2 : source)[key];
              exp = IS_BIND && own ? ctx(out, global2) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
              if (target2) redefine(target2, key, out, type & $export.U);
              if (exports2[key] != out) hide(exports2, key, exp);
              if (IS_PROTO && expProto[key] != out) expProto[key] = out;
            }
          };
          global2.core = core;
          $export.F = 1;
          $export.G = 2;
          $export.S = 4;
          $export.P = 8;
          $export.B = 16;
          $export.W = 32;
          $export.U = 64;
          $export.R = 128;
          module2.exports = $export;
        }
      ),
      /***/
      "5dbc": (
        /***/
        function(module2, exports, __webpack_require__) {
          var isObject2 = __webpack_require__("d3f4");
          var setPrototypeOf2 = __webpack_require__("8b97").set;
          module2.exports = function(that, target2, C) {
            var S = target2.constructor;
            var P;
            if (S !== C && typeof S == "function" && (P = S.prototype) !== C.prototype && isObject2(P) && setPrototypeOf2) {
              setPrototypeOf2(that, P);
            }
            return that;
          };
        }
      ),
      /***/
      "5ed4": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          __webpack_require__("6e21");
        }
      ),
      /***/
      "5eda": (
        /***/
        function(module2, exports, __webpack_require__) {
          var $export = __webpack_require__("5ca1");
          var core = __webpack_require__("8378");
          var fails = __webpack_require__("79e5");
          module2.exports = function(KEY, exec) {
            var fn = (core.Object || {})[KEY] || Object[KEY];
            var exp = {};
            exp[KEY] = exec(fn);
            $export($export.S + $export.F * fails(function() {
              fn(1);
            }), "Object", exp);
          };
        }
      ),
      /***/
      "5f1b": (
        /***/
        function(module2, exports, __webpack_require__) {
          var classof = __webpack_require__("23c6");
          var builtinExec = RegExp.prototype.exec;
          module2.exports = function(R, S) {
            var exec = R.exec;
            if (typeof exec === "function") {
              var result = exec.call(R, S);
              if (typeof result !== "object") {
                throw new TypeError("RegExp exec method returned something other than an Object or null");
              }
              return result;
            }
            if (classof(R) !== "RegExp") {
              throw new TypeError("RegExp#exec called on incompatible receiver");
            }
            return builtinExec.call(R, S);
          };
        }
      ),
      /***/
      "613b": (
        /***/
        function(module2, exports, __webpack_require__) {
          var shared = __webpack_require__("5537")("keys");
          var uid2 = __webpack_require__("ca5a");
          module2.exports = function(key) {
            return shared[key] || (shared[key] = uid2(key));
          };
        }
      ),
      /***/
      "626a": (
        /***/
        function(module2, exports, __webpack_require__) {
          var cof = __webpack_require__("2d95");
          module2.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
            return cof(it) == "String" ? it.split("") : Object(it);
          };
        }
      ),
      /***/
      "6821": (
        /***/
        function(module2, exports, __webpack_require__) {
          var IObject = __webpack_require__("626a");
          var defined = __webpack_require__("be13");
          module2.exports = function(it) {
            return IObject(defined(it));
          };
        }
      ),
      /***/
      "69a8": (
        /***/
        function(module2, exports) {
          var hasOwnProperty2 = {}.hasOwnProperty;
          module2.exports = function(it, key) {
            return hasOwnProperty2.call(it, key);
          };
        }
      ),
      /***/
      "6a99": (
        /***/
        function(module2, exports, __webpack_require__) {
          var isObject2 = __webpack_require__("d3f4");
          module2.exports = function(it, S) {
            if (!isObject2(it)) return it;
            var fn, val;
            if (S && typeof (fn = it.toString) == "function" && !isObject2(val = fn.call(it))) return val;
            if (typeof (fn = it.valueOf) == "function" && !isObject2(val = fn.call(it))) return val;
            if (!S && typeof (fn = it.toString) == "function" && !isObject2(val = fn.call(it))) return val;
            throw TypeError("Can't convert object to primitive value");
          };
        }
      ),
      /***/
      "6e21": (
        /***/
        function(module2, exports, __webpack_require__) {
          var content = __webpack_require__("9cbe");
          if (typeof content === "string") content = [[module2.i, content, ""]];
          if (content.locals) module2.exports = content.locals;
          var add2 = __webpack_require__("499e").default;
          add2("3cbd0c21", content, true, { "sourceMap": false, "shadowMode": false });
        }
      ),
      /***/
      "7333": (
        /***/
        function(module2, exports, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("9e1e");
          var getKeys = __webpack_require__("0d58");
          var gOPS = __webpack_require__("2621");
          var pIE = __webpack_require__("52a7");
          var toObject2 = __webpack_require__("4bf8");
          var IObject = __webpack_require__("626a");
          var $assign = Object.assign;
          module2.exports = !$assign || __webpack_require__("79e5")(function() {
            var A = {};
            var B = {};
            var S = Symbol();
            var K = "abcdefghijklmnopqrst";
            A[S] = 7;
            K.split("").forEach(function(k) {
              B[k] = k;
            });
            return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join("") != K;
          }) ? function assign2(target2, source) {
            var T = toObject2(target2);
            var aLen = arguments.length;
            var index2 = 1;
            var getSymbols = gOPS.f;
            var isEnum = pIE.f;
            while (aLen > index2) {
              var S = IObject(arguments[index2++]);
              var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
              var length = keys.length;
              var j = 0;
              var key;
              while (length > j) {
                key = keys[j++];
                if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
              }
            }
            return T;
          } : $assign;
        }
      ),
      /***/
      "7726": (
        /***/
        function(module2, exports) {
          var global2 = module2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
          if (typeof __g == "number") __g = global2;
        }
      ),
      /***/
      "77f1": (
        /***/
        function(module2, exports, __webpack_require__) {
          var toInteger = __webpack_require__("4588");
          var max2 = Math.max;
          var min2 = Math.min;
          module2.exports = function(index2, length) {
            index2 = toInteger(index2);
            return index2 < 0 ? max2(index2 + length, 0) : min2(index2, length);
          };
        }
      ),
      /***/
      "79e5": (
        /***/
        function(module2, exports) {
          module2.exports = function(exec) {
            try {
              return !!exec();
            } catch (e) {
              return true;
            }
          };
        }
      ),
      /***/
      "7f20": (
        /***/
        function(module2, exports, __webpack_require__) {
          var def2 = __webpack_require__("86cc").f;
          var has2 = __webpack_require__("69a8");
          var TAG = __webpack_require__("2b4c")("toStringTag");
          module2.exports = function(it, tag, stat) {
            if (it && !has2(it = stat ? it : it.prototype, TAG)) def2(it, TAG, { configurable: true, value: tag });
          };
        }
      ),
      /***/
      "7f7f": (
        /***/
        function(module2, exports, __webpack_require__) {
          var dP = __webpack_require__("86cc").f;
          var FProto = Function.prototype;
          var nameRE = /^\s*function ([^ (]*)/;
          var NAME = "name";
          NAME in FProto || __webpack_require__("9e1e") && dP(FProto, NAME, {
            configurable: true,
            get: function() {
              try {
                return ("" + this).match(nameRE)[1];
              } catch (e) {
                return "";
              }
            }
          });
        }
      ),
      /***/
      "8378": (
        /***/
        function(module2, exports) {
          var core = module2.exports = { version: "2.6.12" };
          if (typeof __e == "number") __e = core;
        }
      ),
      /***/
      "84f2": (
        /***/
        function(module2, exports) {
          module2.exports = {};
        }
      ),
      /***/
      "86cc": (
        /***/
        function(module2, exports, __webpack_require__) {
          var anObject = __webpack_require__("cb7c");
          var IE8_DOM_DEFINE = __webpack_require__("c69a");
          var toPrimitive = __webpack_require__("6a99");
          var dP = Object.defineProperty;
          exports.f = __webpack_require__("9e1e") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
            anObject(O);
            P = toPrimitive(P, true);
            anObject(Attributes);
            if (IE8_DOM_DEFINE) try {
              return dP(O, P, Attributes);
            } catch (e) {
            }
            if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
            if ("value" in Attributes) O[P] = Attributes.value;
            return O;
          };
        }
      ),
      /***/
      "8b97": (
        /***/
        function(module2, exports, __webpack_require__) {
          var isObject2 = __webpack_require__("d3f4");
          var anObject = __webpack_require__("cb7c");
          var check = function(O, proto) {
            anObject(O);
            if (!isObject2(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
          };
          module2.exports = {
            set: Object.setPrototypeOf || ("__proto__" in {} ? (
              // eslint-disable-line
              function(test2, buggy, set2) {
                try {
                  set2 = __webpack_require__("9b43")(Function.call, __webpack_require__("11e9").f(Object.prototype, "__proto__").set, 2);
                  set2(test2, []);
                  buggy = !(test2 instanceof Array);
                } catch (e) {
                  buggy = true;
                }
                return function setPrototypeOf2(O, proto) {
                  check(O, proto);
                  if (buggy) O.__proto__ = proto;
                  else set2(O, proto);
                  return O;
                };
              }({}, false)
            ) : void 0),
            check
          };
        }
      ),
      /***/
      "8bbf": (
        /***/
        function(module2, exports) {
          module2.exports = /* @__PURE__ */ requireVue_runtime_common();
        }
      ),
      /***/
      "8e6e": (
        /***/
        function(module2, exports, __webpack_require__) {
          var $export = __webpack_require__("5ca1");
          var ownKeys2 = __webpack_require__("990b");
          var toIObject = __webpack_require__("6821");
          var gOPD = __webpack_require__("11e9");
          var createProperty = __webpack_require__("f1ae");
          $export($export.S, "Object", {
            getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
              var O = toIObject(object);
              var getDesc = gOPD.f;
              var keys = ownKeys2(O);
              var result = {};
              var i = 0;
              var key, desc;
              while (keys.length > i) {
                desc = getDesc(O, key = keys[i++]);
                if (desc !== void 0) createProperty(result, key, desc);
              }
              return result;
            }
          });
        }
      ),
      /***/
      "9093": (
        /***/
        function(module2, exports, __webpack_require__) {
          var $keys = __webpack_require__("ce10");
          var hiddenKeys = __webpack_require__("e11e").concat("length", "prototype");
          exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
            return $keys(O, hiddenKeys);
          };
        }
      ),
      /***/
      "97a7": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return getBreakpointFromWidth;
          });
          __webpack_require__.d(__webpack_exports__, "c", function() {
            return getColsFromBreakpoint;
          });
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return findOrGenerateResponsiveLayout;
          });
          __webpack_require__("55dd");
          __webpack_require__("ac6a");
          __webpack_require__("cadf");
          __webpack_require__("456d");
          var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("a2b6");
          function getBreakpointFromWidth(breakpoints, width) {
            var sorted = sortBreakpoints(breakpoints);
            var matching = sorted[0];
            for (var i = 1, len = sorted.length; i < len; i++) {
              var breakpointName = sorted[i];
              if (width > breakpoints[breakpointName]) matching = breakpointName;
            }
            return matching;
          }
          function getColsFromBreakpoint(breakpoint, cols) {
            if (!cols[breakpoint]) {
              throw new Error("ResponsiveGridLayout: `cols` entry for breakpoint " + breakpoint + " is missing!");
            }
            return cols[breakpoint];
          }
          function findOrGenerateResponsiveLayout(orgLayout, layouts, breakpoints, breakpoint, lastBreakpoint, cols, verticalCompact) {
            if (layouts[breakpoint]) return Object(_utils__WEBPACK_IMPORTED_MODULE_4__[
              /* cloneLayout */
              "b"
            ])(layouts[breakpoint]);
            var layout = orgLayout;
            var breakpointsSorted = sortBreakpoints(breakpoints);
            var breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));
            for (var i = 0, len = breakpointsAbove.length; i < len; i++) {
              var b = breakpointsAbove[i];
              if (layouts[b]) {
                layout = layouts[b];
                break;
              }
            }
            layout = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[
              /* cloneLayout */
              "b"
            ])(layout || []);
            return Object(_utils__WEBPACK_IMPORTED_MODULE_4__[
              /* compact */
              "c"
            ])(Object(_utils__WEBPACK_IMPORTED_MODULE_4__[
              /* correctBounds */
              "d"
            ])(layout, {
              cols
            }), verticalCompact);
          }
          function sortBreakpoints(breakpoints) {
            var keys = Object.keys(breakpoints);
            return keys.sort(function(a, b) {
              return breakpoints[a] - breakpoints[b];
            });
          }
        }
      ),
      /***/
      "990b": (
        /***/
        function(module2, exports, __webpack_require__) {
          var gOPN = __webpack_require__("9093");
          var gOPS = __webpack_require__("2621");
          var anObject = __webpack_require__("cb7c");
          var Reflect2 = __webpack_require__("7726").Reflect;
          module2.exports = Reflect2 && Reflect2.ownKeys || function ownKeys2(it) {
            var keys = gOPN.f(anObject(it));
            var getSymbols = gOPS.f;
            return getSymbols ? keys.concat(getSymbols(it)) : keys;
          };
        }
      ),
      /***/
      "9b43": (
        /***/
        function(module2, exports, __webpack_require__) {
          var aFunction = __webpack_require__("d8e8");
          module2.exports = function(fn, that, length) {
            aFunction(fn);
            if (that === void 0) return fn;
            switch (length) {
              case 1:
                return function(a) {
                  return fn.call(that, a);
                };
              case 2:
                return function(a, b) {
                  return fn.call(that, a, b);
                };
              case 3:
                return function(a, b, c) {
                  return fn.call(that, a, b, c);
                };
            }
            return function() {
              return fn.apply(that, arguments);
            };
          };
        }
      ),
      /***/
      "9c6c": (
        /***/
        function(module2, exports, __webpack_require__) {
          var UNSCOPABLES = __webpack_require__("2b4c")("unscopables");
          var ArrayProto = Array.prototype;
          if (ArrayProto[UNSCOPABLES] == void 0) __webpack_require__("32e9")(ArrayProto, UNSCOPABLES, {});
          module2.exports = function(key) {
            ArrayProto[UNSCOPABLES][key] = true;
          };
        }
      ),
      /***/
      "9cbe": (
        /***/
        function(module2, exports, __webpack_require__) {
          exports = module2.exports = __webpack_require__("2350")(false);
          exports.push([module2.i, '.vue-grid-item{-webkit-transition:all .2s ease;transition:all .2s ease;-webkit-transition-property:left,top,right;transition-property:left,top,right}.vue-grid-item.no-touch{-ms-touch-action:none;touch-action:none}.vue-grid-item.cssTransforms{-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;left:0;right:auto}.vue-grid-item.cssTransforms.render-rtl{left:auto;right:0}.vue-grid-item.resizing{opacity:.6;z-index:3}.vue-grid-item.vue-draggable-dragging{-webkit-transition:none;transition:none;z-index:3}.vue-grid-item.vue-grid-placeholder{background:red;opacity:.2;-webkit-transition-duration:.1s;transition-duration:.1s;z-index:2;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none}.vue-grid-item>.vue-resizable-handle{position:absolute;width:20px;height:20px;bottom:0;right:0;background:url("data:image/svg+xml;base64,PHN2ZyBzdHlsZT0iYmFja2dyb3VuZC1jb2xvcjojZmZmZmZmMDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjYiIGhlaWdodD0iNiI+PHBhdGggZD0iTTYgNkgwVjQuMmg0LjJWMEg2djZ6IiBvcGFjaXR5PSIuMzAyIi8+PC9zdmc+");background-position:100% 100%;padding:0 3px 3px 0;background-repeat:no-repeat;background-origin:content-box;-webkit-box-sizing:border-box;box-sizing:border-box;cursor:se-resize}.vue-grid-item>.vue-rtl-resizable-handle{bottom:0;left:0;background:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAiIGhlaWdodD0iMTAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0ibm9uZSIgZD0iTS0xLTFoMTJ2MTJILTF6Ii8+PGc+PHBhdGggc3Ryb2tlLWxpbmVjYXA9InVuZGVmaW5lZCIgc3Ryb2tlLWxpbmVqb2luPSJ1bmRlZmluZWQiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2U9IiMwMDAiIGZpbGw9Im5vbmUiIGQ9Ik0xNDQuODIxLTM4LjM5M2wtMjAuMzU3LTMxLjc4NSIvPjxwYXRoIHN0cm9rZT0iIzY2NiIgc3Ryb2tlLWxpbmVjYXA9InVuZGVmaW5lZCIgc3Ryb2tlLWxpbmVqb2luPSJ1bmRlZmluZWQiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSIgZD0iTS45NDctLjAxOHY5LjEyNU0tLjY1NiA5aDEwLjczIi8+PC9nPjwvc3ZnPg==);background-position:0 100%;padding-left:3px;background-repeat:no-repeat;background-origin:content-box;cursor:sw-resize;right:auto}.vue-grid-item.disable-userselect{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}', ""]);
        }
      ),
      /***/
      "9def": (
        /***/
        function(module2, exports, __webpack_require__) {
          var toInteger = __webpack_require__("4588");
          var min2 = Math.min;
          module2.exports = function(it) {
            return it > 0 ? min2(toInteger(it), 9007199254740991) : 0;
          };
        }
      ),
      /***/
      "9e1e": (
        /***/
        function(module2, exports, __webpack_require__) {
          module2.exports = !__webpack_require__("79e5")(function() {
            return Object.defineProperty({}, "a", { get: function() {
              return 7;
            } }).a != 7;
          });
        }
      ),
      /***/
      "a2b6": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return bottom;
          });
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return cloneLayout;
          });
          __webpack_require__.d(__webpack_exports__, "c", function() {
            return compact;
          });
          __webpack_require__.d(__webpack_exports__, "d", function() {
            return correctBounds;
          });
          __webpack_require__.d(__webpack_exports__, "f", function() {
            return getLayoutItem;
          });
          __webpack_require__.d(__webpack_exports__, "e", function() {
            return getAllCollisions;
          });
          __webpack_require__.d(__webpack_exports__, "g", function() {
            return moveElement;
          });
          __webpack_require__.d(__webpack_exports__, "j", function() {
            return setTransform;
          });
          __webpack_require__.d(__webpack_exports__, "k", function() {
            return setTransformRtl;
          });
          __webpack_require__.d(__webpack_exports__, "h", function() {
            return setTopLeft;
          });
          __webpack_require__.d(__webpack_exports__, "i", function() {
            return setTopRight;
          });
          __webpack_require__.d(__webpack_exports__, "l", function() {
            return validateLayout;
          });
          __webpack_require__("a481");
          __webpack_require__("cadf");
          __webpack_require__("456d");
          __webpack_require__("ac6a");
          __webpack_require__("55dd");
          function bottom(layout) {
            var max2 = 0, bottomY;
            for (var i = 0, len = layout.length; i < len; i++) {
              bottomY = layout[i].y + layout[i].h;
              if (bottomY > max2) max2 = bottomY;
            }
            return max2;
          }
          function cloneLayout(layout) {
            var newLayout = Array(layout.length);
            for (var i = 0, len = layout.length; i < len; i++) {
              newLayout[i] = cloneLayoutItem(layout[i]);
            }
            return newLayout;
          }
          function cloneLayoutItem(layoutItem) {
            return JSON.parse(JSON.stringify(layoutItem));
          }
          function collides(l1, l2) {
            if (l1 === l2) return false;
            if (l1.x + l1.w <= l2.x) return false;
            if (l1.x >= l2.x + l2.w) return false;
            if (l1.y + l1.h <= l2.y) return false;
            if (l1.y >= l2.y + l2.h) return false;
            return true;
          }
          function compact(layout, verticalCompact, minPositions) {
            var compareWith = getStatics(layout);
            var sorted = sortLayoutItemsByRowCol(layout);
            var out = Array(layout.length);
            for (var i = 0, len = sorted.length; i < len; i++) {
              var l = sorted[i];
              if (!l.static) {
                l = compactItem(compareWith, l, verticalCompact, minPositions);
                compareWith.push(l);
              }
              out[layout.indexOf(l)] = l;
              l.moved = false;
            }
            return out;
          }
          function compactItem(compareWith, l, verticalCompact, minPositions) {
            if (verticalCompact) {
              while (l.y > 0 && !getFirstCollision(compareWith, l)) {
                l.y--;
              }
            } else if (minPositions) {
              var minY = minPositions[l.i].y;
              while (l.y > minY && !getFirstCollision(compareWith, l)) {
                l.y--;
              }
            }
            var collides2;
            while (collides2 = getFirstCollision(compareWith, l)) {
              l.y = collides2.y + collides2.h;
            }
            return l;
          }
          function correctBounds(layout, bounds) {
            var collidesWith = getStatics(layout);
            for (var i = 0, len = layout.length; i < len; i++) {
              var l = layout[i];
              if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w;
              if (l.x < 0) {
                l.x = 0;
                l.w = bounds.cols;
              }
              if (!l.static) collidesWith.push(l);
              else {
                while (getFirstCollision(collidesWith, l)) {
                  l.y++;
                }
              }
            }
            return layout;
          }
          function getLayoutItem(layout, id) {
            for (var i = 0, len = layout.length; i < len; i++) {
              if (layout[i].i === id) return layout[i];
            }
          }
          function getFirstCollision(layout, layoutItem) {
            for (var i = 0, len = layout.length; i < len; i++) {
              if (collides(layout[i], layoutItem)) return layout[i];
            }
          }
          function getAllCollisions(layout, layoutItem) {
            return layout.filter(function(l) {
              return collides(l, layoutItem);
            });
          }
          function getStatics(layout) {
            return layout.filter(function(l) {
              return l.static;
            });
          }
          function moveElement(layout, l, x, y, isUserAction, preventCollision) {
            if (l.static) return layout;
            var oldX = l.x;
            var oldY = l.y;
            var movingUp = y && l.y > y;
            if (typeof x === "number") l.x = x;
            if (typeof y === "number") l.y = y;
            l.moved = true;
            var sorted = sortLayoutItemsByRowCol(layout);
            if (movingUp) sorted = sorted.reverse();
            var collisions = getAllCollisions(sorted, l);
            if (preventCollision && collisions.length) {
              l.x = oldX;
              l.y = oldY;
              l.moved = false;
              return layout;
            }
            for (var i = 0, len = collisions.length; i < len; i++) {
              var collision = collisions[i];
              if (collision.moved) continue;
              if (l.y > collision.y && l.y - collision.y > collision.h / 4) continue;
              if (collision.static) {
                layout = moveElementAwayFromCollision(layout, collision, l, isUserAction);
              } else {
                layout = moveElementAwayFromCollision(layout, l, collision, isUserAction);
              }
            }
            return layout;
          }
          function moveElementAwayFromCollision(layout, collidesWith, itemToMove, isUserAction) {
            var preventCollision = false;
            if (isUserAction) {
              var fakeItem = {
                x: itemToMove.x,
                y: itemToMove.y,
                w: itemToMove.w,
                h: itemToMove.h,
                i: "-1"
              };
              fakeItem.y = Math.max(collidesWith.y - itemToMove.h, 0);
              if (!getFirstCollision(layout, fakeItem)) {
                return moveElement(layout, itemToMove, void 0, fakeItem.y, preventCollision);
              }
            }
            return moveElement(layout, itemToMove, void 0, itemToMove.y + 1, preventCollision);
          }
          function setTransform(top, left, width, height) {
            var translate2 = "translate3d(" + left + "px," + top + "px, 0)";
            return {
              transform: translate2,
              WebkitTransform: translate2,
              MozTransform: translate2,
              msTransform: translate2,
              OTransform: translate2,
              width: width + "px",
              height: height + "px",
              position: "absolute"
            };
          }
          function setTransformRtl(top, right, width, height) {
            var translate2 = "translate3d(" + right * -1 + "px," + top + "px, 0)";
            return {
              transform: translate2,
              WebkitTransform: translate2,
              MozTransform: translate2,
              msTransform: translate2,
              OTransform: translate2,
              width: width + "px",
              height: height + "px",
              position: "absolute"
            };
          }
          function setTopLeft(top, left, width, height) {
            return {
              top: top + "px",
              left: left + "px",
              width: width + "px",
              height: height + "px",
              position: "absolute"
            };
          }
          function setTopRight(top, right, width, height) {
            return {
              top: top + "px",
              right: right + "px",
              width: width + "px",
              height: height + "px",
              position: "absolute"
            };
          }
          function sortLayoutItemsByRowCol(layout) {
            return [].concat(layout).sort(function(a, b) {
              if (a.y === b.y && a.x === b.x) {
                return 0;
              }
              if (a.y > b.y || a.y === b.y && a.x > b.x) {
                return 1;
              }
              return -1;
            });
          }
          function validateLayout(layout, contextName) {
            contextName = contextName || "Layout";
            var subProps = ["x", "y", "w", "h"];
            var keyArr = [];
            if (!Array.isArray(layout)) throw new Error(contextName + " must be an array!");
            for (var i = 0, len = layout.length; i < len; i++) {
              var item = layout[i];
              for (var j = 0; j < subProps.length; j++) {
                if (typeof item[subProps[j]] !== "number") {
                  throw new Error("VueGridLayout: " + contextName + "[" + i + "]." + subProps[j] + " must be a number!");
                }
              }
              if (item.i === void 0 || item.i === null) {
                throw new Error("VueGridLayout: " + contextName + "[" + i + "].i cannot be null!");
              }
              if (typeof item.i !== "number" && typeof item.i !== "string") {
                throw new Error("VueGridLayout: " + contextName + "[" + i + "].i must be a string or number!");
              }
              if (keyArr.indexOf(item.i) >= 0) {
                throw new Error("VueGridLayout: " + contextName + "[" + i + "].i must be unique!");
              }
              keyArr.push(item.i);
              if (item.static !== void 0 && typeof item.static !== "boolean") {
                throw new Error("VueGridLayout: " + contextName + "[" + i + "].static must be a boolean!");
              }
            }
          }
        }
      ),
      /***/
      "a481": (
        /***/
        function(module2, exports, __webpack_require__) {
          var anObject = __webpack_require__("cb7c");
          var toObject2 = __webpack_require__("4bf8");
          var toLength = __webpack_require__("9def");
          var toInteger = __webpack_require__("4588");
          var advanceStringIndex = __webpack_require__("0390");
          var regExpExec = __webpack_require__("5f1b");
          var max2 = Math.max;
          var min2 = Math.min;
          var floor = Math.floor;
          var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
          var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;
          var maybeToString = function(it) {
            return it === void 0 ? it : String(it);
          };
          __webpack_require__("214f")("replace", 2, function(defined, REPLACE, $replace, maybeCallNative) {
            return [
              // `String.prototype.replace` method
              // https://tc39.github.io/ecma262/#sec-string.prototype.replace
              function replace(searchValue, replaceValue) {
                var O = defined(this);
                var fn = searchValue == void 0 ? void 0 : searchValue[REPLACE];
                return fn !== void 0 ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
              },
              // `RegExp.prototype[@@replace]` method
              // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
              function(regexp, replaceValue) {
                var res = maybeCallNative($replace, regexp, this, replaceValue);
                if (res.done) return res.value;
                var rx = anObject(regexp);
                var S = String(this);
                var functionalReplace = typeof replaceValue === "function";
                if (!functionalReplace) replaceValue = String(replaceValue);
                var global2 = rx.global;
                if (global2) {
                  var fullUnicode = rx.unicode;
                  rx.lastIndex = 0;
                }
                var results = [];
                while (true) {
                  var result = regExpExec(rx, S);
                  if (result === null) break;
                  results.push(result);
                  if (!global2) break;
                  var matchStr = String(result[0]);
                  if (matchStr === "") rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
                }
                var accumulatedResult = "";
                var nextSourcePosition = 0;
                for (var i = 0; i < results.length; i++) {
                  result = results[i];
                  var matched = String(result[0]);
                  var position = max2(min2(toInteger(result.index), S.length), 0);
                  var captures = [];
                  for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
                  var namedCaptures = result.groups;
                  if (functionalReplace) {
                    var replacerArgs = [matched].concat(captures, position, S);
                    if (namedCaptures !== void 0) replacerArgs.push(namedCaptures);
                    var replacement = String(replaceValue.apply(void 0, replacerArgs));
                  } else {
                    replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
                  }
                  if (position >= nextSourcePosition) {
                    accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
                    nextSourcePosition = position + matched.length;
                  }
                }
                return accumulatedResult + S.slice(nextSourcePosition);
              }
            ];
            function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
              var tailPos = position + matched.length;
              var m = captures.length;
              var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
              if (namedCaptures !== void 0) {
                namedCaptures = toObject2(namedCaptures);
                symbols = SUBSTITUTION_SYMBOLS;
              }
              return $replace.call(replacement, symbols, function(match, ch) {
                var capture;
                switch (ch.charAt(0)) {
                  case "$":
                    return "$";
                  case "&":
                    return matched;
                  case "`":
                    return str.slice(0, position);
                  case "'":
                    return str.slice(tailPos);
                  case "<":
                    capture = namedCaptures[ch.slice(1, -1)];
                    break;
                  default:
                    var n2 = +ch;
                    if (n2 === 0) return match;
                    if (n2 > m) {
                      var f2 = floor(n2 / 10);
                      if (f2 === 0) return match;
                      if (f2 <= m) return captures[f2 - 1] === void 0 ? ch.charAt(1) : captures[f2 - 1] + ch.charAt(1);
                      return match;
                    }
                    capture = captures[n2 - 1];
                }
                return capture === void 0 ? "" : capture;
              });
            }
          });
        }
      ),
      /***/
      "aa77": (
        /***/
        function(module2, exports, __webpack_require__) {
          var $export = __webpack_require__("5ca1");
          var defined = __webpack_require__("be13");
          var fails = __webpack_require__("79e5");
          var spaces = __webpack_require__("fdef");
          var space = "[" + spaces + "]";
          var non = "​";
          var ltrim = RegExp("^" + space + space + "*");
          var rtrim = RegExp(space + space + "*$");
          var exporter = function(KEY, exec, ALIAS) {
            var exp = {};
            var FORCE = fails(function() {
              return !!spaces[KEY]() || non[KEY]() != non;
            });
            var fn = exp[KEY] = FORCE ? exec(trim2) : spaces[KEY];
            if (ALIAS) exp[ALIAS] = fn;
            $export($export.P + $export.F * FORCE, "String", exp);
          };
          var trim2 = exporter.trim = function(string, TYPE) {
            string = String(defined(string));
            if (TYPE & 1) string = string.replace(ltrim, "");
            if (TYPE & 2) string = string.replace(rtrim, "");
            return string;
          };
          module2.exports = exporter;
        }
      ),
      /***/
      "abb4": (
        /***/
        function(module2, exports, __webpack_require__) {
          module2.exports = function(quiet) {
            function noop2() {
            }
            var reporter = {
              log: noop2,
              warn: noop2,
              error: noop2
            };
            if (!quiet && window.console) {
              var attachFunction = function(reporter2, name) {
                reporter2[name] = function reporterProxy() {
                  var f2 = console[name];
                  if (f2.apply) {
                    f2.apply(console, arguments);
                  } else {
                    for (var i = 0; i < arguments.length; i++) {
                      f2(arguments[i]);
                    }
                  }
                };
              };
              attachFunction(reporter, "log");
              attachFunction(reporter, "warn");
              attachFunction(reporter, "error");
            }
            return reporter;
          };
        }
      ),
      /***/
      "ac6a": (
        /***/
        function(module2, exports, __webpack_require__) {
          var $iterators = __webpack_require__("cadf");
          var getKeys = __webpack_require__("0d58");
          var redefine = __webpack_require__("2aba");
          var global2 = __webpack_require__("7726");
          var hide = __webpack_require__("32e9");
          var Iterators = __webpack_require__("84f2");
          var wks = __webpack_require__("2b4c");
          var ITERATOR = wks("iterator");
          var TO_STRING_TAG = wks("toStringTag");
          var ArrayValues = Iterators.Array;
          var DOMIterables = {
            CSSRuleList: true,
            // TODO: Not spec compliant, should be false.
            CSSStyleDeclaration: false,
            CSSValueList: false,
            ClientRectList: false,
            DOMRectList: false,
            DOMStringList: false,
            DOMTokenList: true,
            DataTransferItemList: false,
            FileList: false,
            HTMLAllCollection: false,
            HTMLCollection: false,
            HTMLFormElement: false,
            HTMLSelectElement: false,
            MediaList: true,
            // TODO: Not spec compliant, should be false.
            MimeTypeArray: false,
            NamedNodeMap: false,
            NodeList: true,
            PaintRequestList: false,
            Plugin: false,
            PluginArray: false,
            SVGLengthList: false,
            SVGNumberList: false,
            SVGPathSegList: false,
            SVGPointList: false,
            SVGStringList: false,
            SVGTransformList: false,
            SourceBufferList: false,
            StyleSheetList: true,
            // TODO: Not spec compliant, should be false.
            TextTrackCueList: false,
            TextTrackList: false,
            TouchList: false
          };
          for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
            var NAME = collections[i];
            var explicit = DOMIterables[NAME];
            var Collection = global2[NAME];
            var proto = Collection && Collection.prototype;
            var key;
            if (proto) {
              if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
              if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
              Iterators[NAME] = ArrayValues;
              if (explicit) {
                for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
              }
            }
          }
        }
      ),
      /***/
      "ad20": (
        /***/
        function(module2, exports, __webpack_require__) {
          exports = module2.exports = __webpack_require__("2350")(false);
          exports.push([module2.i, ".vue-grid-layout{position:relative;-webkit-transition:height .2s ease;transition:height .2s ease}", ""]);
        }
      ),
      /***/
      "ade3": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return _defineProperty2;
          });
          function _defineProperty2(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
        }
      ),
      /***/
      "b0c5": (
        /***/
        function(module2, exports, __webpack_require__) {
          var regexpExec = __webpack_require__("520a");
          __webpack_require__("5ca1")({
            target: "RegExp",
            proto: true,
            forced: regexpExec !== /./.exec
          }, {
            exec: regexpExec
          });
        }
      ),
      /***/
      "b770": (
        /***/
        function(module2, exports, __webpack_require__) {
          var utils2 = module2.exports = {};
          utils2.forEach = function(collection, callback) {
            for (var i = 0; i < collection.length; i++) {
              var result = callback(collection[i]);
              if (result) {
                return result;
              }
            }
          };
        }
      ),
      /***/
      "bc21": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          var all_namespaceObject = {};
          __webpack_require__.r(all_namespaceObject);
          __webpack_require__.d(all_namespaceObject, "edgeTarget", function() {
            return edgeTarget;
          });
          __webpack_require__.d(all_namespaceObject, "elements", function() {
            return snappers_elements;
          });
          __webpack_require__.d(all_namespaceObject, "grid", function() {
            return grid;
          });
          var render66 = function() {
            var _vm = this;
            var _h = _vm.$createElement;
            var _c = _vm._self._c || _h;
            return _c("div", { ref: "item", staticClass: "vue-grid-item", class: _vm.classObj, style: _vm.style }, [_vm._t("default"), _vm.resizableAndNotStatic ? _c("span", { ref: "handle", class: _vm.resizableHandleClass }) : _vm._e()], 2);
          };
          var staticRenderFns2 = [];
          __webpack_require__("8e6e");
          __webpack_require__("ac6a");
          __webpack_require__("cadf");
          __webpack_require__("456d");
          __webpack_require__("a481");
          var defineProperty = __webpack_require__("ade3");
          __webpack_require__("fca0");
          __webpack_require__("4917");
          __webpack_require__("c5f6");
          var utils2 = __webpack_require__("a2b6");
          function getControlPosition(e) {
            return offsetXYFromParentOf(e);
          }
          function offsetXYFromParentOf(evt) {
            var offsetParent = evt.target.offsetParent || document.body;
            var offsetParentRect = evt.offsetParent === document.body ? {
              left: 0,
              top: 0
            } : offsetParent.getBoundingClientRect();
            var x = evt.clientX + offsetParent.scrollLeft - offsetParentRect.left;
            var y = evt.clientY + offsetParent.scrollTop - offsetParentRect.top;
            return {
              x,
              y
            };
          }
          function createCoreData(lastX, lastY, x, y) {
            var isStart = !isNum(lastX);
            if (isStart) {
              return {
                deltaX: 0,
                deltaY: 0,
                lastX: x,
                lastY: y,
                x,
                y
              };
            } else {
              return {
                deltaX: x - lastX,
                deltaY: y - lastY,
                lastX,
                lastY,
                x,
                y
              };
            }
          }
          function isNum(num) {
            return typeof num === "number" && !isNaN(num);
          }
          var responsiveUtils = __webpack_require__("97a7");
          var DOM = __webpack_require__("1ca7");
          const domObjects = {
            init,
            document: null,
            DocumentFragment: null,
            SVGElement: null,
            SVGSVGElement: null,
            SVGElementInstance: null,
            Element: null,
            HTMLElement: null,
            Event: null,
            Touch: null,
            PointerEvent: null
          };
          function blank() {
          }
          var utils_domObjects = domObjects;
          function init(window2) {
            const win2 = window2;
            domObjects.document = win2.document;
            domObjects.DocumentFragment = win2.DocumentFragment || blank;
            domObjects.SVGElement = win2.SVGElement || blank;
            domObjects.SVGSVGElement = win2.SVGSVGElement || blank;
            domObjects.SVGElementInstance = win2.SVGElementInstance || blank;
            domObjects.Element = win2.Element || blank;
            domObjects.HTMLElement = win2.HTMLElement || domObjects.Element;
            domObjects.Event = win2.Event;
            domObjects.Touch = win2.Touch || blank;
            domObjects.PointerEvent = win2.PointerEvent || win2.MSPointerEvent;
          }
          var isWindow2 = (thing) => !!(thing && thing.Window) && thing instanceof thing.Window;
          let realWindow = void 0;
          let win = void 0;
          function window_init(window2) {
            realWindow = window2;
            const el = window2.document.createTextNode("");
            if (el.ownerDocument !== window2.document && typeof window2.wrap === "function" && window2.wrap(el) === el) {
              window2 = window2.wrap(window2);
            }
            win = window2;
          }
          if (typeof window !== "undefined" && !!window) {
            window_init(window);
          }
          function getWindow2(node) {
            if (isWindow2(node)) {
              return node;
            }
            const rootNode = node.ownerDocument || node;
            return rootNode.defaultView || win.window;
          }
          const is_window = (thing) => thing === win || isWindow2(thing);
          const docFrag = (thing) => object(thing) && thing.nodeType === 11;
          const object = (thing) => !!thing && typeof thing === "object";
          const func = (thing) => typeof thing === "function";
          const number = (thing) => typeof thing === "number";
          const bool = (thing) => typeof thing === "boolean";
          const string = (thing) => typeof thing === "string";
          const is_element = (thing) => {
            if (!thing || typeof thing !== "object") {
              return false;
            }
            const _window = getWindow2(thing) || win;
            return /object|function/.test(typeof _window.Element) ? thing instanceof _window.Element : thing.nodeType === 1 && typeof thing.nodeName === "string";
          };
          const plainObject = (thing) => object(thing) && !!thing.constructor && /function Object\b/.test(thing.constructor.toString());
          const array = (thing) => object(thing) && typeof thing.length !== "undefined" && func(thing.splice);
          var is = {
            window: is_window,
            docFrag,
            object,
            func,
            number,
            bool,
            string,
            element: is_element,
            plainObject,
            array
          };
          const browser2 = {
            init: browser_init,
            supportsTouch: null,
            supportsPointerEvent: null,
            isIOS7: null,
            isIOS: null,
            isIe9: null,
            isOperaMobile: null,
            prefixedMatchesSelector: null,
            pEventTypes: null,
            wheelEvent: null
          };
          function browser_init(window2) {
            const Element2 = utils_domObjects.Element;
            const navigator2 = win.navigator;
            browser2.supportsTouch = "ontouchstart" in window2 || is.func(window2.DocumentTouch) && utils_domObjects.document instanceof window2.DocumentTouch;
            browser2.supportsPointerEvent = navigator2.pointerEnabled !== false && !!utils_domObjects.PointerEvent;
            browser2.isIOS = /iP(hone|od|ad)/.test(navigator2.platform);
            browser2.isIOS7 = /iP(hone|od|ad)/.test(navigator2.platform) && /OS 7[^\d]/.test(navigator2.appVersion);
            browser2.isIe9 = /MSIE 9/.test(navigator2.userAgent);
            browser2.isOperaMobile = navigator2.appName === "Opera" && browser2.supportsTouch && /Presto/.test(navigator2.userAgent);
            browser2.prefixedMatchesSelector = "matches" in Element2.prototype ? "matches" : "webkitMatchesSelector" in Element2.prototype ? "webkitMatchesSelector" : "mozMatchesSelector" in Element2.prototype ? "mozMatchesSelector" : "oMatchesSelector" in Element2.prototype ? "oMatchesSelector" : "msMatchesSelector";
            browser2.pEventTypes = browser2.supportsPointerEvent ? utils_domObjects.PointerEvent === window2.MSPointerEvent ? {
              up: "MSPointerUp",
              down: "MSPointerDown",
              over: "mouseover",
              out: "mouseout",
              move: "MSPointerMove",
              cancel: "MSPointerCancel"
            } : {
              up: "pointerup",
              down: "pointerdown",
              over: "pointerover",
              out: "pointerout",
              move: "pointermove",
              cancel: "pointercancel"
            } : null;
            browser2.wheelEvent = "onmousewheel" in utils_domObjects.document ? "mousewheel" : "wheel";
          }
          var utils_browser = browser2;
          const contains2 = (array2, target2) => array2.indexOf(target2) !== -1;
          const merge2 = (target2, source) => {
            for (const item of source) {
              target2.push(item);
            }
            return target2;
          };
          const from = (source) => merge2([], source);
          const findIndex = (array2, func2) => {
            for (let i = 0; i < array2.length; i++) {
              if (func2(array2[i], i, array2)) {
                return i;
              }
            }
            return -1;
          };
          const find = (array2, func2) => array2[findIndex(array2, func2)];
          function clone2(source) {
            const dest = {};
            for (const prop in source) {
              const value = source[prop];
              if (is.plainObject(value)) {
                dest[prop] = clone2(value);
              } else if (is.array(value)) {
                dest[prop] = from(value);
              } else {
                dest[prop] = value;
              }
            }
            return dest;
          }
          function extend2(dest, source) {
            for (const prop in source) {
              dest[prop] = source[prop];
            }
            const ret = dest;
            return ret;
          }
          let lastTime = 0;
          let request;
          let cancel;
          function raf_init(window2) {
            request = window2.requestAnimationFrame;
            cancel = window2.cancelAnimationFrame;
            if (!request) {
              const vendors = ["ms", "moz", "webkit", "o"];
              for (const vendor of vendors) {
                request = window2[`${vendor}RequestAnimationFrame`];
                cancel = window2[`${vendor}CancelAnimationFrame`] || window2[`${vendor}CancelRequestAnimationFrame`];
              }
            }
            request = request && request.bind(window2);
            cancel = cancel && cancel.bind(window2);
            if (!request) {
              request = (callback) => {
                const currTime = Date.now();
                const timeToCall = Math.max(0, 16 - (currTime - lastTime));
                const token2 = window2.setTimeout(() => {
                  callback(currTime + timeToCall);
                }, timeToCall);
                lastTime = currTime + timeToCall;
                return token2;
              };
              cancel = (token2) => clearTimeout(token2);
            }
          }
          var raf2 = {
            request: (callback) => request(callback),
            cancel: (token2) => cancel(token2),
            init: raf_init
          };
          function normalize2(type, listeners, result) {
            result = result || {};
            if (is.string(type) && type.search(" ") !== -1) {
              type = split(type);
            }
            if (is.array(type)) {
              return type.reduce((acc, t2) => extend2(acc, normalize2(t2, listeners, result)), result);
            }
            if (is.object(type)) {
              listeners = type;
              type = "";
            }
            if (is.func(listeners)) {
              result[type] = result[type] || [];
              result[type].push(listeners);
            } else if (is.array(listeners)) {
              for (const l of listeners) {
                normalize2(type, l, result);
              }
            } else if (is.object(listeners)) {
              for (const prefix2 in listeners) {
                const combinedTypes = split(prefix2).map((p) => `${type}${p}`);
                normalize2(combinedTypes, listeners[prefix2], result);
              }
            }
            return result;
          }
          function split(type) {
            return type.trim().split(/ +/);
          }
          function fireUntilImmediateStopped(event, listeners) {
            for (const listener of listeners) {
              if (event.immediatePropagationStopped) {
                break;
              }
              listener(event);
            }
          }
          class Eventable_Eventable {
            constructor(options) {
              this.options = void 0;
              this.types = {};
              this.propagationStopped = false;
              this.immediatePropagationStopped = false;
              this.global = void 0;
              this.options = extend2({}, options || {});
            }
            fire(event) {
              let listeners;
              const global2 = this.global;
              if (listeners = this.types[event.type]) {
                fireUntilImmediateStopped(event, listeners);
              }
              if (!event.propagationStopped && global2 && (listeners = global2[event.type])) {
                fireUntilImmediateStopped(event, listeners);
              }
            }
            on(type, listener) {
              const listeners = normalize2(type, listener);
              for (type in listeners) {
                this.types[type] = merge2(this.types[type] || [], listeners[type]);
              }
            }
            off(type, listener) {
              const listeners = normalize2(type, listener);
              for (type in listeners) {
                const eventList = this.types[type];
                if (!eventList || !eventList.length) {
                  continue;
                }
                for (const subListener of listeners[type]) {
                  const index2 = eventList.indexOf(subListener);
                  if (index2 !== -1) {
                    eventList.splice(index2, 1);
                  }
                }
              }
            }
            getRect(_element) {
              return null;
            }
          }
          function nodeContains(parent, child) {
            if (parent.contains) {
              return parent.contains(child);
            }
            while (child) {
              if (child === parent) {
                return true;
              }
              child = child.parentNode;
            }
            return false;
          }
          function domUtils_closest(element, selector) {
            while (is.element(element)) {
              if (matchesSelector(element, selector)) {
                return element;
              }
              element = parentNode2(element);
            }
            return null;
          }
          function parentNode2(node) {
            let parent = node.parentNode;
            if (is.docFrag(parent)) {
              while ((parent = parent.host) && is.docFrag(parent)) {
                continue;
              }
              return parent;
            }
            return parent;
          }
          function matchesSelector(element, selector) {
            if (win !== realWindow) {
              selector = selector.replace(/\/deep\//g, " ");
            }
            return element[utils_browser.prefixedMatchesSelector](selector);
          }
          function matchesUpTo(element, selector, limit) {
            while (is.element(element)) {
              if (matchesSelector(element, selector)) {
                return true;
              }
              element = parentNode2(element);
              if (element === limit) {
                return matchesSelector(element, selector);
              }
            }
            return false;
          }
          function getActualElement(element) {
            return element.correspondingUseElement || element;
          }
          function getScrollXY(relevantWindow) {
            relevantWindow = relevantWindow || win;
            return {
              x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,
              y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop
            };
          }
          function getElementClientRect(element) {
            const clientRect = element instanceof utils_domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0];
            return clientRect && {
              left: clientRect.left,
              right: clientRect.right,
              top: clientRect.top,
              bottom: clientRect.bottom,
              width: clientRect.width || clientRect.right - clientRect.left,
              height: clientRect.height || clientRect.bottom - clientRect.top
            };
          }
          function getElementRect(element) {
            const clientRect = getElementClientRect(element);
            if (!utils_browser.isIOS7 && clientRect) {
              const scroll = getScrollXY(getWindow2(element));
              clientRect.left += scroll.x;
              clientRect.right += scroll.x;
              clientRect.top += scroll.y;
              clientRect.bottom += scroll.y;
            }
            return clientRect;
          }
          function trySelector(value) {
            if (!is.string(value)) {
              return false;
            }
            utils_domObjects.document.querySelector(value);
            return true;
          }
          function getStringOptionResult(value, target2, element) {
            if (value === "parent") {
              return parentNode2(element);
            }
            if (value === "self") {
              return target2.getRect(element);
            }
            return domUtils_closest(element, value);
          }
          function resolveRectLike(value, target2, element, functionArgs) {
            let returnValue = value;
            if (is.string(returnValue)) {
              returnValue = getStringOptionResult(returnValue, target2, element);
            } else if (is.func(returnValue)) {
              returnValue = returnValue(...functionArgs);
            }
            if (is.element(returnValue)) {
              returnValue = getElementRect(returnValue);
            }
            return returnValue;
          }
          function rectToXY(rect) {
            return rect && {
              x: "x" in rect ? rect.x : rect.left,
              y: "y" in rect ? rect.y : rect.top
            };
          }
          function xywhToTlbr(rect) {
            if (rect && !("left" in rect && "top" in rect)) {
              rect = extend2({}, rect);
              rect.left = rect.x || 0;
              rect.top = rect.y || 0;
              rect.right = rect.right || rect.left + rect.width;
              rect.bottom = rect.bottom || rect.top + rect.height;
            }
            return rect;
          }
          function tlbrToXywh(rect) {
            if (rect && !("x" in rect && "y" in rect)) {
              rect = extend2({}, rect);
              rect.x = rect.left || 0;
              rect.y = rect.top || 0;
              rect.width = rect.width || (rect.right || 0) - rect.x;
              rect.height = rect.height || (rect.bottom || 0) - rect.y;
            }
            return rect;
          }
          function addEdges(edges, rect, delta) {
            if (edges.left) {
              rect.left += delta.x;
            }
            if (edges.right) {
              rect.right += delta.x;
            }
            if (edges.top) {
              rect.top += delta.y;
            }
            if (edges.bottom) {
              rect.bottom += delta.y;
            }
            rect.width = rect.right - rect.left;
            rect.height = rect.bottom - rect.top;
          }
          var getOriginXY = function(target2, element, actionName) {
            const actionOptions = target2.options[actionName];
            const actionOrigin = actionOptions && actionOptions.origin;
            const origin2 = actionOrigin || target2.options.origin;
            const originRect = resolveRectLike(origin2, target2, element, [target2 && element]);
            return rectToXY(originRect) || {
              x: 0,
              y: 0
            };
          };
          var hypot = (x, y) => Math.sqrt(x * x + y * y);
          class BaseEvent {
            constructor(interaction) {
              this.type = void 0;
              this.target = void 0;
              this.currentTarget = void 0;
              this.interactable = void 0;
              this._interaction = void 0;
              this.timeStamp = void 0;
              this.immediatePropagationStopped = false;
              this.propagationStopped = false;
              this._interaction = interaction;
            }
            preventDefault() {
            }
            /**
             * Don't call any other listeners (even on the current target)
             */
            stopPropagation() {
              this.propagationStopped = true;
            }
            /**
             * Don't call listeners on the remaining targets
             */
            stopImmediatePropagation() {
              this.immediatePropagationStopped = this.propagationStopped = true;
            }
          }
          Object.defineProperty(BaseEvent.prototype, "interaction", {
            get() {
              return this._interaction._proxy;
            },
            set() {
            }
          });
          const defaultOptions_defaults = {
            base: {
              preventDefault: "auto",
              deltaSource: "page"
            },
            perAction: {
              enabled: false,
              origin: {
                x: 0,
                y: 0
              }
            },
            actions: {}
          };
          class InteractEvent_InteractEvent extends BaseEvent {
            // resize
            /** */
            constructor(interaction, event, actionName, phase, element, preEnd, type) {
              super(interaction);
              this.target = void 0;
              this.currentTarget = void 0;
              this.relatedTarget = null;
              this.screenX = void 0;
              this.screenY = void 0;
              this.button = void 0;
              this.buttons = void 0;
              this.ctrlKey = void 0;
              this.shiftKey = void 0;
              this.altKey = void 0;
              this.metaKey = void 0;
              this.page = void 0;
              this.client = void 0;
              this.delta = void 0;
              this.rect = void 0;
              this.x0 = void 0;
              this.y0 = void 0;
              this.t0 = void 0;
              this.dt = void 0;
              this.duration = void 0;
              this.clientX0 = void 0;
              this.clientY0 = void 0;
              this.velocity = void 0;
              this.speed = void 0;
              this.swipe = void 0;
              this.timeStamp = void 0;
              this.axes = void 0;
              this.preEnd = void 0;
              element = element || interaction.element;
              const target2 = interaction.interactable;
              const deltaSource = (target2 && target2.options || defaultOptions_defaults).deltaSource;
              const origin2 = getOriginXY(target2, element, actionName);
              const starting = phase === "start";
              const ending = phase === "end";
              const prevEvent = starting ? this : interaction.prevEvent;
              const coords = starting ? interaction.coords.start : ending ? {
                page: prevEvent.page,
                client: prevEvent.client,
                timeStamp: interaction.coords.cur.timeStamp
              } : interaction.coords.cur;
              this.page = extend2({}, coords.page);
              this.client = extend2({}, coords.client);
              this.rect = extend2({}, interaction.rect);
              this.timeStamp = coords.timeStamp;
              if (!ending) {
                this.page.x -= origin2.x;
                this.page.y -= origin2.y;
                this.client.x -= origin2.x;
                this.client.y -= origin2.y;
              }
              this.ctrlKey = event.ctrlKey;
              this.altKey = event.altKey;
              this.shiftKey = event.shiftKey;
              this.metaKey = event.metaKey;
              this.button = event.button;
              this.buttons = event.buttons;
              this.target = element;
              this.currentTarget = element;
              this.preEnd = preEnd;
              this.type = type || actionName + (phase || "");
              this.interactable = target2;
              this.t0 = starting ? interaction.pointers[interaction.pointers.length - 1].downTime : prevEvent.t0;
              this.x0 = interaction.coords.start.page.x - origin2.x;
              this.y0 = interaction.coords.start.page.y - origin2.y;
              this.clientX0 = interaction.coords.start.client.x - origin2.x;
              this.clientY0 = interaction.coords.start.client.y - origin2.y;
              if (starting || ending) {
                this.delta = {
                  x: 0,
                  y: 0
                };
              } else {
                this.delta = {
                  x: this[deltaSource].x - prevEvent[deltaSource].x,
                  y: this[deltaSource].y - prevEvent[deltaSource].y
                };
              }
              this.dt = interaction.coords.delta.timeStamp;
              this.duration = this.timeStamp - this.t0;
              this.velocity = extend2({}, interaction.coords.velocity[deltaSource]);
              this.speed = hypot(this.velocity.x, this.velocity.y);
              this.swipe = ending || phase === "inertiastart" ? this.getSwipe() : null;
            }
            getSwipe() {
              const interaction = this._interaction;
              if (interaction.prevEvent.speed < 600 || this.timeStamp - interaction.prevEvent.timeStamp > 150) {
                return null;
              }
              let angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;
              const overlap = 22.5;
              if (angle < 0) {
                angle += 360;
              }
              const left = 135 - overlap <= angle && angle < 225 + overlap;
              const up = 225 - overlap <= angle && angle < 315 + overlap;
              const right = !left && (315 - overlap <= angle || angle < 45 + overlap);
              const down = !up && 45 - overlap <= angle && angle < 135 + overlap;
              return {
                up,
                down,
                left,
                right,
                angle,
                speed: interaction.prevEvent.speed,
                velocity: {
                  x: interaction.prevEvent.velocityX,
                  y: interaction.prevEvent.velocityY
                }
              };
            }
            preventDefault() {
            }
            /**
             * Don't call listeners on the remaining targets
             */
            stopImmediatePropagation() {
              this.immediatePropagationStopped = this.propagationStopped = true;
            }
            /**
             * Don't call any other listeners (even on the current target)
             */
            stopPropagation() {
              this.propagationStopped = true;
            }
          }
          Object.defineProperties(InteractEvent_InteractEvent.prototype, {
            pageX: {
              get() {
                return this.page.x;
              },
              set(value) {
                this.page.x = value;
              }
            },
            pageY: {
              get() {
                return this.page.y;
              },
              set(value) {
                this.page.y = value;
              }
            },
            clientX: {
              get() {
                return this.client.x;
              },
              set(value) {
                this.client.x = value;
              }
            },
            clientY: {
              get() {
                return this.client.y;
              },
              set(value) {
                this.client.y = value;
              }
            },
            dx: {
              get() {
                return this.delta.x;
              },
              set(value) {
                this.delta.x = value;
              }
            },
            dy: {
              get() {
                return this.delta.y;
              },
              set(value) {
                this.delta.y = value;
              }
            },
            velocityX: {
              get() {
                return this.velocity.x;
              },
              set(value) {
                this.velocity.x = value;
              }
            },
            velocityY: {
              get() {
                return this.velocity.y;
              },
              set(value) {
                this.velocity.y = value;
              }
            }
          });
          function isNonNativeEvent(type, actions) {
            if (actions.phaselessTypes[type]) {
              return true;
            }
            for (const name in actions.map) {
              if (type.indexOf(name) === 0 && type.substr(name.length) in actions.phases) {
                return true;
              }
            }
            return false;
          }
          class Interactable_Interactable {
            /** @internal */
            get _defaults() {
              return {
                base: {},
                perAction: {},
                actions: {}
              };
            }
            /** */
            constructor(target2, options, defaultContext, scopeEvents) {
              this.options = void 0;
              this._actions = void 0;
              this.target = void 0;
              this.events = new Eventable_Eventable();
              this._context = void 0;
              this._win = void 0;
              this._doc = void 0;
              this._scopeEvents = void 0;
              this._rectChecker = void 0;
              this._actions = options.actions;
              this.target = target2;
              this._context = options.context || defaultContext;
              this._win = getWindow2(trySelector(target2) ? this._context : target2);
              this._doc = this._win.document;
              this._scopeEvents = scopeEvents;
              this.set(options);
            }
            setOnEvents(actionName, phases) {
              if (is.func(phases.onstart)) {
                this.on(`${actionName}start`, phases.onstart);
              }
              if (is.func(phases.onmove)) {
                this.on(`${actionName}move`, phases.onmove);
              }
              if (is.func(phases.onend)) {
                this.on(`${actionName}end`, phases.onend);
              }
              if (is.func(phases.oninertiastart)) {
                this.on(`${actionName}inertiastart`, phases.oninertiastart);
              }
              return this;
            }
            updatePerActionListeners(actionName, prev, cur) {
              if (is.array(prev) || is.object(prev)) {
                this.off(actionName, prev);
              }
              if (is.array(cur) || is.object(cur)) {
                this.on(actionName, cur);
              }
            }
            setPerAction(actionName, options) {
              const defaults2 = this._defaults;
              for (const optionName_ in options) {
                const optionName = optionName_;
                const actionOptions = this.options[actionName];
                const optionValue = options[optionName];
                if (optionName === "listeners") {
                  this.updatePerActionListeners(actionName, actionOptions.listeners, optionValue);
                }
                if (is.array(optionValue)) {
                  actionOptions[optionName] = from(optionValue);
                } else if (is.plainObject(optionValue)) {
                  actionOptions[optionName] = extend2(actionOptions[optionName] || {}, clone2(optionValue));
                  if (is.object(defaults2.perAction[optionName]) && "enabled" in defaults2.perAction[optionName]) {
                    actionOptions[optionName].enabled = optionValue.enabled !== false;
                  }
                } else if (is.bool(optionValue) && is.object(defaults2.perAction[optionName])) {
                  actionOptions[optionName].enabled = optionValue;
                } else {
                  actionOptions[optionName] = optionValue;
                }
              }
            }
            /**
             * The default function to get an Interactables bounding rect. Can be
             * overridden using {@link Interactable.rectChecker}.
             *
             * @param {Element} [element] The element to measure.
             * @return {Rect} The object's bounding rectangle.
             */
            getRect(element) {
              element = element || (is.element(this.target) ? this.target : null);
              if (is.string(this.target)) {
                element = element || this._context.querySelector(this.target);
              }
              return getElementRect(element);
            }
            /**
             * Returns or sets the function used to calculate the interactable's
             * element's rectangle
             *
             * @param {function} [checker] A function which returns this Interactable's
             * bounding rectangle. See {@link Interactable.getRect}
             * @return {function | object} The checker function or this Interactable
             */
            rectChecker(checker) {
              if (is.func(checker)) {
                this._rectChecker = checker;
                this.getRect = (element) => {
                  const rect = extend2({}, this._rectChecker(element));
                  if (!("width" in rect)) {
                    rect.width = rect.right - rect.left;
                    rect.height = rect.bottom - rect.top;
                  }
                  return rect;
                };
                return this;
              }
              if (checker === null) {
                delete this.getRect;
                delete this._rectChecker;
                return this;
              }
              return this.getRect;
            }
            _backCompatOption(optionName, newValue) {
              if (trySelector(newValue) || is.object(newValue)) {
                this.options[optionName] = newValue;
                for (const action in this._actions.map) {
                  this.options[action][optionName] = newValue;
                }
                return this;
              }
              return this.options[optionName];
            }
            /**
             * Gets or sets the origin of the Interactable's element.  The x and y
             * of the origin will be subtracted from action event coordinates.
             *
             * @param {Element | object | string} [origin] An HTML or SVG Element whose
             * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'
             * or any CSS selector
             *
             * @return {object} The current origin or this Interactable
             */
            origin(newValue) {
              return this._backCompatOption("origin", newValue);
            }
            /**
             * Returns or sets the mouse coordinate types used to calculate the
             * movement of the pointer.
             *
             * @param {string} [newValue] Use 'client' if you will be scrolling while
             * interacting; Use 'page' if you want autoScroll to work
             * @return {string | object} The current deltaSource or this Interactable
             */
            deltaSource(newValue) {
              if (newValue === "page" || newValue === "client") {
                this.options.deltaSource = newValue;
                return this;
              }
              return this.options.deltaSource;
            }
            /**
             * Gets the selector context Node of the Interactable. The default is
             * `window.document`.
             *
             * @return {Node} The context Node of this Interactable
             */
            context() {
              return this._context;
            }
            inContext(element) {
              return this._context === element.ownerDocument || nodeContains(this._context, element);
            }
            testIgnoreAllow(options, targetNode, eventTarget) {
              return !this.testIgnore(options.ignoreFrom, targetNode, eventTarget) && this.testAllow(options.allowFrom, targetNode, eventTarget);
            }
            testAllow(allowFrom, targetNode, element) {
              if (!allowFrom) {
                return true;
              }
              if (!is.element(element)) {
                return false;
              }
              if (is.string(allowFrom)) {
                return matchesUpTo(element, allowFrom, targetNode);
              } else if (is.element(allowFrom)) {
                return nodeContains(allowFrom, element);
              }
              return false;
            }
            testIgnore(ignoreFrom, targetNode, element) {
              if (!ignoreFrom || !is.element(element)) {
                return false;
              }
              if (is.string(ignoreFrom)) {
                return matchesUpTo(element, ignoreFrom, targetNode);
              } else if (is.element(ignoreFrom)) {
                return nodeContains(ignoreFrom, element);
              }
              return false;
            }
            /**
             * Calls listeners for the given InteractEvent type bound globally
             * and directly to this Interactable
             *
             * @param {InteractEvent} iEvent The InteractEvent object to be fired on this
             * Interactable
             * @return {Interactable} this Interactable
             */
            fire(iEvent) {
              this.events.fire(iEvent);
              return this;
            }
            _onOff(method, typeArg, listenerArg, options) {
              if (is.object(typeArg) && !is.array(typeArg)) {
                options = listenerArg;
                listenerArg = null;
              }
              const addRemove = method === "on" ? "add" : "remove";
              const listeners = normalize2(typeArg, listenerArg);
              for (let type in listeners) {
                if (type === "wheel") {
                  type = utils_browser.wheelEvent;
                }
                for (const listener of listeners[type]) {
                  if (isNonNativeEvent(type, this._actions)) {
                    this.events[method](type, listener);
                  } else if (is.string(this.target)) {
                    this._scopeEvents[`${addRemove}Delegate`](this.target, this._context, type, listener, options);
                  } else {
                    this._scopeEvents[addRemove](this.target, type, listener, options);
                  }
                }
              }
              return this;
            }
            /**
             * Binds a listener for an InteractEvent, pointerEvent or DOM event.
             *
             * @param {string | array | object} types The types of events to listen
             * for
             * @param {function | array | object} [listener] The event listener function(s)
             * @param {object | boolean} [options] options object or useCapture flag for
             * addEventListener
             * @return {Interactable} This Interactable
             */
            on(types, listener, options) {
              return this._onOff("on", types, listener, options);
            }
            /**
             * Removes an InteractEvent, pointerEvent or DOM event listener.
             *
             * @param {string | array | object} types The types of events that were
             * listened for
             * @param {function | array | object} [listener] The event listener function(s)
             * @param {object | boolean} [options] options object or useCapture flag for
             * removeEventListener
             * @return {Interactable} This Interactable
             */
            off(types, listener, options) {
              return this._onOff("off", types, listener, options);
            }
            /**
             * Reset the options of this Interactable
             *
             * @param {object} options The new settings to apply
             * @return {object} This Interactable
             */
            set(options) {
              const defaults2 = this._defaults;
              if (!is.object(options)) {
                options = {};
              }
              this.options = clone2(defaults2.base);
              for (const actionName_ in this._actions.methodDict) {
                const actionName = actionName_;
                const methodName = this._actions.methodDict[actionName];
                this.options[actionName] = {};
                this.setPerAction(actionName, extend2(extend2({}, defaults2.perAction), defaults2.actions[actionName]));
                this[methodName](options[actionName]);
              }
              for (const setting in options) {
                if (is.func(this[setting])) {
                  this[setting](options[setting]);
                }
              }
              return this;
            }
            /**
             * Remove this interactable from the list of interactables and remove it's
             * action capabilities and event listeners
             */
            unset() {
              if (is.string(this.target)) {
                for (const type in this._scopeEvents.delegatedEvents) {
                  const delegated = this._scopeEvents.delegatedEvents[type];
                  for (let i = delegated.length - 1; i >= 0; i--) {
                    const {
                      selector,
                      context,
                      listeners
                    } = delegated[i];
                    if (selector === this.target && context === this._context) {
                      delegated.splice(i, 1);
                    }
                    for (let l = listeners.length - 1; l >= 0; l--) {
                      this._scopeEvents.removeDelegate(this.target, this._context, type, listeners[l][0], listeners[l][1]);
                    }
                  }
                }
              } else {
                this._scopeEvents.remove(this.target, "all");
              }
            }
          }
          class InteractableSet_InteractableSet {
            // all set interactables
            constructor(scope) {
              this.list = [];
              this.selectorMap = {};
              this.scope = void 0;
              this.scope = scope;
              scope.addListeners({
                "interactable:unset": ({
                  interactable
                }) => {
                  const {
                    target: target2,
                    _context: context
                  } = interactable;
                  const targetMappings = is.string(target2) ? this.selectorMap[target2] : target2[this.scope.id];
                  const targetIndex = findIndex(targetMappings, (m) => m.context === context);
                  if (targetMappings[targetIndex]) {
                    targetMappings[targetIndex].context = null;
                    targetMappings[targetIndex].interactable = null;
                  }
                  targetMappings.splice(targetIndex, 1);
                }
              });
            }
            new(target2, options) {
              options = extend2(options || {}, {
                actions: this.scope.actions
              });
              const interactable = new this.scope.Interactable(target2, options, this.scope.document, this.scope.events);
              const mappingInfo = {
                context: interactable._context,
                interactable
              };
              this.scope.addDocument(interactable._doc);
              this.list.push(interactable);
              if (is.string(target2)) {
                if (!this.selectorMap[target2]) {
                  this.selectorMap[target2] = [];
                }
                this.selectorMap[target2].push(mappingInfo);
              } else {
                if (!interactable.target[this.scope.id]) {
                  Object.defineProperty(target2, this.scope.id, {
                    value: [],
                    configurable: true
                  });
                }
                target2[this.scope.id].push(mappingInfo);
              }
              this.scope.fire("interactable:new", {
                target: target2,
                options,
                interactable,
                win: this.scope._win
              });
              return interactable;
            }
            get(target2, options) {
              const context = options && options.context || this.scope.document;
              const isSelector = is.string(target2);
              const targetMappings = isSelector ? this.selectorMap[target2] : target2[this.scope.id];
              if (!targetMappings) {
                return null;
              }
              const found = find(targetMappings, (m) => m.context === context && (isSelector || m.interactable.inContext(target2)));
              return found && found.interactable;
            }
            forEachMatch(node, callback) {
              for (const interactable of this.list) {
                let ret;
                if ((is.string(interactable.target) ? is.element(node) && matchesSelector(node, interactable.target) : (
                  // target is the element
                  node === interactable.target
                )) && // the element is in context
                interactable.inContext(node)) {
                  ret = callback(interactable);
                }
                if (ret !== void 0) {
                  return ret;
                }
              }
            }
          }
          function pointerExtend(dest, source) {
            for (const prop in source) {
              const prefixedPropREs = pointerExtend.prefixedPropREs;
              let deprecated = false;
              for (const vendor in prefixedPropREs) {
                if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {
                  deprecated = true;
                  break;
                }
              }
              if (!deprecated && typeof source[prop] !== "function") {
                dest[prop] = source[prop];
              }
            }
            return dest;
          }
          pointerExtend.prefixedPropREs = {
            webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,
            moz: /(Pressure)$/
          };
          var utils_pointerExtend = pointerExtend;
          function copyCoords(dest, src) {
            dest.page = dest.page || {};
            dest.page.x = src.page.x;
            dest.page.y = src.page.y;
            dest.client = dest.client || {};
            dest.client.x = src.client.x;
            dest.client.y = src.client.y;
            dest.timeStamp = src.timeStamp;
          }
          function setCoordDeltas(targetObj, prev, cur) {
            targetObj.page.x = cur.page.x - prev.page.x;
            targetObj.page.y = cur.page.y - prev.page.y;
            targetObj.client.x = cur.client.x - prev.client.x;
            targetObj.client.y = cur.client.y - prev.client.y;
            targetObj.timeStamp = cur.timeStamp - prev.timeStamp;
          }
          function setCoordVelocity(targetObj, delta) {
            const dt = Math.max(delta.timeStamp / 1e3, 1e-3);
            targetObj.page.x = delta.page.x / dt;
            targetObj.page.y = delta.page.y / dt;
            targetObj.client.x = delta.client.x / dt;
            targetObj.client.y = delta.client.y / dt;
            targetObj.timeStamp = dt;
          }
          function setZeroCoords(targetObj) {
            targetObj.page.x = 0;
            targetObj.page.y = 0;
            targetObj.client.x = 0;
            targetObj.client.y = 0;
          }
          function isNativePointer(pointer) {
            return pointer instanceof utils_domObjects.Event || pointer instanceof utils_domObjects.Touch;
          }
          function getXY(type, pointer, xy) {
            xy = xy || {};
            type = type || "page";
            xy.x = pointer[type + "X"];
            xy.y = pointer[type + "Y"];
            return xy;
          }
          function getPageXY(pointer, page) {
            page = page || {
              x: 0,
              y: 0
            };
            if (utils_browser.isOperaMobile && isNativePointer(pointer)) {
              getXY("screen", pointer, page);
              page.x += window.scrollX;
              page.y += window.scrollY;
            } else {
              getXY("page", pointer, page);
            }
            return page;
          }
          function getClientXY(pointer, client2) {
            client2 = client2 || {};
            if (utils_browser.isOperaMobile && isNativePointer(pointer)) {
              getXY("screen", pointer, client2);
            } else {
              getXY("client", pointer, client2);
            }
            return client2;
          }
          function getPointerId(pointer) {
            return is.number(pointer.pointerId) ? pointer.pointerId : pointer.identifier;
          }
          function setCoords(dest, pointers, timeStamp) {
            const pointer = pointers.length > 1 ? pointerAverage(pointers) : pointers[0];
            getPageXY(pointer, dest.page);
            getClientXY(pointer, dest.client);
            dest.timeStamp = timeStamp;
          }
          function getTouchPair(event) {
            const touches = [];
            if (is.array(event)) {
              touches[0] = event[0];
              touches[1] = event[1];
            } else {
              if (event.type === "touchend") {
                if (event.touches.length === 1) {
                  touches[0] = event.touches[0];
                  touches[1] = event.changedTouches[0];
                } else if (event.touches.length === 0) {
                  touches[0] = event.changedTouches[0];
                  touches[1] = event.changedTouches[1];
                }
              } else {
                touches[0] = event.touches[0];
                touches[1] = event.touches[1];
              }
            }
            return touches;
          }
          function pointerAverage(pointers) {
            const average = {
              pageX: 0,
              pageY: 0,
              clientX: 0,
              clientY: 0,
              screenX: 0,
              screenY: 0
            };
            for (const pointer of pointers) {
              for (const prop in average) {
                average[prop] += pointer[prop];
              }
            }
            for (const prop in average) {
              average[prop] /= pointers.length;
            }
            return average;
          }
          function touchBBox(event) {
            if (!event.length) {
              return null;
            }
            const touches = getTouchPair(event);
            const minX = Math.min(touches[0].pageX, touches[1].pageX);
            const minY = Math.min(touches[0].pageY, touches[1].pageY);
            const maxX = Math.max(touches[0].pageX, touches[1].pageX);
            const maxY = Math.max(touches[0].pageY, touches[1].pageY);
            return {
              x: minX,
              y: minY,
              left: minX,
              top: minY,
              right: maxX,
              bottom: maxY,
              width: maxX - minX,
              height: maxY - minY
            };
          }
          function touchDistance(event, deltaSource) {
            const sourceX = deltaSource + "X";
            const sourceY = deltaSource + "Y";
            const touches = getTouchPair(event);
            const dx = touches[0][sourceX] - touches[1][sourceX];
            const dy = touches[0][sourceY] - touches[1][sourceY];
            return hypot(dx, dy);
          }
          function touchAngle(event, deltaSource) {
            const sourceX = deltaSource + "X";
            const sourceY = deltaSource + "Y";
            const touches = getTouchPair(event);
            const dx = touches[1][sourceX] - touches[0][sourceX];
            const dy = touches[1][sourceY] - touches[0][sourceY];
            const angle = 180 * Math.atan2(dy, dx) / Math.PI;
            return angle;
          }
          function getPointerType(pointer) {
            return is.string(pointer.pointerType) ? pointer.pointerType : is.number(pointer.pointerType) ? [void 0, void 0, "touch", "pen", "mouse"][pointer.pointerType] : /touch/.test(pointer.type) || pointer instanceof utils_domObjects.Touch ? "touch" : "mouse";
          }
          function getEventTargets(event) {
            const path = is.func(event.composedPath) ? event.composedPath() : event.path;
            return [getActualElement(path ? path[0] : event.target), getActualElement(event.currentTarget)];
          }
          function newCoords() {
            return {
              page: {
                x: 0,
                y: 0
              },
              client: {
                x: 0,
                y: 0
              },
              timeStamp: 0
            };
          }
          function install2(scope) {
            const targets = [];
            const delegatedEvents = {};
            const documents = [];
            const eventsMethods = {
              add: add2,
              remove: remove2,
              addDelegate,
              removeDelegate,
              delegateListener,
              delegateUseCapture,
              delegatedEvents,
              documents,
              targets,
              supportsOptions: false,
              supportsPassive: false
            };
            scope.document.createElement("div").addEventListener("test", null, {
              get capture() {
                return eventsMethods.supportsOptions = true;
              },
              get passive() {
                return eventsMethods.supportsPassive = true;
              }
            });
            scope.events = eventsMethods;
            function add2(eventTarget, type, listener, optionalArg) {
              const options = getOptions2(optionalArg);
              let target2 = find(targets, (t2) => t2.eventTarget === eventTarget);
              if (!target2) {
                target2 = {
                  eventTarget,
                  events: {}
                };
                targets.push(target2);
              }
              if (!target2.events[type]) {
                target2.events[type] = [];
              }
              if (eventTarget.addEventListener && !contains2(target2.events[type], listener)) {
                eventTarget.addEventListener(type, listener, eventsMethods.supportsOptions ? options : options.capture);
                target2.events[type].push(listener);
              }
            }
            function remove2(eventTarget, type, listener, optionalArg) {
              const options = getOptions2(optionalArg);
              const targetIndex = findIndex(targets, (t2) => t2.eventTarget === eventTarget);
              const target2 = targets[targetIndex];
              if (!target2 || !target2.events) {
                return;
              }
              if (type === "all") {
                for (type in target2.events) {
                  if (target2.events.hasOwnProperty(type)) {
                    remove2(eventTarget, type, "all");
                  }
                }
                return;
              }
              let typeIsEmpty = false;
              const typeListeners = target2.events[type];
              if (typeListeners) {
                if (listener === "all") {
                  for (let i = typeListeners.length - 1; i >= 0; i--) {
                    remove2(eventTarget, type, typeListeners[i], options);
                  }
                  return;
                } else {
                  for (let i = 0; i < typeListeners.length; i++) {
                    if (typeListeners[i] === listener) {
                      eventTarget.removeEventListener(type, listener, eventsMethods.supportsOptions ? options : options.capture);
                      typeListeners.splice(i, 1);
                      if (typeListeners.length === 0) {
                        delete target2.events[type];
                        typeIsEmpty = true;
                      }
                      break;
                    }
                  }
                }
              }
              if (typeIsEmpty && !Object.keys(target2.events).length) {
                targets.splice(targetIndex, 1);
              }
            }
            function addDelegate(selector, context, type, listener, optionalArg) {
              const options = getOptions2(optionalArg);
              if (!delegatedEvents[type]) {
                delegatedEvents[type] = [];
                for (const doc of documents) {
                  add2(doc, type, delegateListener);
                  add2(doc, type, delegateUseCapture, true);
                }
              }
              const delegates = delegatedEvents[type];
              let delegate = find(delegates, (d) => d.selector === selector && d.context === context);
              if (!delegate) {
                delegate = {
                  selector,
                  context,
                  listeners: []
                };
                delegates.push(delegate);
              }
              delegate.listeners.push([listener, options]);
            }
            function removeDelegate(selector, context, type, listener, optionalArg) {
              const options = getOptions2(optionalArg);
              const delegates = delegatedEvents[type];
              let matchFound = false;
              let index2;
              if (!delegates) {
                return;
              }
              for (index2 = delegates.length - 1; index2 >= 0; index2--) {
                const cur = delegates[index2];
                if (cur.selector === selector && cur.context === context) {
                  const {
                    listeners
                  } = cur;
                  for (let i = listeners.length - 1; i >= 0; i--) {
                    const [fn, {
                      capture,
                      passive
                    }] = listeners[i];
                    if (fn === listener && capture === options.capture && passive === options.passive) {
                      listeners.splice(i, 1);
                      if (!listeners.length) {
                        delegates.splice(index2, 1);
                        remove2(context, type, delegateListener);
                        remove2(context, type, delegateUseCapture, true);
                      }
                      matchFound = true;
                      break;
                    }
                  }
                  if (matchFound) {
                    break;
                  }
                }
              }
            }
            function delegateListener(event, optionalArg) {
              const options = getOptions2(optionalArg);
              const fakeEvent = new events_FakeEvent(event);
              const delegates = delegatedEvents[event.type];
              const [eventTarget] = getEventTargets(event);
              let element = eventTarget;
              while (is.element(element)) {
                for (let i = 0; i < delegates.length; i++) {
                  const cur = delegates[i];
                  const {
                    selector,
                    context
                  } = cur;
                  if (matchesSelector(element, selector) && nodeContains(context, eventTarget) && nodeContains(context, element)) {
                    const {
                      listeners
                    } = cur;
                    fakeEvent.currentTarget = element;
                    for (const [fn, {
                      capture,
                      passive
                    }] of listeners) {
                      if (capture === options.capture && passive === options.passive) {
                        fn(fakeEvent);
                      }
                    }
                  }
                }
                element = parentNode2(element);
              }
            }
            function delegateUseCapture(event) {
              return delegateListener.call(this, event, true);
            }
            return eventsMethods;
          }
          class events_FakeEvent {
            constructor(originalEvent) {
              this.currentTarget = void 0;
              this.originalEvent = void 0;
              this.type = void 0;
              this.originalEvent = originalEvent;
              utils_pointerExtend(this, originalEvent);
            }
            preventOriginalDefault() {
              this.originalEvent.preventDefault();
            }
            stopPropagation() {
              this.originalEvent.stopPropagation();
            }
            stopImmediatePropagation() {
              this.originalEvent.stopImmediatePropagation();
            }
          }
          function getOptions2(param) {
            if (!is.object(param)) {
              return {
                capture: !!param,
                passive: false
              };
            }
            const options = extend2({}, param);
            options.capture = !!param.capture;
            options.passive = !!param.passive;
            return options;
          }
          var events2 = {
            id: "events",
            install: install2
          };
          function warnOnce(method, message) {
            let warned = false;
            return function() {
              if (!warned) {
                win.console.warn(message);
                warned = true;
              }
              return method.apply(this, arguments);
            };
          }
          function copyAction(dest, src) {
            dest.name = src.name;
            dest.axis = src.axis;
            dest.edges = src.edges;
            return dest;
          }
          function createInteractStatic(scope) {
            const interact = (target2, options) => {
              let interactable = scope.interactables.get(target2, options);
              if (!interactable) {
                interactable = scope.interactables.new(target2, options);
                interactable.events.global = interact.globalEvents;
              }
              return interactable;
            };
            interact.getPointerAverage = pointerAverage;
            interact.getTouchBBox = touchBBox;
            interact.getTouchDistance = touchDistance;
            interact.getTouchAngle = touchAngle;
            interact.getElementRect = getElementRect;
            interact.getElementClientRect = getElementClientRect;
            interact.matchesSelector = matchesSelector;
            interact.closest = domUtils_closest;
            interact.globalEvents = {};
            interact.version = "1.10.2";
            interact.scope = scope;
            interact.use = function(plugin2, options) {
              this.scope.usePlugin(plugin2, options);
              return this;
            };
            interact.isSet = function(target2, options) {
              return !!this.scope.interactables.get(target2, options && options.context);
            };
            interact.on = warnOnce(function on(type, listener, options) {
              if (is.string(type) && type.search(" ") !== -1) {
                type = type.trim().split(/ +/);
              }
              if (is.array(type)) {
                for (const eventType of type) {
                  this.on(eventType, listener, options);
                }
                return this;
              }
              if (is.object(type)) {
                for (const prop in type) {
                  this.on(prop, type[prop], listener);
                }
                return this;
              }
              if (isNonNativeEvent(type, this.scope.actions)) {
                if (!this.globalEvents[type]) {
                  this.globalEvents[type] = [listener];
                } else {
                  this.globalEvents[type].push(listener);
                }
              } else {
                this.scope.events.add(this.scope.document, type, listener, {
                  options
                });
              }
              return this;
            }, "The interact.on() method is being deprecated");
            interact.off = warnOnce(function off(type, listener, options) {
              if (is.string(type) && type.search(" ") !== -1) {
                type = type.trim().split(/ +/);
              }
              if (is.array(type)) {
                for (const eventType of type) {
                  this.off(eventType, listener, options);
                }
                return this;
              }
              if (is.object(type)) {
                for (const prop in type) {
                  this.off(prop, type[prop], listener);
                }
                return this;
              }
              if (isNonNativeEvent(type, this.scope.actions)) {
                let index2;
                if (type in this.globalEvents && (index2 = this.globalEvents[type].indexOf(listener)) !== -1) {
                  this.globalEvents[type].splice(index2, 1);
                }
              } else {
                this.scope.events.remove(this.scope.document, type, listener, options);
              }
              return this;
            }, "The interact.off() method is being deprecated");
            interact.debug = function() {
              return this.scope;
            };
            interact.supportsTouch = function() {
              return utils_browser.supportsTouch;
            };
            interact.supportsPointerEvent = function() {
              return utils_browser.supportsPointerEvent;
            };
            interact.stop = function() {
              for (const interaction of this.scope.interactions.list) {
                interaction.stop();
              }
              return this;
            };
            interact.pointerMoveTolerance = function(newValue) {
              if (is.number(newValue)) {
                this.scope.interactions.pointerMoveTolerance = newValue;
                return this;
              }
              return this.scope.interactions.pointerMoveTolerance;
            };
            interact.addDocument = function(doc, options) {
              this.scope.addDocument(doc, options);
            };
            interact.removeDocument = function(doc) {
              this.scope.removeDocument(doc);
            };
            return interact;
          }
          class PointerInfo {
            constructor(id, pointer, event, downTime, downTarget) {
              this.id = void 0;
              this.pointer = void 0;
              this.event = void 0;
              this.downTime = void 0;
              this.downTarget = void 0;
              this.id = id;
              this.pointer = pointer;
              this.event = event;
              this.downTime = downTime;
              this.downTarget = downTarget;
            }
          }
          let _ProxyValues;
          (function(_ProxyValues2) {
            _ProxyValues2["interactable"] = "";
            _ProxyValues2["element"] = "";
            _ProxyValues2["prepared"] = "";
            _ProxyValues2["pointerIsDown"] = "";
            _ProxyValues2["pointerWasMoved"] = "";
            _ProxyValues2["_proxy"] = "";
          })(_ProxyValues || (_ProxyValues = {}));
          let _ProxyMethods;
          (function(_ProxyMethods2) {
            _ProxyMethods2["start"] = "";
            _ProxyMethods2["move"] = "";
            _ProxyMethods2["end"] = "";
            _ProxyMethods2["stop"] = "";
            _ProxyMethods2["interacting"] = "";
          })(_ProxyMethods || (_ProxyMethods = {}));
          let idCounter = 0;
          class Interaction_Interaction {
            // current interactable being interacted with
            // the target element of the interactable
            // action that's ready to be fired on next move event
            // keep track of added pointers
            // pointerdown/mousedown/touchstart event
            // previous action event
            /** @internal */
            get pointerMoveTolerance() {
              return 1;
            }
            /**
             * @alias Interaction.prototype.move
             */
            /** */
            constructor({
              pointerType,
              scopeFire
            }) {
              this.interactable = null;
              this.element = null;
              this.rect = void 0;
              this._rects = void 0;
              this.edges = void 0;
              this._scopeFire = void 0;
              this.prepared = {
                name: null,
                axis: null,
                edges: null
              };
              this.pointerType = void 0;
              this.pointers = [];
              this.downEvent = null;
              this.downPointer = {};
              this._latestPointer = {
                pointer: null,
                event: null,
                eventTarget: null
              };
              this.prevEvent = null;
              this.pointerIsDown = false;
              this.pointerWasMoved = false;
              this._interacting = false;
              this._ending = false;
              this._stopped = true;
              this._proxy = null;
              this.simulation = null;
              this.doMove = warnOnce(function(signalArg) {
                this.move(signalArg);
              }, "The interaction.doMove() method has been renamed to interaction.move()");
              this.coords = {
                // Starting InteractEvent pointer coordinates
                start: newCoords(),
                // Previous native pointer move event coordinates
                prev: newCoords(),
                // current native pointer move event coordinates
                cur: newCoords(),
                // Change in coordinates and time of the pointer
                delta: newCoords(),
                // pointer velocity
                velocity: newCoords()
              };
              this._id = idCounter++;
              this._scopeFire = scopeFire;
              this.pointerType = pointerType;
              const that = this;
              this._proxy = {};
              for (const key in _ProxyValues) {
                Object.defineProperty(this._proxy, key, {
                  get() {
                    return that[key];
                  }
                });
              }
              for (const key in _ProxyMethods) {
                Object.defineProperty(this._proxy, key, {
                  value: (...args) => that[key](...args)
                });
              }
              this._scopeFire("interactions:new", {
                interaction: this
              });
            }
            pointerDown(pointer, event, eventTarget) {
              const pointerIndex = this.updatePointer(pointer, event, eventTarget, true);
              const pointerInfo = this.pointers[pointerIndex];
              this._scopeFire("interactions:down", {
                pointer,
                event,
                eventTarget,
                pointerIndex,
                pointerInfo,
                type: "down",
                interaction: this
              });
            }
            /**
             * ```js
             * interact(target)
             *   .draggable({
             *     // disable the default drag start by down->move
             *     manualStart: true
             *   })
             *   // start dragging after the user holds the pointer down
             *   .on('hold', function (event) {
             *     var interaction = event.interaction
             *
             *     if (!interaction.interacting()) {
             *       interaction.start({ name: 'drag' },
             *                         event.interactable,
             *                         event.currentTarget)
             *     }
             * })
             * ```
             *
             * Start an action with the given Interactable and Element as tartgets. The
             * action must be enabled for the target Interactable and an appropriate
             * number of pointers must be held down - 1 for drag/resize, 2 for gesture.
             *
             * Use it with `interactable.<action>able({ manualStart: false })` to always
             * [start actions manually](https://github.com/taye/interact.js/issues/114)
             *
             * @param {object} action   The action to be performed - drag, resize, etc.
             * @param {Interactable} target  The Interactable to target
             * @param {Element} element The DOM Element to target
             * @return {Boolean} Whether the interaction was successfully started
             */
            start(action, interactable, element) {
              if (this.interacting() || !this.pointerIsDown || this.pointers.length < (action.name === "gesture" ? 2 : 1) || !interactable.options[action.name].enabled) {
                return false;
              }
              copyAction(this.prepared, action);
              this.interactable = interactable;
              this.element = element;
              this.rect = interactable.getRect(element);
              this.edges = this.prepared.edges ? extend2({}, this.prepared.edges) : {
                left: true,
                right: true,
                top: true,
                bottom: true
              };
              this._stopped = false;
              this._interacting = this._doPhase({
                interaction: this,
                event: this.downEvent,
                phase: "start"
              }) && !this._stopped;
              return this._interacting;
            }
            pointerMove(pointer, event, eventTarget) {
              if (!this.simulation && !(this.modification && this.modification.endResult)) {
                this.updatePointer(pointer, event, eventTarget, false);
              }
              const duplicateMove = this.coords.cur.page.x === this.coords.prev.page.x && this.coords.cur.page.y === this.coords.prev.page.y && this.coords.cur.client.x === this.coords.prev.client.x && this.coords.cur.client.y === this.coords.prev.client.y;
              let dx;
              let dy;
              if (this.pointerIsDown && !this.pointerWasMoved) {
                dx = this.coords.cur.client.x - this.coords.start.client.x;
                dy = this.coords.cur.client.y - this.coords.start.client.y;
                this.pointerWasMoved = hypot(dx, dy) > this.pointerMoveTolerance;
              }
              const pointerIndex = this.getPointerIndex(pointer);
              const signalArg = {
                pointer,
                pointerIndex,
                pointerInfo: this.pointers[pointerIndex],
                event,
                type: "move",
                eventTarget,
                dx,
                dy,
                duplicate: duplicateMove,
                interaction: this
              };
              if (!duplicateMove) {
                setCoordVelocity(this.coords.velocity, this.coords.delta);
              }
              this._scopeFire("interactions:move", signalArg);
              if (!duplicateMove && !this.simulation) {
                if (this.interacting()) {
                  signalArg.type = null;
                  this.move(signalArg);
                }
                if (this.pointerWasMoved) {
                  copyCoords(this.coords.prev, this.coords.cur);
                }
              }
            }
            /**
             * ```js
             * interact(target)
             *   .draggable(true)
             *   .on('dragmove', function (event) {
             *     if (someCondition) {
             *       // change the snap settings
             *       event.interactable.draggable({ snap: { targets: [] }})
             *       // fire another move event with re-calculated snap
             *       event.interaction.move()
             *     }
             *   })
             * ```
             *
             * Force a move of the current action at the same coordinates. Useful if
             * snap/restrict has been changed and you want a movement with the new
             * settings.
             */
            move(signalArg) {
              if (!signalArg || !signalArg.event) {
                setZeroCoords(this.coords.delta);
              }
              signalArg = extend2({
                pointer: this._latestPointer.pointer,
                event: this._latestPointer.event,
                eventTarget: this._latestPointer.eventTarget,
                interaction: this
              }, signalArg || {});
              signalArg.phase = "move";
              this._doPhase(signalArg);
            }
            // End interact move events and stop auto-scroll unless simulation is running
            pointerUp(pointer, event, eventTarget, curEventTarget) {
              let pointerIndex = this.getPointerIndex(pointer);
              if (pointerIndex === -1) {
                pointerIndex = this.updatePointer(pointer, event, eventTarget, false);
              }
              const type = /cancel$/i.test(event.type) ? "cancel" : "up";
              this._scopeFire(`interactions:${type}`, {
                pointer,
                pointerIndex,
                pointerInfo: this.pointers[pointerIndex],
                event,
                eventTarget,
                type,
                curEventTarget,
                interaction: this
              });
              if (!this.simulation) {
                this.end(event);
              }
              this.removePointer(pointer, event);
            }
            documentBlur(event) {
              this.end(event);
              this._scopeFire("interactions:blur", {
                event,
                type: "blur",
                interaction: this
              });
            }
            /**
             * ```js
             * interact(target)
             *   .draggable(true)
             *   .on('move', function (event) {
             *     if (event.pageX > 1000) {
             *       // end the current action
             *       event.interaction.end()
             *       // stop all further listeners from being called
             *       event.stopImmediatePropagation()
             *     }
             *   })
             * ```
             *
             * @param {PointerEvent} [event]
             */
            end(event) {
              this._ending = true;
              event = event || this._latestPointer.event;
              let endPhaseResult;
              if (this.interacting()) {
                endPhaseResult = this._doPhase({
                  event,
                  interaction: this,
                  phase: "end"
                });
              }
              this._ending = false;
              if (endPhaseResult === true) {
                this.stop();
              }
            }
            currentAction() {
              return this._interacting ? this.prepared.name : null;
            }
            interacting() {
              return this._interacting;
            }
            /** */
            stop() {
              this._scopeFire("interactions:stop", {
                interaction: this
              });
              this.interactable = this.element = null;
              this._interacting = false;
              this._stopped = true;
              this.prepared.name = this.prevEvent = null;
            }
            getPointerIndex(pointer) {
              const pointerId = getPointerId(pointer);
              return this.pointerType === "mouse" || this.pointerType === "pen" ? this.pointers.length - 1 : findIndex(this.pointers, (curPointer) => curPointer.id === pointerId);
            }
            getPointerInfo(pointer) {
              return this.pointers[this.getPointerIndex(pointer)];
            }
            updatePointer(pointer, event, eventTarget, down) {
              const id = getPointerId(pointer);
              let pointerIndex = this.getPointerIndex(pointer);
              let pointerInfo = this.pointers[pointerIndex];
              down = down === false ? false : down || /(down|start)$/i.test(event.type);
              if (!pointerInfo) {
                pointerInfo = new PointerInfo(id, pointer, event, null, null);
                pointerIndex = this.pointers.length;
                this.pointers.push(pointerInfo);
              } else {
                pointerInfo.pointer = pointer;
              }
              setCoords(this.coords.cur, this.pointers.map((p) => p.pointer), this._now());
              setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur);
              if (down) {
                this.pointerIsDown = true;
                pointerInfo.downTime = this.coords.cur.timeStamp;
                pointerInfo.downTarget = eventTarget;
                utils_pointerExtend(this.downPointer, pointer);
                if (!this.interacting()) {
                  copyCoords(this.coords.start, this.coords.cur);
                  copyCoords(this.coords.prev, this.coords.cur);
                  this.downEvent = event;
                  this.pointerWasMoved = false;
                }
              }
              this._updateLatestPointer(pointer, event, eventTarget);
              this._scopeFire("interactions:update-pointer", {
                pointer,
                event,
                eventTarget,
                down,
                pointerInfo,
                pointerIndex,
                interaction: this
              });
              return pointerIndex;
            }
            removePointer(pointer, event) {
              const pointerIndex = this.getPointerIndex(pointer);
              if (pointerIndex === -1) {
                return;
              }
              const pointerInfo = this.pointers[pointerIndex];
              this._scopeFire("interactions:remove-pointer", {
                pointer,
                event,
                eventTarget: null,
                pointerIndex,
                pointerInfo,
                interaction: this
              });
              this.pointers.splice(pointerIndex, 1);
              this.pointerIsDown = false;
            }
            _updateLatestPointer(pointer, event, eventTarget) {
              this._latestPointer.pointer = pointer;
              this._latestPointer.event = event;
              this._latestPointer.eventTarget = eventTarget;
            }
            destroy() {
              this._latestPointer.pointer = null;
              this._latestPointer.event = null;
              this._latestPointer.eventTarget = null;
            }
            _createPreparedEvent(event, phase, preEnd, type) {
              return new InteractEvent_InteractEvent(this, event, this.prepared.name, phase, this.element, preEnd, type);
            }
            _fireEvent(iEvent) {
              this.interactable.fire(iEvent);
              if (!this.prevEvent || iEvent.timeStamp >= this.prevEvent.timeStamp) {
                this.prevEvent = iEvent;
              }
            }
            _doPhase(signalArg) {
              const {
                event,
                phase,
                preEnd,
                type
              } = signalArg;
              const {
                rect
              } = this;
              if (rect && phase === "move") {
                addEdges(this.edges, rect, this.coords.delta[this.interactable.options.deltaSource]);
                rect.width = rect.right - rect.left;
                rect.height = rect.bottom - rect.top;
              }
              const beforeResult = this._scopeFire(`interactions:before-action-${phase}`, signalArg);
              if (beforeResult === false) {
                return false;
              }
              const iEvent = signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type);
              this._scopeFire(`interactions:action-${phase}`, signalArg);
              if (phase === "start") {
                this.prevEvent = iEvent;
              }
              this._fireEvent(iEvent);
              this._scopeFire(`interactions:after-action-${phase}`, signalArg);
              return true;
            }
            _now() {
              return Date.now();
            }
          }
          var core_Interaction = Interaction_Interaction;
          function preventDefault(newValue) {
            if (/^(always|never|auto)$/.test(newValue)) {
              this.options.preventDefault = newValue;
              return this;
            }
            if (is.bool(newValue)) {
              this.options.preventDefault = newValue ? "always" : "never";
              return this;
            }
            return this.options.preventDefault;
          }
          function checkAndPreventDefault(interactable, scope, event) {
            const setting = interactable.options.preventDefault;
            if (setting === "never") {
              return;
            }
            if (setting === "always") {
              event.preventDefault();
              return;
            }
            if (scope.events.supportsPassive && /^touch(start|move)$/.test(event.type)) {
              const doc = getWindow2(event.target).document;
              const docOptions = scope.getDocOptions(doc);
              if (!(docOptions && docOptions.events) || docOptions.events.passive !== false) {
                return;
              }
            }
            if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {
              return;
            }
            if (is.element(event.target) && matchesSelector(event.target, "input,select,textarea,[contenteditable=true],[contenteditable=true] *")) {
              return;
            }
            event.preventDefault();
          }
          function onInteractionEvent({
            interaction,
            event
          }) {
            if (interaction.interactable) {
              interaction.interactable.checkAndPreventDefault(event);
            }
          }
          function interactablePreventDefault_install(scope) {
            const {
              Interactable
            } = scope;
            Interactable.prototype.preventDefault = preventDefault;
            Interactable.prototype.checkAndPreventDefault = function(event) {
              return checkAndPreventDefault(this, scope, event);
            };
            scope.interactions.docEvents.push({
              type: "dragstart",
              listener(event) {
                for (const interaction of scope.interactions.list) {
                  if (interaction.element && (interaction.element === event.target || nodeContains(interaction.element, event.target))) {
                    interaction.interactable.checkAndPreventDefault(event);
                    return;
                  }
                }
              }
            });
          }
          var interactablePreventDefault = {
            id: "core/interactablePreventDefault",
            install: interactablePreventDefault_install,
            listeners: ["down", "move", "up", "cancel"].reduce((acc, eventType) => {
              acc[`interactions:${eventType}`] = onInteractionEvent;
              return acc;
            }, {})
          };
          const finder = {
            methodOrder: ["simulationResume", "mouseOrPen", "hasPointer", "idle"],
            search(details) {
              for (const method of finder.methodOrder) {
                const interaction = finder[method](details);
                if (interaction) {
                  return interaction;
                }
              }
              return null;
            },
            // try to resume simulation with a new pointer
            simulationResume({
              pointerType,
              eventType,
              eventTarget,
              scope
            }) {
              if (!/down|start/i.test(eventType)) {
                return null;
              }
              for (const interaction of scope.interactions.list) {
                let element = eventTarget;
                if (interaction.simulation && interaction.simulation.allowResume && interaction.pointerType === pointerType) {
                  while (element) {
                    if (element === interaction.element) {
                      return interaction;
                    }
                    element = parentNode2(element);
                  }
                }
              }
              return null;
            },
            // if it's a mouse or pen interaction
            mouseOrPen({
              pointerId,
              pointerType,
              eventType,
              scope
            }) {
              if (pointerType !== "mouse" && pointerType !== "pen") {
                return null;
              }
              let firstNonActive;
              for (const interaction of scope.interactions.list) {
                if (interaction.pointerType === pointerType) {
                  if (interaction.simulation && !hasPointerId(interaction, pointerId)) {
                    continue;
                  }
                  if (interaction.interacting()) {
                    return interaction;
                  } else if (!firstNonActive) {
                    firstNonActive = interaction;
                  }
                }
              }
              if (firstNonActive) {
                return firstNonActive;
              }
              for (const interaction of scope.interactions.list) {
                if (interaction.pointerType === pointerType && !(/down/i.test(eventType) && interaction.simulation)) {
                  return interaction;
                }
              }
              return null;
            },
            // get interaction that has this pointer
            hasPointer({
              pointerId,
              scope
            }) {
              for (const interaction of scope.interactions.list) {
                if (hasPointerId(interaction, pointerId)) {
                  return interaction;
                }
              }
              return null;
            },
            // get first idle interaction with a matching pointerType
            idle({
              pointerType,
              scope
            }) {
              for (const interaction of scope.interactions.list) {
                if (interaction.pointers.length === 1) {
                  const target2 = interaction.interactable;
                  if (target2 && !(target2.options.gesture && target2.options.gesture.enabled)) {
                    continue;
                  }
                } else if (interaction.pointers.length >= 2) {
                  continue;
                }
                if (!interaction.interacting() && pointerType === interaction.pointerType) {
                  return interaction;
                }
              }
              return null;
            }
          };
          function hasPointerId(interaction, pointerId) {
            return interaction.pointers.some(({
              id
            }) => id === pointerId);
          }
          var interactionFinder = finder;
          const methodNames = ["pointerDown", "pointerMove", "pointerUp", "updatePointer", "removePointer", "windowBlur"];
          function interactions_install(scope) {
            const listeners = {};
            for (const method of methodNames) {
              listeners[method] = doOnInteractions(method, scope);
            }
            const pEventTypes = utils_browser.pEventTypes;
            let docEvents;
            if (utils_domObjects.PointerEvent) {
              docEvents = [{
                type: pEventTypes.down,
                listener: releasePointersOnRemovedEls
              }, {
                type: pEventTypes.down,
                listener: listeners.pointerDown
              }, {
                type: pEventTypes.move,
                listener: listeners.pointerMove
              }, {
                type: pEventTypes.up,
                listener: listeners.pointerUp
              }, {
                type: pEventTypes.cancel,
                listener: listeners.pointerUp
              }];
            } else {
              docEvents = [{
                type: "mousedown",
                listener: listeners.pointerDown
              }, {
                type: "mousemove",
                listener: listeners.pointerMove
              }, {
                type: "mouseup",
                listener: listeners.pointerUp
              }, {
                type: "touchstart",
                listener: releasePointersOnRemovedEls
              }, {
                type: "touchstart",
                listener: listeners.pointerDown
              }, {
                type: "touchmove",
                listener: listeners.pointerMove
              }, {
                type: "touchend",
                listener: listeners.pointerUp
              }, {
                type: "touchcancel",
                listener: listeners.pointerUp
              }];
            }
            docEvents.push({
              type: "blur",
              listener(event) {
                for (const interaction of scope.interactions.list) {
                  interaction.documentBlur(event);
                }
              }
            });
            scope.prevTouchTime = 0;
            scope.Interaction = class extends core_Interaction {
              get pointerMoveTolerance() {
                return scope.interactions.pointerMoveTolerance;
              }
              set pointerMoveTolerance(value) {
                scope.interactions.pointerMoveTolerance = value;
              }
              _now() {
                return scope.now();
              }
            };
            scope.interactions = {
              // all active and idle interactions
              list: [],
              new(options) {
                options.scopeFire = (name, arg) => scope.fire(name, arg);
                const interaction = new scope.Interaction(options);
                scope.interactions.list.push(interaction);
                return interaction;
              },
              listeners,
              docEvents,
              pointerMoveTolerance: 1
            };
            function releasePointersOnRemovedEls() {
              for (const interaction of scope.interactions.list) {
                if (!interaction.pointerIsDown || interaction.pointerType !== "touch" || interaction._interacting) {
                  continue;
                }
                for (const pointer of interaction.pointers) {
                  if (!scope.documents.some(({
                    doc
                  }) => nodeContains(doc, pointer.downTarget))) {
                    interaction.removePointer(pointer.pointer, pointer.event);
                  }
                }
              }
            }
            scope.usePlugin(interactablePreventDefault);
          }
          function doOnInteractions(method, scope) {
            return function(event) {
              const interactions = scope.interactions.list;
              const pointerType = getPointerType(event);
              const [eventTarget, curEventTarget] = getEventTargets(event);
              const matches2 = [];
              if (/^touch/.test(event.type)) {
                scope.prevTouchTime = scope.now();
                for (const changedTouch of event.changedTouches) {
                  const pointer = changedTouch;
                  const pointerId = getPointerId(pointer);
                  const searchDetails = {
                    pointer,
                    pointerId,
                    pointerType,
                    eventType: event.type,
                    eventTarget,
                    curEventTarget,
                    scope
                  };
                  const interaction = getInteraction(searchDetails);
                  matches2.push([searchDetails.pointer, searchDetails.eventTarget, searchDetails.curEventTarget, interaction]);
                }
              } else {
                let invalidPointer = false;
                if (!utils_browser.supportsPointerEvent && /mouse/.test(event.type)) {
                  for (let i = 0; i < interactions.length && !invalidPointer; i++) {
                    invalidPointer = interactions[i].pointerType !== "mouse" && interactions[i].pointerIsDown;
                  }
                  invalidPointer = invalidPointer || scope.now() - scope.prevTouchTime < 500 || // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated
                  event.timeStamp === 0;
                }
                if (!invalidPointer) {
                  const searchDetails = {
                    pointer: event,
                    pointerId: getPointerId(event),
                    pointerType,
                    eventType: event.type,
                    curEventTarget,
                    eventTarget,
                    scope
                  };
                  const interaction = getInteraction(searchDetails);
                  matches2.push([searchDetails.pointer, searchDetails.eventTarget, searchDetails.curEventTarget, interaction]);
                }
              }
              for (const [pointer, eventTarget2, curEventTarget2, interaction] of matches2) {
                interaction[method](pointer, event, eventTarget2, curEventTarget2);
              }
            };
          }
          function getInteraction(searchDetails) {
            const {
              pointerType,
              scope
            } = searchDetails;
            const foundInteraction = interactionFinder.search(searchDetails);
            const signalArg = {
              interaction: foundInteraction,
              searchDetails
            };
            scope.fire("interactions:find", signalArg);
            return signalArg.interaction || scope.interactions.new({
              pointerType
            });
          }
          function onDocSignal({
            doc,
            scope,
            options
          }, eventMethodName) {
            const {
              interactions: {
                docEvents
              },
              events: events22
            } = scope;
            const eventMethod = events22[eventMethodName];
            if (scope.browser.isIOS && !options.events) {
              options.events = {
                passive: false
              };
            }
            for (const eventType in events22.delegatedEvents) {
              eventMethod(doc, eventType, events22.delegateListener);
              eventMethod(doc, eventType, events22.delegateUseCapture, true);
            }
            const eventOptions = options && options.events;
            for (const {
              type,
              listener
            } of docEvents) {
              eventMethod(doc, type, listener, eventOptions);
            }
          }
          const interactions_interactions = {
            id: "core/interactions",
            install: interactions_install,
            listeners: {
              "scope:add-document": (arg) => onDocSignal(arg, "add"),
              "scope:remove-document": (arg) => onDocSignal(arg, "remove"),
              "interactable:unset": ({
                interactable
              }, scope) => {
                for (let i = scope.interactions.list.length - 1; i >= 0; i--) {
                  const interaction = scope.interactions.list[i];
                  if (interaction.interactable !== interactable) {
                    continue;
                  }
                  interaction.stop();
                  scope.fire("interactions:destroy", {
                    interaction
                  });
                  interaction.destroy();
                  if (scope.interactions.list.length > 2) {
                    scope.interactions.list.splice(i, 1);
                  }
                }
              }
            },
            onDocSignal,
            doOnInteractions,
            methodNames
          };
          var core_interactions = interactions_interactions;
          class scope_Scope {
            // main window
            // main document
            // main window
            // all documents being listened to
            constructor() {
              this.id = `__interact_scope_${Math.floor(Math.random() * 100)}`;
              this.isInitialized = false;
              this.listenerMaps = [];
              this.browser = utils_browser;
              this.defaults = clone2(defaultOptions_defaults);
              this.Eventable = Eventable_Eventable;
              this.actions = {
                map: {},
                phases: {
                  start: true,
                  move: true,
                  end: true
                },
                methodDict: {},
                phaselessTypes: {}
              };
              this.interactStatic = createInteractStatic(this);
              this.InteractEvent = InteractEvent_InteractEvent;
              this.Interactable = void 0;
              this.interactables = new InteractableSet_InteractableSet(this);
              this._win = void 0;
              this.document = void 0;
              this.window = void 0;
              this.documents = [];
              this._plugins = {
                list: [],
                map: {}
              };
              this.onWindowUnload = (event) => this.removeDocument(event.target);
              const scope = this;
              this.Interactable = class extends Interactable_Interactable {
                get _defaults() {
                  return scope.defaults;
                }
                set(options) {
                  super.set(options);
                  scope.fire("interactable:set", {
                    options,
                    interactable: this
                  });
                  return this;
                }
                unset() {
                  super.unset();
                  scope.interactables.list.splice(scope.interactables.list.indexOf(this), 1);
                  scope.fire("interactable:unset", {
                    interactable: this
                  });
                }
              };
            }
            addListeners(map, id) {
              this.listenerMaps.push({
                id,
                map
              });
            }
            fire(name, arg) {
              for (const {
                map: {
                  [name]: listener
                }
              } of this.listenerMaps) {
                if (!!listener && listener(arg, this, name) === false) {
                  return false;
                }
              }
            }
            init(window2) {
              return this.isInitialized ? this : initScope(this, window2);
            }
            pluginIsInstalled(plugin2) {
              return this._plugins.map[plugin2.id] || this._plugins.list.indexOf(plugin2) !== -1;
            }
            usePlugin(plugin2, options) {
              if (!this.isInitialized) {
                return this;
              }
              if (this.pluginIsInstalled(plugin2)) {
                return this;
              }
              if (plugin2.id) {
                this._plugins.map[plugin2.id] = plugin2;
              }
              this._plugins.list.push(plugin2);
              if (plugin2.install) {
                plugin2.install(this, options);
              }
              if (plugin2.listeners && plugin2.before) {
                let index2 = 0;
                const len = this.listenerMaps.length;
                const before = plugin2.before.reduce((acc, id) => {
                  acc[id] = true;
                  acc[pluginIdRoot(id)] = true;
                  return acc;
                }, {});
                for (; index2 < len; index2++) {
                  const otherId = this.listenerMaps[index2].id;
                  if (before[otherId] || before[pluginIdRoot(otherId)]) {
                    break;
                  }
                }
                this.listenerMaps.splice(index2, 0, {
                  id: plugin2.id,
                  map: plugin2.listeners
                });
              } else if (plugin2.listeners) {
                this.listenerMaps.push({
                  id: plugin2.id,
                  map: plugin2.listeners
                });
              }
              return this;
            }
            addDocument(doc, options) {
              if (this.getDocIndex(doc) !== -1) {
                return false;
              }
              const window2 = getWindow2(doc);
              options = options ? extend2({}, options) : {};
              this.documents.push({
                doc,
                options
              });
              this.events.documents.push(doc);
              if (doc !== this.document) {
                this.events.add(window2, "unload", this.onWindowUnload);
              }
              this.fire("scope:add-document", {
                doc,
                window: window2,
                scope: this,
                options
              });
            }
            removeDocument(doc) {
              const index2 = this.getDocIndex(doc);
              const window2 = getWindow2(doc);
              const options = this.documents[index2].options;
              this.events.remove(window2, "unload", this.onWindowUnload);
              this.documents.splice(index2, 1);
              this.events.documents.splice(index2, 1);
              this.fire("scope:remove-document", {
                doc,
                window: window2,
                scope: this,
                options
              });
            }
            getDocIndex(doc) {
              for (let i = 0; i < this.documents.length; i++) {
                if (this.documents[i].doc === doc) {
                  return i;
                }
              }
              return -1;
            }
            getDocOptions(doc) {
              const docIndex = this.getDocIndex(doc);
              return docIndex === -1 ? null : this.documents[docIndex].options;
            }
            now() {
              return (this.window.Date || Date).now();
            }
          }
          function initScope(scope, window2) {
            scope.isInitialized = true;
            window_init(window2);
            utils_domObjects.init(window2);
            utils_browser.init(window2);
            raf2.init(window2);
            scope.window = window2;
            scope.document = window2.document;
            scope.usePlugin(core_interactions);
            scope.usePlugin(events2);
            return scope;
          }
          function pluginIdRoot(id) {
            return id && id.replace(/\/.*$/, "");
          }
          const interact_scope = new scope_Scope();
          const interact_interact = interact_scope.interactStatic;
          var _interactjs_interact = interact_interact;
          const interact_init = (win2) => interact_scope.init(win2);
          if (typeof window === "object" && !!window) {
            interact_init(window);
          }
          function InteractableMethods_install(scope) {
            const {
              /** @lends Interactable */
              Interactable
              // tslint:disable-line no-shadowed-variable
            } = scope;
            Interactable.prototype.getAction = function getAction(pointer, event, interaction, element) {
              const action = defaultActionChecker(this, event, interaction, element, scope);
              if (this.options.actionChecker) {
                return this.options.actionChecker(pointer, event, action, this, element, interaction);
              }
              return action;
            };
            Interactable.prototype.ignoreFrom = warnOnce(function(newValue) {
              return this._backCompatOption("ignoreFrom", newValue);
            }, "Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).");
            Interactable.prototype.allowFrom = warnOnce(function(newValue) {
              return this._backCompatOption("allowFrom", newValue);
            }, "Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).");
            Interactable.prototype.actionChecker = actionChecker;
            Interactable.prototype.styleCursor = styleCursor;
          }
          function defaultActionChecker(interactable, event, interaction, element, scope) {
            const rect = interactable.getRect(element);
            const buttons = event.buttons || {
              0: 1,
              1: 4,
              3: 8,
              4: 16
            }[event.button];
            const arg = {
              action: null,
              interactable,
              interaction,
              element,
              rect,
              buttons
            };
            scope.fire("auto-start:check", arg);
            return arg.action;
          }
          function styleCursor(newValue) {
            if (is.bool(newValue)) {
              this.options.styleCursor = newValue;
              return this;
            }
            if (newValue === null) {
              delete this.options.styleCursor;
              return this;
            }
            return this.options.styleCursor;
          }
          function actionChecker(checker) {
            if (is.func(checker)) {
              this.options.actionChecker = checker;
              return this;
            }
            if (checker === null) {
              delete this.options.actionChecker;
              return this;
            }
            return this.options.actionChecker;
          }
          var InteractableMethods = {
            id: "auto-start/interactableMethods",
            install: InteractableMethods_install
          };
          function base_install(scope) {
            const {
              interactStatic: interact,
              defaults: defaults2
            } = scope;
            scope.usePlugin(InteractableMethods);
            defaults2.base.actionChecker = null;
            defaults2.base.styleCursor = true;
            extend2(defaults2.perAction, {
              manualStart: false,
              max: Infinity,
              maxPerElement: 1,
              allowFrom: null,
              ignoreFrom: null,
              // only allow left button by default
              // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value
              mouseButtons: 1
            });
            interact.maxInteractions = (newValue) => maxInteractions(newValue, scope);
            scope.autoStart = {
              // Allow this many interactions to happen simultaneously
              maxInteractions: Infinity,
              withinInteractionLimit,
              cursorElement: null
            };
          }
          function prepareOnDown({
            interaction,
            pointer,
            event,
            eventTarget
          }, scope) {
            if (interaction.interacting()) {
              return;
            }
            const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope);
            prepare(interaction, actionInfo, scope);
          }
          function prepareOnMove({
            interaction,
            pointer,
            event,
            eventTarget
          }, scope) {
            if (interaction.pointerType !== "mouse" || interaction.pointerIsDown || interaction.interacting()) {
              return;
            }
            const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope);
            prepare(interaction, actionInfo, scope);
          }
          function startOnMove(arg, scope) {
            const {
              interaction
            } = arg;
            if (!interaction.pointerIsDown || interaction.interacting() || !interaction.pointerWasMoved || !interaction.prepared.name) {
              return;
            }
            scope.fire("autoStart:before-start", arg);
            const {
              interactable
            } = interaction;
            const actionName = interaction.prepared.name;
            if (actionName && interactable) {
              if (interactable.options[actionName].manualStart || !withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)) {
                interaction.stop();
              } else {
                interaction.start(interaction.prepared, interactable, interaction.element);
                setInteractionCursor(interaction, scope);
              }
            }
          }
          function clearCursorOnStop({
            interaction
          }, scope) {
            const {
              interactable
            } = interaction;
            if (interactable && interactable.options.styleCursor) {
              setCursor(interaction.element, "", scope);
            }
          }
          function validateAction(action, interactable, element, eventTarget, scope) {
            if (interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) && interactable.options[action.name].enabled && withinInteractionLimit(interactable, element, action, scope)) {
              return action;
            }
            return null;
          }
          function validateMatches(interaction, pointer, event, matches2, matchElements, eventTarget, scope) {
            for (let i = 0, len = matches2.length; i < len; i++) {
              const match = matches2[i];
              const matchElement = matchElements[i];
              const matchAction = match.getAction(pointer, event, interaction, matchElement);
              if (!matchAction) {
                continue;
              }
              const action = validateAction(matchAction, match, matchElement, eventTarget, scope);
              if (action) {
                return {
                  action,
                  interactable: match,
                  element: matchElement
                };
              }
            }
            return {
              action: null,
              interactable: null,
              element: null
            };
          }
          function getActionInfo(interaction, pointer, event, eventTarget, scope) {
            let matches2 = [];
            let matchElements = [];
            let element = eventTarget;
            function pushMatches(interactable) {
              matches2.push(interactable);
              matchElements.push(element);
            }
            while (is.element(element)) {
              matches2 = [];
              matchElements = [];
              scope.interactables.forEachMatch(element, pushMatches);
              const actionInfo = validateMatches(interaction, pointer, event, matches2, matchElements, eventTarget, scope);
              if (actionInfo.action && !actionInfo.interactable.options[actionInfo.action.name].manualStart) {
                return actionInfo;
              }
              element = parentNode2(element);
            }
            return {
              action: null,
              interactable: null,
              element: null
            };
          }
          function prepare(interaction, {
            action,
            interactable,
            element
          }, scope) {
            action = action || {
              name: null
            };
            interaction.interactable = interactable;
            interaction.element = element;
            copyAction(interaction.prepared, action);
            interaction.rect = interactable && action.name ? interactable.getRect(element) : null;
            setInteractionCursor(interaction, scope);
            scope.fire("autoStart:prepared", {
              interaction
            });
          }
          function withinInteractionLimit(interactable, element, action, scope) {
            const options = interactable.options;
            const maxActions = options[action.name].max;
            const maxPerElement = options[action.name].maxPerElement;
            const autoStartMax = scope.autoStart.maxInteractions;
            let activeInteractions = 0;
            let interactableCount = 0;
            let elementCount = 0;
            if (!(maxActions && maxPerElement && autoStartMax)) {
              return false;
            }
            for (const interaction of scope.interactions.list) {
              const otherAction = interaction.prepared.name;
              if (!interaction.interacting()) {
                continue;
              }
              activeInteractions++;
              if (activeInteractions >= autoStartMax) {
                return false;
              }
              if (interaction.interactable !== interactable) {
                continue;
              }
              interactableCount += otherAction === action.name ? 1 : 0;
              if (interactableCount >= maxActions) {
                return false;
              }
              if (interaction.element === element) {
                elementCount++;
                if (otherAction === action.name && elementCount >= maxPerElement) {
                  return false;
                }
              }
            }
            return autoStartMax > 0;
          }
          function maxInteractions(newValue, scope) {
            if (is.number(newValue)) {
              scope.autoStart.maxInteractions = newValue;
              return this;
            }
            return scope.autoStart.maxInteractions;
          }
          function setCursor(element, cursor, scope) {
            const {
              cursorElement: prevCursorElement
            } = scope.autoStart;
            if (prevCursorElement && prevCursorElement !== element) {
              prevCursorElement.style.cursor = "";
            }
            element.ownerDocument.documentElement.style.cursor = cursor;
            element.style.cursor = cursor;
            scope.autoStart.cursorElement = cursor ? element : null;
          }
          function setInteractionCursor(interaction, scope) {
            const {
              interactable,
              element,
              prepared
            } = interaction;
            if (!(interaction.pointerType === "mouse" && interactable && interactable.options.styleCursor)) {
              if (scope.autoStart.cursorElement) {
                setCursor(scope.autoStart.cursorElement, "", scope);
              }
              return;
            }
            let cursor = "";
            if (prepared.name) {
              const cursorChecker = interactable.options[prepared.name].cursorChecker;
              if (is.func(cursorChecker)) {
                cursor = cursorChecker(prepared, interactable, element, interaction._interacting);
              } else {
                cursor = scope.actions.map[prepared.name].getCursor(prepared);
              }
            }
            setCursor(interaction.element, cursor || "", scope);
          }
          const autoStart = {
            id: "auto-start/base",
            before: ["actions"],
            install: base_install,
            listeners: {
              "interactions:down": prepareOnDown,
              "interactions:move": (arg, scope) => {
                prepareOnMove(arg, scope);
                startOnMove(arg, scope);
              },
              "interactions:stop": clearCursorOnStop
            },
            maxInteractions,
            withinInteractionLimit,
            validateAction
          };
          var base = autoStart;
          function beforeStart({
            interaction,
            eventTarget,
            dx,
            dy
          }, scope) {
            if (interaction.prepared.name !== "drag") {
              return;
            }
            const absX = Math.abs(dx);
            const absY = Math.abs(dy);
            const targetOptions = interaction.interactable.options.drag;
            const startAxis = targetOptions.startAxis;
            const currentAxis = absX > absY ? "x" : absX < absY ? "y" : "xy";
            interaction.prepared.axis = targetOptions.lockAxis === "start" ? currentAxis[0] : targetOptions.lockAxis;
            if (currentAxis !== "xy" && startAxis !== "xy" && startAxis !== currentAxis) {
              interaction.prepared.name = null;
              let element = eventTarget;
              const getDraggable = function(interactable) {
                if (interactable === interaction.interactable) {
                  return;
                }
                const options = interaction.interactable.options.drag;
                if (!options.manualStart && interactable.testIgnoreAllow(options, element, eventTarget)) {
                  const action = interactable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);
                  if (action && action.name === "drag" && checkStartAxis(currentAxis, interactable) && base.validateAction(action, interactable, element, eventTarget, scope)) {
                    return interactable;
                  }
                }
              };
              while (is.element(element)) {
                const interactable = scope.interactables.forEachMatch(element, getDraggable);
                if (interactable) {
                  interaction.prepared.name = "drag";
                  interaction.interactable = interactable;
                  interaction.element = element;
                  break;
                }
                element = parentNode2(element);
              }
            }
          }
          function checkStartAxis(startAxis, interactable) {
            if (!interactable) {
              return false;
            }
            const thisAxis = interactable.options.drag.startAxis;
            return startAxis === "xy" || thisAxis === "xy" || thisAxis === startAxis;
          }
          var dragAxis = {
            id: "auto-start/dragAxis",
            listeners: {
              "autoStart:before-start": beforeStart
            }
          };
          function hold_install(scope) {
            const {
              defaults: defaults2
            } = scope;
            scope.usePlugin(base);
            defaults2.perAction.hold = 0;
            defaults2.perAction.delay = 0;
          }
          function getHoldDuration(interaction) {
            const actionName = interaction.prepared && interaction.prepared.name;
            if (!actionName) {
              return null;
            }
            const options = interaction.interactable.options;
            return options[actionName].hold || options[actionName].delay;
          }
          const hold = {
            id: "auto-start/hold",
            install: hold_install,
            listeners: {
              "interactions:new": ({
                interaction
              }) => {
                interaction.autoStartHoldTimer = null;
              },
              "autoStart:prepared": ({
                interaction
              }) => {
                const hold2 = getHoldDuration(interaction);
                if (hold2 > 0) {
                  interaction.autoStartHoldTimer = setTimeout(() => {
                    interaction.start(interaction.prepared, interaction.interactable, interaction.element);
                  }, hold2);
                }
              },
              "interactions:move": ({
                interaction,
                duplicate
              }) => {
                if (interaction.autoStartHoldTimer && interaction.pointerWasMoved && !duplicate) {
                  clearTimeout(interaction.autoStartHoldTimer);
                  interaction.autoStartHoldTimer = null;
                }
              },
              // prevent regular down->move autoStart
              "autoStart:before-start": ({
                interaction
              }) => {
                const holdDuration = getHoldDuration(interaction);
                if (holdDuration > 0) {
                  interaction.prepared.name = null;
                }
              }
            },
            getHoldDuration
          };
          var auto_start_hold = hold;
          var auto_start_plugin = {
            id: "auto-start",
            install(scope) {
              scope.usePlugin(base);
              scope.usePlugin(auto_start_hold);
              scope.usePlugin(dragAxis);
            }
          };
          if (typeof window === "object" && !!window) {
            interact_init(window);
          }
          _interactjs_interact.use(auto_start_plugin);
          function plugin_install(scope) {
            const {
              defaults: defaults2,
              actions
            } = scope;
            scope.autoScroll = autoScroll;
            autoScroll.now = () => scope.now();
            actions.phaselessTypes.autoscroll = true;
            defaults2.perAction.autoScroll = autoScroll.defaults;
          }
          const autoScroll = {
            defaults: {
              enabled: false,
              margin: 60,
              // the item that is scrolled (Window or HTMLElement)
              container: null,
              // the scroll speed in pixels per second
              speed: 300
            },
            now: Date.now,
            interaction: null,
            i: 0,
            // the handle returned by window.setInterval
            // Direction each pulse is to scroll in
            x: 0,
            y: 0,
            isScrolling: false,
            prevTime: 0,
            margin: 0,
            speed: 0,
            start(interaction) {
              autoScroll.isScrolling = true;
              raf2.cancel(autoScroll.i);
              interaction.autoScroll = autoScroll;
              autoScroll.interaction = interaction;
              autoScroll.prevTime = autoScroll.now();
              autoScroll.i = raf2.request(autoScroll.scroll);
            },
            stop() {
              autoScroll.isScrolling = false;
              if (autoScroll.interaction) {
                autoScroll.interaction.autoScroll = null;
              }
              raf2.cancel(autoScroll.i);
            },
            // scroll the window by the values in scroll.x/y
            scroll() {
              const {
                interaction
              } = autoScroll;
              const {
                interactable,
                element
              } = interaction;
              const actionName = interaction.prepared.name;
              const options = interactable.options[actionName].autoScroll;
              const container = getContainer(options.container, interactable, element);
              const now = autoScroll.now();
              const dt = (now - autoScroll.prevTime) / 1e3;
              const s = options.speed * dt;
              if (s >= 1) {
                const scrollBy = {
                  x: autoScroll.x * s,
                  y: autoScroll.y * s
                };
                if (scrollBy.x || scrollBy.y) {
                  const prevScroll = getScroll(container);
                  if (is.window(container)) {
                    container.scrollBy(scrollBy.x, scrollBy.y);
                  } else if (container) {
                    container.scrollLeft += scrollBy.x;
                    container.scrollTop += scrollBy.y;
                  }
                  const curScroll = getScroll(container);
                  const delta = {
                    x: curScroll.x - prevScroll.x,
                    y: curScroll.y - prevScroll.y
                  };
                  if (delta.x || delta.y) {
                    interactable.fire({
                      type: "autoscroll",
                      target: element,
                      interactable,
                      delta,
                      interaction,
                      container
                    });
                  }
                }
                autoScroll.prevTime = now;
              }
              if (autoScroll.isScrolling) {
                raf2.cancel(autoScroll.i);
                autoScroll.i = raf2.request(autoScroll.scroll);
              }
            },
            check(interactable, actionName) {
              var _options$actionName$a;
              const options = interactable.options;
              return (_options$actionName$a = options[actionName].autoScroll) == null ? void 0 : _options$actionName$a.enabled;
            },
            onInteractionMove({
              interaction,
              pointer
            }) {
              if (!(interaction.interacting() && autoScroll.check(interaction.interactable, interaction.prepared.name))) {
                return;
              }
              if (interaction.simulation) {
                autoScroll.x = autoScroll.y = 0;
                return;
              }
              let top;
              let right;
              let bottom;
              let left;
              const {
                interactable,
                element
              } = interaction;
              const actionName = interaction.prepared.name;
              const options = interactable.options[actionName].autoScroll;
              const container = getContainer(options.container, interactable, element);
              if (is.window(container)) {
                left = pointer.clientX < autoScroll.margin;
                top = pointer.clientY < autoScroll.margin;
                right = pointer.clientX > container.innerWidth - autoScroll.margin;
                bottom = pointer.clientY > container.innerHeight - autoScroll.margin;
              } else {
                const rect = getElementClientRect(container);
                left = pointer.clientX < rect.left + autoScroll.margin;
                top = pointer.clientY < rect.top + autoScroll.margin;
                right = pointer.clientX > rect.right - autoScroll.margin;
                bottom = pointer.clientY > rect.bottom - autoScroll.margin;
              }
              autoScroll.x = right ? 1 : left ? -1 : 0;
              autoScroll.y = bottom ? 1 : top ? -1 : 0;
              if (!autoScroll.isScrolling) {
                autoScroll.margin = options.margin;
                autoScroll.speed = options.speed;
                autoScroll.start(interaction);
              }
            }
          };
          function getContainer(value, interactable, element) {
            return (is.string(value) ? getStringOptionResult(value, interactable, element) : value) || getWindow2(element);
          }
          function getScroll(container) {
            if (is.window(container)) {
              container = window.document.body;
            }
            return {
              x: container.scrollLeft,
              y: container.scrollTop
            };
          }
          const autoScrollPlugin = {
            id: "auto-scroll",
            install: plugin_install,
            listeners: {
              "interactions:new": ({
                interaction
              }) => {
                interaction.autoScroll = null;
              },
              "interactions:destroy": ({
                interaction
              }) => {
                interaction.autoScroll = null;
                autoScroll.stop();
                if (autoScroll.interaction) {
                  autoScroll.interaction = null;
                }
              },
              "interactions:stop": autoScroll.stop,
              "interactions:action-move": (arg) => autoScroll.onInteractionMove(arg)
            }
          };
          var auto_scroll_plugin = autoScrollPlugin;
          if (typeof window === "object" && !!window) {
            interact_init(window);
          }
          _interactjs_interact.use(auto_scroll_plugin);
          function drag_plugin_install(scope) {
            const {
              actions,
              Interactable,
              defaults: defaults2
            } = scope;
            Interactable.prototype.draggable = drag.draggable;
            actions.map.drag = drag;
            actions.methodDict.drag = "draggable";
            defaults2.actions.drag = drag.defaults;
          }
          function beforeMove({
            interaction
          }) {
            if (interaction.prepared.name !== "drag") {
              return;
            }
            const axis = interaction.prepared.axis;
            if (axis === "x") {
              interaction.coords.cur.page.y = interaction.coords.start.page.y;
              interaction.coords.cur.client.y = interaction.coords.start.client.y;
              interaction.coords.velocity.client.y = 0;
              interaction.coords.velocity.page.y = 0;
            } else if (axis === "y") {
              interaction.coords.cur.page.x = interaction.coords.start.page.x;
              interaction.coords.cur.client.x = interaction.coords.start.client.x;
              interaction.coords.velocity.client.x = 0;
              interaction.coords.velocity.page.x = 0;
            }
          }
          function move({
            iEvent,
            interaction
          }) {
            if (interaction.prepared.name !== "drag") {
              return;
            }
            const axis = interaction.prepared.axis;
            if (axis === "x" || axis === "y") {
              const opposite = axis === "x" ? "y" : "x";
              iEvent.page[opposite] = interaction.coords.start.page[opposite];
              iEvent.client[opposite] = interaction.coords.start.client[opposite];
              iEvent.delta[opposite] = 0;
            }
          }
          const plugin_draggable = function draggable(options) {
            if (is.object(options)) {
              this.options.drag.enabled = options.enabled !== false;
              this.setPerAction("drag", options);
              this.setOnEvents("drag", options);
              if (/^(xy|x|y|start)$/.test(options.lockAxis)) {
                this.options.drag.lockAxis = options.lockAxis;
              }
              if (/^(xy|x|y)$/.test(options.startAxis)) {
                this.options.drag.startAxis = options.startAxis;
              }
              return this;
            }
            if (is.bool(options)) {
              this.options.drag.enabled = options;
              return this;
            }
            return this.options.drag;
          };
          const drag = {
            id: "actions/drag",
            install: drag_plugin_install,
            listeners: {
              "interactions:before-action-move": beforeMove,
              "interactions:action-resume": beforeMove,
              // dragmove
              "interactions:action-move": move,
              "auto-start:check": (arg) => {
                const {
                  interaction,
                  interactable,
                  buttons
                } = arg;
                const dragOptions = interactable.options.drag;
                if (!(dragOptions && dragOptions.enabled) || // check mouseButton setting if the pointer is down
                interaction.pointerIsDown && /mouse|pointer/.test(interaction.pointerType) && (buttons & interactable.options.drag.mouseButtons) === 0) {
                  return void 0;
                }
                arg.action = {
                  name: "drag",
                  axis: dragOptions.lockAxis === "start" ? dragOptions.startAxis : dragOptions.lockAxis
                };
                return false;
              }
            },
            draggable: plugin_draggable,
            beforeMove,
            move,
            defaults: {
              startAxis: "xy",
              lockAxis: "xy"
            },
            getCursor() {
              return "move";
            }
          };
          var drag_plugin = drag;
          if (typeof window === "object" && !!window) {
            interact_init(window);
          }
          _interactjs_interact.use(drag_plugin);
          function resize_plugin_install(scope) {
            const {
              actions,
              browser: browser22,
              /** @lends Interactable */
              Interactable,
              // tslint:disable-line no-shadowed-variable
              defaults: defaults2
            } = scope;
            resize.cursors = initCursors(browser22);
            resize.defaultMargin = browser22.supportsTouch || browser22.supportsPointerEvent ? 20 : 10;
            Interactable.prototype.resizable = function(options) {
              return resizable(this, options, scope);
            };
            actions.map.resize = resize;
            actions.methodDict.resize = "resizable";
            defaults2.actions.resize = resize.defaults;
          }
          function resizeChecker(arg) {
            const {
              interaction,
              interactable,
              element,
              rect,
              buttons
            } = arg;
            if (!rect) {
              return void 0;
            }
            const page = extend2({}, interaction.coords.cur.page);
            const resizeOptions = interactable.options.resize;
            if (!(resizeOptions && resizeOptions.enabled) || // check mouseButton setting if the pointer is down
            interaction.pointerIsDown && /mouse|pointer/.test(interaction.pointerType) && (buttons & resizeOptions.mouseButtons) === 0) {
              return void 0;
            }
            if (is.object(resizeOptions.edges)) {
              const resizeEdges = {
                left: false,
                right: false,
                top: false,
                bottom: false
              };
              for (const edge in resizeEdges) {
                resizeEdges[edge] = checkResizeEdge(edge, resizeOptions.edges[edge], page, interaction._latestPointer.eventTarget, element, rect, resizeOptions.margin || resize.defaultMargin);
              }
              resizeEdges.left = resizeEdges.left && !resizeEdges.right;
              resizeEdges.top = resizeEdges.top && !resizeEdges.bottom;
              if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {
                arg.action = {
                  name: "resize",
                  edges: resizeEdges
                };
              }
            } else {
              const right = resizeOptions.axis !== "y" && page.x > rect.right - resize.defaultMargin;
              const bottom = resizeOptions.axis !== "x" && page.y > rect.bottom - resize.defaultMargin;
              if (right || bottom) {
                arg.action = {
                  name: "resize",
                  axes: (right ? "x" : "") + (bottom ? "y" : "")
                };
              }
            }
            return arg.action ? false : void 0;
          }
          function resizable(interactable, options, scope) {
            if (is.object(options)) {
              interactable.options.resize.enabled = options.enabled !== false;
              interactable.setPerAction("resize", options);
              interactable.setOnEvents("resize", options);
              if (is.string(options.axis) && /^x$|^y$|^xy$/.test(options.axis)) {
                interactable.options.resize.axis = options.axis;
              } else if (options.axis === null) {
                interactable.options.resize.axis = scope.defaults.actions.resize.axis;
              }
              if (is.bool(options.preserveAspectRatio)) {
                interactable.options.resize.preserveAspectRatio = options.preserveAspectRatio;
              } else if (is.bool(options.square)) {
                interactable.options.resize.square = options.square;
              }
              return interactable;
            }
            if (is.bool(options)) {
              interactable.options.resize.enabled = options;
              return interactable;
            }
            return interactable.options.resize;
          }
          function checkResizeEdge(name, value, page, element, interactableElement, rect, margin) {
            if (!value) {
              return false;
            }
            if (value === true) {
              const width = is.number(rect.width) ? rect.width : rect.right - rect.left;
              const height = is.number(rect.height) ? rect.height : rect.bottom - rect.top;
              margin = Math.min(margin, Math.abs((name === "left" || name === "right" ? width : height) / 2));
              if (width < 0) {
                if (name === "left") {
                  name = "right";
                } else if (name === "right") {
                  name = "left";
                }
              }
              if (height < 0) {
                if (name === "top") {
                  name = "bottom";
                } else if (name === "bottom") {
                  name = "top";
                }
              }
              if (name === "left") {
                return page.x < (width >= 0 ? rect.left : rect.right) + margin;
              }
              if (name === "top") {
                return page.y < (height >= 0 ? rect.top : rect.bottom) + margin;
              }
              if (name === "right") {
                return page.x > (width >= 0 ? rect.right : rect.left) - margin;
              }
              if (name === "bottom") {
                return page.y > (height >= 0 ? rect.bottom : rect.top) - margin;
              }
            }
            if (!is.element(element)) {
              return false;
            }
            return is.element(value) ? value === element : matchesUpTo(element, value, interactableElement);
          }
          function initCursors(browser22) {
            return browser22.isIe9 ? {
              x: "e-resize",
              y: "s-resize",
              xy: "se-resize",
              top: "n-resize",
              left: "w-resize",
              bottom: "s-resize",
              right: "e-resize",
              topleft: "se-resize",
              bottomright: "se-resize",
              topright: "ne-resize",
              bottomleft: "ne-resize"
            } : {
              x: "ew-resize",
              y: "ns-resize",
              xy: "nwse-resize",
              top: "ns-resize",
              left: "ew-resize",
              bottom: "ns-resize",
              right: "ew-resize",
              topleft: "nwse-resize",
              bottomright: "nwse-resize",
              topright: "nesw-resize",
              bottomleft: "nesw-resize"
            };
          }
          function start({
            iEvent,
            interaction
          }) {
            if (interaction.prepared.name !== "resize" || !interaction.prepared.edges) {
              return;
            }
            const resizeEvent = iEvent;
            const rect = interaction.rect;
            interaction._rects = {
              start: extend2({}, rect),
              corrected: extend2({}, rect),
              previous: extend2({}, rect),
              delta: {
                left: 0,
                right: 0,
                width: 0,
                top: 0,
                bottom: 0,
                height: 0
              }
            };
            resizeEvent.edges = interaction.prepared.edges;
            resizeEvent.rect = interaction._rects.corrected;
            resizeEvent.deltaRect = interaction._rects.delta;
          }
          function plugin_move({
            iEvent,
            interaction
          }) {
            if (interaction.prepared.name !== "resize" || !interaction.prepared.edges) {
              return;
            }
            const resizeEvent = iEvent;
            const resizeOptions = interaction.interactable.options.resize;
            const invert = resizeOptions.invert;
            const invertible = invert === "reposition" || invert === "negate";
            const current = interaction.rect;
            const {
              start: startRect,
              corrected,
              delta: deltaRect,
              previous
            } = interaction._rects;
            extend2(previous, corrected);
            if (invertible) {
              extend2(corrected, current);
              if (invert === "reposition") {
                if (corrected.top > corrected.bottom) {
                  const swap = corrected.top;
                  corrected.top = corrected.bottom;
                  corrected.bottom = swap;
                }
                if (corrected.left > corrected.right) {
                  const swap = corrected.left;
                  corrected.left = corrected.right;
                  corrected.right = swap;
                }
              }
            } else {
              corrected.top = Math.min(current.top, startRect.bottom);
              corrected.bottom = Math.max(current.bottom, startRect.top);
              corrected.left = Math.min(current.left, startRect.right);
              corrected.right = Math.max(current.right, startRect.left);
            }
            corrected.width = corrected.right - corrected.left;
            corrected.height = corrected.bottom - corrected.top;
            for (const edge in corrected) {
              deltaRect[edge] = corrected[edge] - previous[edge];
            }
            resizeEvent.edges = interaction.prepared.edges;
            resizeEvent.rect = corrected;
            resizeEvent.deltaRect = deltaRect;
          }
          function end({
            iEvent,
            interaction
          }) {
            if (interaction.prepared.name !== "resize" || !interaction.prepared.edges) {
              return;
            }
            const resizeEvent = iEvent;
            resizeEvent.edges = interaction.prepared.edges;
            resizeEvent.rect = interaction._rects.corrected;
            resizeEvent.deltaRect = interaction._rects.delta;
          }
          function updateEventAxes({
            iEvent,
            interaction
          }) {
            if (interaction.prepared.name !== "resize" || !interaction.resizeAxes) {
              return;
            }
            const options = interaction.interactable.options;
            const resizeEvent = iEvent;
            if (options.resize.square) {
              if (interaction.resizeAxes === "y") {
                resizeEvent.delta.x = resizeEvent.delta.y;
              } else {
                resizeEvent.delta.y = resizeEvent.delta.x;
              }
              resizeEvent.axes = "xy";
            } else {
              resizeEvent.axes = interaction.resizeAxes;
              if (interaction.resizeAxes === "x") {
                resizeEvent.delta.y = 0;
              } else if (interaction.resizeAxes === "y") {
                resizeEvent.delta.x = 0;
              }
            }
          }
          const resize = {
            id: "actions/resize",
            before: ["actions/drag"],
            install: resize_plugin_install,
            listeners: {
              "interactions:new": ({
                interaction
              }) => {
                interaction.resizeAxes = "xy";
              },
              "interactions:action-start": (arg) => {
                start(arg);
                updateEventAxes(arg);
              },
              "interactions:action-move": (arg) => {
                plugin_move(arg);
                updateEventAxes(arg);
              },
              "interactions:action-end": end,
              "auto-start:check": resizeChecker
            },
            defaults: {
              square: false,
              preserveAspectRatio: false,
              axis: "xy",
              // use default margin
              margin: NaN,
              // object with props left, right, top, bottom which are
              // true/false values to resize when the pointer is over that edge,
              // CSS selectors to match the handles for each direction
              // or the Elements for each handle
              edges: null,
              // a value of 'none' will limit the resize rect to a minimum of 0x0
              // 'negate' will alow the rect to have negative width/height
              // 'reposition' will keep the width/height positive by swapping
              // the top and bottom edges and/or swapping the left and right edges
              invert: "none"
            },
            cursors: null,
            getCursor({
              edges,
              axis,
              name
            }) {
              const cursors = resize.cursors;
              let result = null;
              if (axis) {
                result = cursors[name + axis];
              } else if (edges) {
                let cursorKey = "";
                for (const edge of ["top", "bottom", "left", "right"]) {
                  if (edges[edge]) {
                    cursorKey += edge;
                  }
                }
                result = cursors[cursorKey];
              }
              return result;
            },
            defaultMargin: null
          };
          var resize_plugin = resize;
          if (typeof window === "object" && !!window) {
            interact_init(window);
          }
          _interactjs_interact.use(resize_plugin);
          var edgeTarget = () => {
          };
          var snappers_elements = () => {
          };
          var grid = (grid2) => {
            const coordFields = [["x", "y"], ["left", "top"], ["right", "bottom"], ["width", "height"]].filter(([xField, yField]) => xField in grid2 || yField in grid2);
            const gridFunc = (x, y) => {
              const {
                range,
                limits = {
                  left: -Infinity,
                  right: Infinity,
                  top: -Infinity,
                  bottom: Infinity
                },
                offset: offset2 = {
                  x: 0,
                  y: 0
                }
              } = grid2;
              const result = {
                range,
                grid: grid2,
                x: null,
                y: null
              };
              for (const [xField, yField] of coordFields) {
                const gridx = Math.round((x - offset2.x) / grid2[xField]);
                const gridy = Math.round((y - offset2.y) / grid2[yField]);
                result[xField] = Math.max(limits.left, Math.min(limits.right, gridx * grid2[xField] + offset2.x));
                result[yField] = Math.max(limits.top, Math.min(limits.bottom, gridy * grid2[yField] + offset2.y));
              }
              return result;
            };
            gridFunc.grid = grid2;
            gridFunc.coordFields = coordFields;
            return gridFunc;
          };
          const snappersPlugin = {
            id: "snappers",
            install(scope) {
              const {
                interactStatic: interact
              } = scope;
              interact.snappers = extend2(interact.snappers || {}, all_namespaceObject);
              interact.createSnapGrid = interact.snappers.grid;
            }
          };
          var snappers_plugin = snappersPlugin;
          class Modification_Modification {
            constructor(interaction) {
              this.states = [];
              this.startOffset = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
              };
              this.startDelta = null;
              this.result = null;
              this.endResult = null;
              this.edges = void 0;
              this.interaction = void 0;
              this.interaction = interaction;
              this.result = createResult();
            }
            start({
              phase
            }, pageCoords) {
              const {
                interaction
              } = this;
              const modifierList = getModifierList(interaction);
              this.prepareStates(modifierList);
              this.edges = extend2({}, interaction.edges);
              this.startOffset = getRectOffset(interaction.rect, pageCoords);
              this.startDelta = {
                x: 0,
                y: 0
              };
              const arg = {
                phase,
                pageCoords,
                preEnd: false
              };
              this.result = createResult();
              this.startAll(arg);
              const result = this.result = this.setAll(arg);
              return result;
            }
            fillArg(arg) {
              const {
                interaction
              } = this;
              arg.interaction = interaction;
              arg.interactable = interaction.interactable;
              arg.element = interaction.element;
              arg.rect = arg.rect || interaction.rect;
              arg.edges = this.edges;
              arg.startOffset = this.startOffset;
            }
            startAll(arg) {
              this.fillArg(arg);
              for (const state of this.states) {
                if (state.methods.start) {
                  arg.state = state;
                  state.methods.start(arg);
                }
              }
            }
            setAll(arg) {
              this.fillArg(arg);
              const {
                phase,
                preEnd,
                skipModifiers,
                rect: unmodifiedRect
              } = arg;
              arg.coords = extend2({}, arg.pageCoords);
              arg.rect = extend2({}, unmodifiedRect);
              const states = skipModifiers ? this.states.slice(skipModifiers) : this.states;
              const newResult = createResult(arg.coords, arg.rect);
              for (const state of states) {
                const {
                  options
                } = state;
                const lastModifierCoords = extend2({}, arg.coords);
                let returnValue = null;
                if (state.methods.set && this.shouldDo(options, preEnd, phase)) {
                  arg.state = state;
                  returnValue = state.methods.set(arg);
                  addEdges(this.interaction.edges, arg.rect, {
                    x: arg.coords.x - lastModifierCoords.x,
                    y: arg.coords.y - lastModifierCoords.y
                  });
                }
                newResult.eventProps.push(returnValue);
              }
              newResult.delta.x = arg.coords.x - arg.pageCoords.x;
              newResult.delta.y = arg.coords.y - arg.pageCoords.y;
              newResult.rectDelta.left = arg.rect.left - unmodifiedRect.left;
              newResult.rectDelta.right = arg.rect.right - unmodifiedRect.right;
              newResult.rectDelta.top = arg.rect.top - unmodifiedRect.top;
              newResult.rectDelta.bottom = arg.rect.bottom - unmodifiedRect.bottom;
              const prevCoords = this.result.coords;
              const prevRect = this.result.rect;
              if (prevCoords && prevRect) {
                const rectChanged = newResult.rect.left !== prevRect.left || newResult.rect.right !== prevRect.right || newResult.rect.top !== prevRect.top || newResult.rect.bottom !== prevRect.bottom;
                newResult.changed = rectChanged || prevCoords.x !== newResult.coords.x || prevCoords.y !== newResult.coords.y;
              }
              return newResult;
            }
            applyToInteraction(arg) {
              const {
                interaction
              } = this;
              const {
                phase
              } = arg;
              const curCoords = interaction.coords.cur;
              const startCoords = interaction.coords.start;
              const {
                result,
                startDelta
              } = this;
              const curDelta = result.delta;
              if (phase === "start") {
                extend2(this.startDelta, result.delta);
              }
              for (const [coordsSet, delta] of [[startCoords, startDelta], [curCoords, curDelta]]) {
                coordsSet.page.x += delta.x;
                coordsSet.page.y += delta.y;
                coordsSet.client.x += delta.x;
                coordsSet.client.y += delta.y;
              }
              const {
                rectDelta
              } = this.result;
              const rect = arg.rect || interaction.rect;
              rect.left += rectDelta.left;
              rect.right += rectDelta.right;
              rect.top += rectDelta.top;
              rect.bottom += rectDelta.bottom;
              rect.width = rect.right - rect.left;
              rect.height = rect.bottom - rect.top;
            }
            setAndApply(arg) {
              const {
                interaction
              } = this;
              const {
                phase,
                preEnd,
                skipModifiers
              } = arg;
              const result = this.setAll({
                preEnd,
                phase,
                pageCoords: arg.modifiedCoords || interaction.coords.cur.page
              });
              this.result = result;
              if (!result.changed && (!skipModifiers || skipModifiers < this.states.length) && interaction.interacting()) {
                return false;
              }
              if (arg.modifiedCoords) {
                const {
                  page
                } = interaction.coords.cur;
                const adjustment = {
                  x: arg.modifiedCoords.x - page.x,
                  y: arg.modifiedCoords.y - page.y
                };
                result.coords.x += adjustment.x;
                result.coords.y += adjustment.y;
                result.delta.x += adjustment.x;
                result.delta.y += adjustment.y;
              }
              this.applyToInteraction(arg);
            }
            beforeEnd(arg) {
              const {
                interaction,
                event
              } = arg;
              const states = this.states;
              if (!states || !states.length) {
                return;
              }
              let doPreend = false;
              for (const state of states) {
                arg.state = state;
                const {
                  options,
                  methods
                } = state;
                const endPosition = methods.beforeEnd && methods.beforeEnd(arg);
                if (endPosition) {
                  this.endResult = endPosition;
                  return false;
                }
                doPreend = doPreend || !doPreend && this.shouldDo(options, true, arg.phase, true);
              }
              if (doPreend) {
                interaction.move({
                  event,
                  preEnd: true
                });
              }
            }
            stop(arg) {
              const {
                interaction
              } = arg;
              if (!this.states || !this.states.length) {
                return;
              }
              const modifierArg = extend2({
                states: this.states,
                interactable: interaction.interactable,
                element: interaction.element,
                rect: null
              }, arg);
              this.fillArg(modifierArg);
              for (const state of this.states) {
                modifierArg.state = state;
                if (state.methods.stop) {
                  state.methods.stop(modifierArg);
                }
              }
              this.states = null;
              this.endResult = null;
            }
            prepareStates(modifierList) {
              this.states = [];
              for (let index2 = 0; index2 < modifierList.length; index2++) {
                const {
                  options,
                  methods,
                  name
                } = modifierList[index2];
                this.states.push({
                  options,
                  methods,
                  index: index2,
                  name
                });
              }
              return this.states;
            }
            restoreInteractionCoords({
              interaction: {
                coords,
                rect,
                modification
              }
            }) {
              if (!modification.result) {
                return;
              }
              const {
                startDelta
              } = modification;
              const {
                delta: curDelta,
                rectDelta
              } = modification.result;
              const coordsAndDeltas = [[coords.start, startDelta], [coords.cur, curDelta]];
              for (const [coordsSet, delta] of coordsAndDeltas) {
                coordsSet.page.x -= delta.x;
                coordsSet.page.y -= delta.y;
                coordsSet.client.x -= delta.x;
                coordsSet.client.y -= delta.y;
              }
              rect.left -= rectDelta.left;
              rect.right -= rectDelta.right;
              rect.top -= rectDelta.top;
              rect.bottom -= rectDelta.bottom;
            }
            shouldDo(options, preEnd, phase, requireEndOnly) {
              if (
                // ignore disabled modifiers
                !options || options.enabled === false || // check if we require endOnly option to fire move before end
                requireEndOnly && !options.endOnly || // don't apply endOnly modifiers when not ending
                options.endOnly && !preEnd || // check if modifier should run be applied on start
                phase === "start" && !options.setStart
              ) {
                return false;
              }
              return true;
            }
            copyFrom(other) {
              this.startOffset = other.startOffset;
              this.startDelta = other.startDelta;
              this.edges = other.edges;
              this.states = other.states.map((s) => clone2(s));
              this.result = createResult(extend2({}, other.result.coords), extend2({}, other.result.rect));
            }
            destroy() {
              for (const prop in this) {
                this[prop] = null;
              }
            }
          }
          function createResult(coords, rect) {
            return {
              rect,
              coords,
              delta: {
                x: 0,
                y: 0
              },
              rectDelta: {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
              },
              eventProps: [],
              changed: true
            };
          }
          function getModifierList(interaction) {
            const actionOptions = interaction.interactable.options[interaction.prepared.name];
            const actionModifiers = actionOptions.modifiers;
            if (actionModifiers && actionModifiers.length) {
              return actionModifiers;
            }
            return ["snap", "snapSize", "snapEdges", "restrict", "restrictEdges", "restrictSize"].map((type) => {
              const options = actionOptions[type];
              return options && options.enabled && {
                options,
                methods: options._methods
              };
            }).filter((m) => !!m);
          }
          function getRectOffset(rect, coords) {
            return rect ? {
              left: coords.x - rect.left,
              top: coords.y - rect.top,
              right: rect.right - coords.x,
              bottom: rect.bottom - coords.y
            } : {
              left: 0,
              top: 0,
              right: 0,
              bottom: 0
            };
          }
          function makeModifier(module3, name) {
            const {
              defaults: defaults2
            } = module3;
            const methods = {
              start: module3.start,
              set: module3.set,
              beforeEnd: module3.beforeEnd,
              stop: module3.stop
            };
            const modifier = (_options) => {
              const options = _options || {};
              options.enabled = options.enabled !== false;
              for (const prop in defaults2) {
                if (!(prop in options)) {
                  options[prop] = defaults2[prop];
                }
              }
              const m = {
                options,
                methods,
                name,
                enable: () => {
                  options.enabled = true;
                  return m;
                },
                disable: () => {
                  options.enabled = false;
                  return m;
                }
              };
              return m;
            };
            if (name && typeof name === "string") {
              modifier._defaults = defaults2;
              modifier._methods = methods;
            }
            return modifier;
          }
          function addEventModifiers({
            iEvent,
            interaction: {
              modification: {
                result
              }
            }
          }) {
            if (result) {
              iEvent.modifiers = result.eventProps;
            }
          }
          const modifiersBase = {
            id: "modifiers/base",
            before: ["actions"],
            install: (scope) => {
              scope.defaults.perAction.modifiers = [];
            },
            listeners: {
              "interactions:new": ({
                interaction
              }) => {
                interaction.modification = new Modification_Modification(interaction);
              },
              "interactions:before-action-start": (arg) => {
                const {
                  modification
                } = arg.interaction;
                modification.start(arg, arg.interaction.coords.start.page);
                arg.interaction.edges = modification.edges;
                modification.applyToInteraction(arg);
              },
              "interactions:before-action-move": (arg) => arg.interaction.modification.setAndApply(arg),
              "interactions:before-action-end": (arg) => arg.interaction.modification.beforeEnd(arg),
              "interactions:action-start": addEventModifiers,
              "interactions:action-move": addEventModifiers,
              "interactions:action-end": addEventModifiers,
              "interactions:after-action-start": (arg) => arg.interaction.modification.restoreInteractionCoords(arg),
              "interactions:after-action-move": (arg) => arg.interaction.modification.restoreInteractionCoords(arg),
              "interactions:stop": (arg) => arg.interaction.modification.stop(arg)
            }
          };
          var modifiers_base = modifiersBase;
          const aspectRatio = {
            start(arg) {
              const {
                state,
                rect,
                edges: originalEdges,
                pageCoords: coords
              } = arg;
              let {
                ratio
              } = state.options;
              const {
                equalDelta,
                modifiers
              } = state.options;
              if (ratio === "preserve") {
                ratio = rect.width / rect.height;
              }
              state.startCoords = extend2({}, coords);
              state.startRect = extend2({}, rect);
              state.ratio = ratio;
              state.equalDelta = equalDelta;
              const linkedEdges = state.linkedEdges = {
                top: originalEdges.top || originalEdges.left && !originalEdges.bottom,
                left: originalEdges.left || originalEdges.top && !originalEdges.right,
                bottom: originalEdges.bottom || originalEdges.right && !originalEdges.top,
                right: originalEdges.right || originalEdges.bottom && !originalEdges.left
              };
              state.xIsPrimaryAxis = !!(originalEdges.left || originalEdges.right);
              if (state.equalDelta) {
                state.edgeSign = (linkedEdges.left ? 1 : -1) * (linkedEdges.top ? 1 : -1);
              } else {
                const negativeSecondaryEdge = state.xIsPrimaryAxis ? linkedEdges.top : linkedEdges.left;
                state.edgeSign = negativeSecondaryEdge ? -1 : 1;
              }
              extend2(arg.edges, linkedEdges);
              if (!modifiers || !modifiers.length) {
                return;
              }
              const subModification = new Modification_Modification(arg.interaction);
              subModification.copyFrom(arg.interaction.modification);
              subModification.prepareStates(modifiers);
              state.subModification = subModification;
              subModification.startAll({
                ...arg
              });
            },
            set(arg) {
              const {
                state,
                rect,
                coords
              } = arg;
              const initialCoords = extend2({}, coords);
              const aspectMethod = state.equalDelta ? setEqualDelta : setRatio;
              aspectMethod(state, state.xIsPrimaryAxis, coords, rect);
              if (!state.subModification) {
                return null;
              }
              const correctedRect = extend2({}, rect);
              addEdges(state.linkedEdges, correctedRect, {
                x: coords.x - initialCoords.x,
                y: coords.y - initialCoords.y
              });
              const result = state.subModification.setAll({
                ...arg,
                rect: correctedRect,
                edges: state.linkedEdges,
                pageCoords: coords,
                prevCoords: coords,
                prevRect: correctedRect
              });
              const {
                delta
              } = result;
              if (result.changed) {
                const xIsCriticalAxis = Math.abs(delta.x) > Math.abs(delta.y);
                aspectMethod(state, xIsCriticalAxis, result.coords, result.rect);
                extend2(coords, result.coords);
              }
              return result.eventProps;
            },
            defaults: {
              ratio: "preserve",
              equalDelta: false,
              modifiers: [],
              enabled: false
            }
          };
          function setEqualDelta({
            startCoords,
            edgeSign
          }, xIsPrimaryAxis, coords) {
            if (xIsPrimaryAxis) {
              coords.y = startCoords.y + (coords.x - startCoords.x) * edgeSign;
            } else {
              coords.x = startCoords.x + (coords.y - startCoords.y) * edgeSign;
            }
          }
          function setRatio({
            startRect,
            startCoords,
            ratio,
            edgeSign
          }, xIsPrimaryAxis, coords, rect) {
            if (xIsPrimaryAxis) {
              const newHeight = rect.width / ratio;
              coords.y = startCoords.y + (newHeight - startRect.height) * edgeSign;
            } else {
              const newWidth = rect.height * ratio;
              coords.x = startCoords.x + (newWidth - startRect.width) * edgeSign;
            }
          }
          var modifiers_aspectRatio = makeModifier(aspectRatio, "aspectRatio");
          const noop2 = () => {
          };
          noop2._defaults = {};
          var modifiers_noop = noop2;
          function pointer_start({
            rect,
            startOffset,
            state,
            interaction,
            pageCoords
          }) {
            const {
              options
            } = state;
            const {
              elementRect
            } = options;
            const offset2 = extend2({
              left: 0,
              top: 0,
              right: 0,
              bottom: 0
            }, options.offset || {});
            if (rect && elementRect) {
              const restriction = getRestrictionRect(options.restriction, interaction, pageCoords);
              if (restriction) {
                const widthDiff = restriction.right - restriction.left - rect.width;
                const heightDiff = restriction.bottom - restriction.top - rect.height;
                if (widthDiff < 0) {
                  offset2.left += widthDiff;
                  offset2.right += widthDiff;
                }
                if (heightDiff < 0) {
                  offset2.top += heightDiff;
                  offset2.bottom += heightDiff;
                }
              }
              offset2.left += startOffset.left - rect.width * elementRect.left;
              offset2.top += startOffset.top - rect.height * elementRect.top;
              offset2.right += startOffset.right - rect.width * (1 - elementRect.right);
              offset2.bottom += startOffset.bottom - rect.height * (1 - elementRect.bottom);
            }
            state.offset = offset2;
          }
          function set2({
            coords,
            interaction,
            state
          }) {
            const {
              options,
              offset: offset2
            } = state;
            const restriction = getRestrictionRect(options.restriction, interaction, coords);
            if (!restriction) {
              return;
            }
            const rect = xywhToTlbr(restriction);
            coords.x = Math.max(Math.min(rect.right - offset2.right, coords.x), rect.left + offset2.left);
            coords.y = Math.max(Math.min(rect.bottom - offset2.bottom, coords.y), rect.top + offset2.top);
          }
          function getRestrictionRect(value, interaction, coords) {
            if (is.func(value)) {
              return resolveRectLike(value, interaction.interactable, interaction.element, [coords.x, coords.y, interaction]);
            } else {
              return resolveRectLike(value, interaction.interactable, interaction.element);
            }
          }
          const pointer_defaults = {
            restriction: null,
            elementRect: null,
            offset: null,
            endOnly: false,
            enabled: false
          };
          const restrict = {
            start: pointer_start,
            set: set2,
            defaults: pointer_defaults
          };
          var restrict_pointer = makeModifier(restrict, "restrict");
          const noInner = {
            top: Infinity,
            left: Infinity,
            bottom: -Infinity,
            right: -Infinity
          };
          const noOuter = {
            top: -Infinity,
            left: -Infinity,
            bottom: Infinity,
            right: Infinity
          };
          function edges_start({
            interaction,
            startOffset,
            state
          }) {
            const {
              options
            } = state;
            let offset2;
            if (options) {
              const offsetRect = getRestrictionRect(options.offset, interaction, interaction.coords.start.page);
              offset2 = rectToXY(offsetRect);
            }
            offset2 = offset2 || {
              x: 0,
              y: 0
            };
            state.offset = {
              top: offset2.y + startOffset.top,
              left: offset2.x + startOffset.left,
              bottom: offset2.y - startOffset.bottom,
              right: offset2.x - startOffset.right
            };
          }
          function edges_set({
            coords,
            edges,
            interaction,
            state
          }) {
            const {
              offset: offset2,
              options
            } = state;
            if (!edges) {
              return;
            }
            const page = extend2({}, coords);
            const inner = getRestrictionRect(options.inner, interaction, page) || {};
            const outer = getRestrictionRect(options.outer, interaction, page) || {};
            fixRect(inner, noInner);
            fixRect(outer, noOuter);
            if (edges.top) {
              coords.y = Math.min(Math.max(outer.top + offset2.top, page.y), inner.top + offset2.top);
            } else if (edges.bottom) {
              coords.y = Math.max(Math.min(outer.bottom + offset2.bottom, page.y), inner.bottom + offset2.bottom);
            }
            if (edges.left) {
              coords.x = Math.min(Math.max(outer.left + offset2.left, page.x), inner.left + offset2.left);
            } else if (edges.right) {
              coords.x = Math.max(Math.min(outer.right + offset2.right, page.x), inner.right + offset2.right);
            }
          }
          function fixRect(rect, defaults2) {
            for (const edge of ["top", "left", "bottom", "right"]) {
              if (!(edge in rect)) {
                rect[edge] = defaults2[edge];
              }
            }
            return rect;
          }
          const edges_defaults = {
            inner: null,
            outer: null,
            offset: null,
            endOnly: false,
            enabled: false
          };
          const restrictEdges = {
            noInner,
            noOuter,
            start: edges_start,
            set: edges_set,
            defaults: edges_defaults
          };
          var restrict_edges = makeModifier(restrictEdges, "restrictEdges");
          const rect_defaults = extend2({
            get elementRect() {
              return {
                top: 0,
                left: 0,
                bottom: 1,
                right: 1
              };
            },
            set elementRect(_2) {
            }
          }, restrict.defaults);
          const restrictRect = {
            start: restrict.start,
            set: restrict.set,
            defaults: rect_defaults
          };
          var restrict_rect = makeModifier(restrictRect, "restrictRect");
          const noMin = {
            width: -Infinity,
            height: -Infinity
          };
          const noMax = {
            width: Infinity,
            height: Infinity
          };
          function size_start(arg) {
            return restrictEdges.start(arg);
          }
          function size_set(arg) {
            const {
              interaction,
              state,
              rect,
              edges
            } = arg;
            const {
              options
            } = state;
            if (!edges) {
              return;
            }
            const minSize = tlbrToXywh(getRestrictionRect(options.min, interaction, arg.coords)) || noMin;
            const maxSize = tlbrToXywh(getRestrictionRect(options.max, interaction, arg.coords)) || noMax;
            state.options = {
              endOnly: options.endOnly,
              inner: extend2({}, restrictEdges.noInner),
              outer: extend2({}, restrictEdges.noOuter)
            };
            if (edges.top) {
              state.options.inner.top = rect.bottom - minSize.height;
              state.options.outer.top = rect.bottom - maxSize.height;
            } else if (edges.bottom) {
              state.options.inner.bottom = rect.top + minSize.height;
              state.options.outer.bottom = rect.top + maxSize.height;
            }
            if (edges.left) {
              state.options.inner.left = rect.right - minSize.width;
              state.options.outer.left = rect.right - maxSize.width;
            } else if (edges.right) {
              state.options.inner.right = rect.left + minSize.width;
              state.options.outer.right = rect.left + maxSize.width;
            }
            restrictEdges.set(arg);
            state.options = options;
          }
          const size_defaults = {
            min: null,
            max: null,
            endOnly: false,
            enabled: false
          };
          const restrictSize = {
            start: size_start,
            set: size_set,
            defaults: size_defaults
          };
          var size2 = makeModifier(restrictSize, "restrictSize");
          function snap_pointer_start(arg) {
            const {
              interaction,
              interactable,
              element,
              rect,
              state,
              startOffset
            } = arg;
            const {
              options
            } = state;
            const origin2 = options.offsetWithOrigin ? getOrigin(arg) : {
              x: 0,
              y: 0
            };
            let snapOffset;
            if (options.offset === "startCoords") {
              snapOffset = {
                x: interaction.coords.start.page.x,
                y: interaction.coords.start.page.y
              };
            } else {
              const offsetRect = resolveRectLike(options.offset, interactable, element, [interaction]);
              snapOffset = rectToXY(offsetRect) || {
                x: 0,
                y: 0
              };
              snapOffset.x += origin2.x;
              snapOffset.y += origin2.y;
            }
            const {
              relativePoints
            } = options;
            state.offsets = rect && relativePoints && relativePoints.length ? relativePoints.map((relativePoint, index2) => ({
              index: index2,
              relativePoint,
              x: startOffset.left - rect.width * relativePoint.x + snapOffset.x,
              y: startOffset.top - rect.height * relativePoint.y + snapOffset.y
            })) : [extend2({
              index: 0,
              relativePoint: null
            }, snapOffset)];
          }
          function pointer_set(arg) {
            const {
              interaction,
              coords,
              state
            } = arg;
            const {
              options,
              offsets
            } = state;
            const origin2 = getOriginXY(interaction.interactable, interaction.element, interaction.prepared.name);
            const page = extend2({}, coords);
            const targets = [];
            if (!options.offsetWithOrigin) {
              page.x -= origin2.x;
              page.y -= origin2.y;
            }
            for (const offset2 of offsets) {
              const relativeX = page.x - offset2.x;
              const relativeY = page.y - offset2.y;
              for (let index2 = 0, len = options.targets.length; index2 < len; index2++) {
                const snapTarget = options.targets[index2];
                let target2;
                if (is.func(snapTarget)) {
                  target2 = snapTarget(relativeX, relativeY, interaction._proxy, offset2, index2);
                } else {
                  target2 = snapTarget;
                }
                if (!target2) {
                  continue;
                }
                targets.push({
                  x: (is.number(target2.x) ? target2.x : relativeX) + offset2.x,
                  y: (is.number(target2.y) ? target2.y : relativeY) + offset2.y,
                  range: is.number(target2.range) ? target2.range : options.range,
                  source: snapTarget,
                  index: index2,
                  offset: offset2
                });
              }
            }
            const closest = {
              target: null,
              inRange: false,
              distance: 0,
              range: 0,
              delta: {
                x: 0,
                y: 0
              }
            };
            for (const target2 of targets) {
              const range = target2.range;
              const dx = target2.x - page.x;
              const dy = target2.y - page.y;
              const distance = hypot(dx, dy);
              let inRange = distance <= range;
              if (range === Infinity && closest.inRange && closest.range !== Infinity) {
                inRange = false;
              }
              if (!closest.target || (inRange ? closest.inRange && range !== Infinity ? distance / range < closest.distance / closest.range : range === Infinity && closest.range !== Infinity || // OR this target is closer that the previous closest
              distance < closest.distance : (
                // The other is not in range and the pointer is closer to this target
                !closest.inRange && distance < closest.distance
              ))) {
                closest.target = target2;
                closest.distance = distance;
                closest.range = range;
                closest.inRange = inRange;
                closest.delta.x = dx;
                closest.delta.y = dy;
              }
            }
            if (closest.inRange) {
              coords.x = closest.target.x;
              coords.y = closest.target.y;
            }
            state.closest = closest;
            return closest;
          }
          function getOrigin(arg) {
            const {
              element
            } = arg.interaction;
            const optionsOrigin = rectToXY(resolveRectLike(arg.state.options.origin, null, null, [element]));
            const origin2 = optionsOrigin || getOriginXY(arg.interactable, element, arg.interaction.prepared.name);
            return origin2;
          }
          const snap_pointer_defaults = {
            range: Infinity,
            targets: null,
            offset: null,
            offsetWithOrigin: true,
            origin: null,
            relativePoints: null,
            endOnly: false,
            enabled: false
          };
          const snap = {
            start: snap_pointer_start,
            set: pointer_set,
            defaults: snap_pointer_defaults
          };
          var snap_pointer = makeModifier(snap, "snap");
          function snap_size_start(arg) {
            const {
              state,
              edges
            } = arg;
            const {
              options
            } = state;
            if (!edges) {
              return null;
            }
            arg.state = {
              options: {
                targets: null,
                relativePoints: [{
                  x: edges.left ? 0 : 1,
                  y: edges.top ? 0 : 1
                }],
                offset: options.offset || "self",
                origin: {
                  x: 0,
                  y: 0
                },
                range: options.range
              }
            };
            state.targetFields = state.targetFields || [["width", "height"], ["x", "y"]];
            snap.start(arg);
            state.offsets = arg.state.offsets;
            arg.state = state;
          }
          function snap_size_set(arg) {
            const {
              interaction,
              state,
              coords
            } = arg;
            const {
              options,
              offsets
            } = state;
            const relative = {
              x: coords.x - offsets[0].x,
              y: coords.y - offsets[0].y
            };
            state.options = extend2({}, options);
            state.options.targets = [];
            for (const snapTarget of options.targets || []) {
              let target2;
              if (is.func(snapTarget)) {
                target2 = snapTarget(relative.x, relative.y, interaction);
              } else {
                target2 = snapTarget;
              }
              if (!target2) {
                continue;
              }
              for (const [xField, yField] of state.targetFields) {
                if (xField in target2 || yField in target2) {
                  target2.x = target2[xField];
                  target2.y = target2[yField];
                  break;
                }
              }
              state.options.targets.push(target2);
            }
            const returnValue = snap.set(arg);
            state.options = options;
            return returnValue;
          }
          const snap_size_defaults = {
            range: Infinity,
            targets: null,
            offset: null,
            endOnly: false,
            enabled: false
          };
          const snapSize = {
            start: snap_size_start,
            set: snap_size_set,
            defaults: snap_size_defaults
          };
          var snap_size = makeModifier(snapSize, "snapSize");
          function snap_edges_start(arg) {
            const {
              edges
            } = arg;
            if (!edges) {
              return null;
            }
            arg.state.targetFields = arg.state.targetFields || [[edges.left ? "left" : "right", edges.top ? "top" : "bottom"]];
            return snapSize.start(arg);
          }
          const snapEdges = {
            start: snap_edges_start,
            set: snapSize.set,
            defaults: extend2(clone2(snapSize.defaults), {
              targets: null,
              range: null,
              offset: {
                x: 0,
                y: 0
              }
            })
          };
          var snap_edges = makeModifier(snapEdges, "snapEdges");
          var modifiers_all = {
            aspectRatio: modifiers_aspectRatio,
            restrictEdges: restrict_edges,
            restrict: restrict_pointer,
            restrictRect: restrict_rect,
            restrictSize: size2,
            snapEdges: snap_edges,
            snap: snap_pointer,
            snapSize: snap_size,
            spring: modifiers_noop,
            avoid: modifiers_noop,
            transform: modifiers_noop,
            rubberband: modifiers_noop
          };
          const plugin_modifiers = {
            id: "modifiers",
            install(scope) {
              const {
                interactStatic: interact
              } = scope;
              scope.usePlugin(modifiers_base);
              scope.usePlugin(snappers_plugin);
              interact.modifiers = modifiers_all;
              for (const type in modifiers_all) {
                const {
                  _defaults,
                  _methods
                } = modifiers_all[type];
                _defaults._methods = _methods;
                scope.defaults.perAction[type] = _defaults;
              }
            }
          };
          var modifiers_plugin = plugin_modifiers;
          if (typeof window === "object" && !!window) {
            interact_init(window);
          }
          _interactjs_interact.use(modifiers_plugin);
          var CheckName;
          (function(CheckName2) {
            CheckName2["touchAction"] = "touchAction";
            CheckName2["boxSizing"] = "boxSizing";
            CheckName2["noListeners"] = "noListeners";
          })(CheckName || (CheckName = {}));
          const prefix = "[interact.js] ";
          const links = {
            touchAction: "https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action",
            boxSizing: "https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing"
          };
          function dev_tools_plugin_install(scope, {
            logger
          } = {}) {
            const {
              Interactable,
              defaults: defaults2
            } = scope;
            scope.logger = logger || console;
            defaults2.base.devTools = {
              ignore: {}
            };
            Interactable.prototype.devTools = function(options) {
              if (options) {
                extend2(this.options.devTools, options);
                return this;
              }
              return this.options.devTools;
            };
          }
          const checks = [{
            name: CheckName.touchAction,
            perform({
              element
            }) {
              return !parentHasStyle(element, "touchAction", /pan-|pinch|none/);
            },
            getInfo({
              element
            }) {
              return [element, links.touchAction];
            },
            text: 'Consider adding CSS "touch-action: none" to this element\n'
          }, {
            name: CheckName.boxSizing,
            perform(interaction) {
              const {
                element
              } = interaction;
              return interaction.prepared.name === "resize" && element instanceof utils_domObjects.HTMLElement && !hasStyle(element, "boxSizing", /border-box/);
            },
            text: 'Consider adding CSS "box-sizing: border-box" to this resizable element',
            getInfo({
              element
            }) {
              return [element, links.boxSizing];
            }
          }, {
            name: CheckName.noListeners,
            perform(interaction) {
              const actionName = interaction.prepared.name;
              const moveListeners = interaction.interactable.events.types[`${actionName}move`] || [];
              return !moveListeners.length;
            },
            getInfo(interaction) {
              return [interaction.prepared.name, interaction.interactable];
            },
            text: "There are no listeners set for this action"
          }];
          function hasStyle(element, prop, styleRe) {
            const value = element.style[prop] || win.getComputedStyle(element)[prop];
            return styleRe.test((value || "").toString());
          }
          function parentHasStyle(element, prop, styleRe) {
            let parent = element;
            while (is.element(parent)) {
              if (hasStyle(parent, prop, styleRe)) {
                return true;
              }
              parent = parentNode2(parent);
            }
            return false;
          }
          const plugin_id = "dev-tools";
          const defaultExport = {
            id: plugin_id,
            install: dev_tools_plugin_install,
            listeners: {
              "interactions:action-start": ({
                interaction
              }, scope) => {
                for (const check of checks) {
                  const options = interaction.interactable && interaction.interactable.options;
                  if (!(options && options.devTools && options.devTools.ignore[check.name]) && check.perform(interaction)) {
                    scope.logger.warn(prefix + check.text, ...check.getInfo(interaction));
                  }
                }
              }
            },
            checks,
            CheckName,
            links,
            prefix
          };
          var dev_tools_plugin = defaultExport;
          if (typeof window === "object" && !!window) {
            interact_init(window);
          }
          _interactjs_interact.use(dev_tools_plugin);
          function ownKeys2(object2, enumerableOnly) {
            var keys = Object.keys(object2);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object2);
              if (enumerableOnly) symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
              });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target2) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              if (i % 2) {
                ownKeys2(Object(source), true).forEach(function(key) {
                  Object(defineProperty[
                    "a"
                    /* default */
                  ])(target2, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys2(Object(source)).forEach(function(key) {
                  Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }
            return target2;
          }
          var GridItemvue_type_script_lang_js_ = {
            name: "GridItem",
            props: {
              /*cols: {
               type: Number,
               required: true
               },*/
              /*containerWidth: {
               type: Number,
               required: true
                 },
               rowHeight: {
               type: Number,
               required: true
               },
               margin: {
               type: Array,
               required: true
               },
               maxRows: {
               type: Number,
               required: true
               },*/
              isDraggable: {
                type: Boolean,
                required: false,
                default: null
              },
              isResizable: {
                type: Boolean,
                required: false,
                default: null
              },
              isBounded: {
                type: Boolean,
                required: false,
                default: null
              },
              /*useCssTransforms: {
               type: Boolean,
               required: true
               },
               */
              static: {
                type: Boolean,
                required: false,
                default: false
              },
              minH: {
                type: Number,
                required: false,
                default: 1
              },
              minW: {
                type: Number,
                required: false,
                default: 1
              },
              maxH: {
                type: Number,
                required: false,
                default: Infinity
              },
              maxW: {
                type: Number,
                required: false,
                default: Infinity
              },
              x: {
                type: Number,
                required: true
              },
              y: {
                type: Number,
                required: true
              },
              w: {
                type: Number,
                required: true
              },
              h: {
                type: Number,
                required: true
              },
              i: {
                required: true
              },
              dragIgnoreFrom: {
                type: String,
                required: false,
                default: "a, button"
              },
              dragAllowFrom: {
                type: String,
                required: false,
                default: null
              },
              resizeIgnoreFrom: {
                type: String,
                required: false,
                default: "a, button"
              },
              preserveAspectRatio: {
                type: Boolean,
                required: false,
                default: false
              },
              dragOption: {
                type: Object,
                required: false,
                default: function _default() {
                  return {};
                }
              },
              resizeOption: {
                type: Object,
                required: false,
                default: function _default() {
                  return {};
                }
              }
            },
            inject: ["eventBus", "layout"],
            data: function data() {
              return {
                cols: 1,
                containerWidth: 100,
                rowHeight: 30,
                margin: [10, 10],
                maxRows: Infinity,
                draggable: null,
                resizable: null,
                transformScale: 1,
                useCssTransforms: true,
                useStyleCursor: true,
                isDragging: false,
                dragging: null,
                isResizing: false,
                resizing: null,
                lastX: NaN,
                lastY: NaN,
                lastW: NaN,
                lastH: NaN,
                style: {},
                rtl: false,
                dragEventSet: false,
                resizeEventSet: false,
                previousW: null,
                previousH: null,
                previousX: null,
                previousY: null,
                innerX: this.x,
                innerY: this.y,
                innerW: this.w,
                innerH: this.h
              };
            },
            created: function created() {
              var _this = this;
              var self2 = this;
              self2.updateWidthHandler = function(width) {
                self2.updateWidth(width);
              };
              self2.compactHandler = function(layout) {
                self2.compact(layout);
              };
              self2.setDraggableHandler = function(isDraggable) {
                if (self2.isDraggable === null) {
                  self2.draggable = isDraggable;
                }
              };
              self2.setResizableHandler = function(isResizable) {
                if (self2.isResizable === null) {
                  self2.resizable = isResizable;
                }
              };
              self2.setBoundedHandler = function(isBounded) {
                if (self2.isBounded === null) {
                  self2.bounded = isBounded;
                }
              };
              self2.setTransformScaleHandler = function(transformScale) {
                self2.transformScale = transformScale;
              };
              self2.setRowHeightHandler = function(rowHeight) {
                self2.rowHeight = rowHeight;
              };
              self2.setMaxRowsHandler = function(maxRows) {
                self2.maxRows = maxRows;
              };
              self2.directionchangeHandler = function() {
                _this.rtl = Object(DOM[
                  "b"
                  /* getDocumentDir */
                ])() === "rtl";
                _this.compact();
              };
              self2.setColNum = function(colNum) {
                self2.cols = parseInt(colNum);
              };
              this.eventBus.$on("updateWidth", self2.updateWidthHandler);
              this.eventBus.$on("compact", self2.compactHandler);
              this.eventBus.$on("setDraggable", self2.setDraggableHandler);
              this.eventBus.$on("setResizable", self2.setResizableHandler);
              this.eventBus.$on("setBounded", self2.setBoundedHandler);
              this.eventBus.$on("setTransformScale", self2.setTransformScaleHandler);
              this.eventBus.$on("setRowHeight", self2.setRowHeightHandler);
              this.eventBus.$on("setMaxRows", self2.setMaxRowsHandler);
              this.eventBus.$on("directionchange", self2.directionchangeHandler);
              this.eventBus.$on("setColNum", self2.setColNum);
              this.rtl = Object(DOM[
                "b"
                /* getDocumentDir */
              ])() === "rtl";
            },
            beforeDestroy: function beforeDestroy2() {
              var self2 = this;
              this.eventBus.$off("updateWidth", self2.updateWidthHandler);
              this.eventBus.$off("compact", self2.compactHandler);
              this.eventBus.$off("setDraggable", self2.setDraggableHandler);
              this.eventBus.$off("setResizable", self2.setResizableHandler);
              this.eventBus.$off("setBounded", self2.setBoundedHandler);
              this.eventBus.$off("setTransformScale", self2.setTransformScaleHandler);
              this.eventBus.$off("setRowHeight", self2.setRowHeightHandler);
              this.eventBus.$off("setMaxRows", self2.setMaxRowsHandler);
              this.eventBus.$off("directionchange", self2.directionchangeHandler);
              this.eventBus.$off("setColNum", self2.setColNum);
              if (this.interactObj) {
                this.interactObj.unset();
              }
            },
            mounted: function mounted2() {
              if (this.layout.responsive && this.layout.lastBreakpoint) {
                this.cols = Object(responsiveUtils[
                  "c"
                  /* getColsFromBreakpoint */
                ])(this.layout.lastBreakpoint, this.layout.cols);
              } else {
                this.cols = this.layout.colNum;
              }
              this.rowHeight = this.layout.rowHeight;
              this.containerWidth = this.layout.width !== null ? this.layout.width : 100;
              this.margin = this.layout.margin !== void 0 ? this.layout.margin : [10, 10];
              this.maxRows = this.layout.maxRows;
              if (this.isDraggable === null) {
                this.draggable = this.layout.isDraggable;
              } else {
                this.draggable = this.isDraggable;
              }
              if (this.isResizable === null) {
                this.resizable = this.layout.isResizable;
              } else {
                this.resizable = this.isResizable;
              }
              if (this.isBounded === null) {
                this.bounded = this.layout.isBounded;
              } else {
                this.bounded = this.isBounded;
              }
              this.transformScale = this.layout.transformScale;
              this.useCssTransforms = this.layout.useCssTransforms;
              this.useStyleCursor = this.layout.useStyleCursor;
              this.createStyle();
            },
            watch: {
              isDraggable: function isDraggable() {
                this.draggable = this.isDraggable;
              },
              static: function _static() {
                this.tryMakeDraggable();
                this.tryMakeResizable();
              },
              draggable: function draggable() {
                this.tryMakeDraggable();
              },
              isResizable: function isResizable() {
                this.resizable = this.isResizable;
              },
              isBounded: function isBounded() {
                this.bounded = this.isBounded;
              },
              resizable: function resizable2() {
                this.tryMakeResizable();
              },
              rowHeight: function rowHeight() {
                this.createStyle();
                this.emitContainerResized();
              },
              cols: function cols() {
                this.tryMakeResizable();
                this.createStyle();
                this.emitContainerResized();
              },
              containerWidth: function containerWidth() {
                this.tryMakeResizable();
                this.createStyle();
                this.emitContainerResized();
              },
              x: function x(newVal) {
                this.innerX = newVal;
                this.createStyle();
              },
              y: function y(newVal) {
                this.innerY = newVal;
                this.createStyle();
              },
              h: function h(newVal) {
                this.innerH = newVal;
                this.createStyle();
              },
              w: function w(newVal) {
                this.innerW = newVal;
                this.createStyle();
              },
              renderRtl: function renderRtl() {
                this.tryMakeResizable();
                this.createStyle();
              },
              minH: function minH() {
                this.tryMakeResizable();
              },
              maxH: function maxH() {
                this.tryMakeResizable();
              },
              minW: function minW() {
                this.tryMakeResizable();
              },
              maxW: function maxW() {
                this.tryMakeResizable();
              },
              "$parent.margin": function $parentMargin(margin) {
                if (!margin || margin[0] == this.margin[0] && margin[1] == this.margin[1]) {
                  return;
                }
                this.margin = margin.map(function(m) {
                  return Number(m);
                });
                this.createStyle();
                this.emitContainerResized();
              }
            },
            computed: {
              classObj: function classObj() {
                return {
                  "vue-resizable": this.resizableAndNotStatic,
                  "static": this.static,
                  "resizing": this.isResizing,
                  "vue-draggable-dragging": this.isDragging,
                  "cssTransforms": this.useCssTransforms,
                  "render-rtl": this.renderRtl,
                  "disable-userselect": this.isDragging,
                  "no-touch": this.isAndroid && this.draggableOrResizableAndNotStatic
                };
              },
              resizableAndNotStatic: function resizableAndNotStatic() {
                return this.resizable && !this.static;
              },
              draggableOrResizableAndNotStatic: function draggableOrResizableAndNotStatic() {
                return (this.draggable || this.resizable) && !this.static;
              },
              isAndroid: function isAndroid() {
                return navigator.userAgent.toLowerCase().indexOf("android") !== -1;
              },
              renderRtl: function renderRtl() {
                return this.layout.isMirrored ? !this.rtl : this.rtl;
              },
              resizableHandleClass: function resizableHandleClass() {
                if (this.renderRtl) {
                  return "vue-resizable-handle vue-rtl-resizable-handle";
                } else {
                  return "vue-resizable-handle";
                }
              }
            },
            methods: {
              createStyle: function createStyle() {
                if (this.x + this.w > this.cols) {
                  this.innerX = 0;
                  this.innerW = this.w > this.cols ? this.cols : this.w;
                } else {
                  this.innerX = this.x;
                  this.innerW = this.w;
                }
                var pos = this.calcPosition(this.innerX, this.innerY, this.innerW, this.innerH);
                if (this.isDragging) {
                  pos.top = this.dragging.top;
                  if (this.renderRtl) {
                    pos.right = this.dragging.left;
                  } else {
                    pos.left = this.dragging.left;
                  }
                }
                if (this.isResizing) {
                  pos.width = this.resizing.width;
                  pos.height = this.resizing.height;
                }
                var style2;
                if (this.useCssTransforms) {
                  if (this.renderRtl) {
                    style2 = Object(utils2[
                      "k"
                      /* setTransformRtl */
                    ])(pos.top, pos.right, pos.width, pos.height);
                  } else {
                    style2 = Object(utils2[
                      "j"
                      /* setTransform */
                    ])(pos.top, pos.left, pos.width, pos.height);
                  }
                } else {
                  if (this.renderRtl) {
                    style2 = Object(utils2[
                      "i"
                      /* setTopRight */
                    ])(pos.top, pos.right, pos.width, pos.height);
                  } else {
                    style2 = Object(utils2[
                      "h"
                      /* setTopLeft */
                    ])(pos.top, pos.left, pos.width, pos.height);
                  }
                }
                this.style = style2;
              },
              emitContainerResized: function emitContainerResized() {
                var styleProps = {};
                for (var _i = 0, _arr = ["width", "height"]; _i < _arr.length; _i++) {
                  var prop = _arr[_i];
                  var val = this.style[prop];
                  var matches2 = val.match(/^(\d+)px$/);
                  if (!matches2) return;
                  styleProps[prop] = matches2[1];
                }
                this.$emit("container-resized", this.i, this.h, this.w, styleProps.height, styleProps.width);
              },
              handleResize: function handleResize(event) {
                if (this.static) return;
                var position = getControlPosition(event);
                if (position == null) return;
                var x = position.x, y = position.y;
                var newSize = {
                  width: 0,
                  height: 0
                };
                var pos;
                switch (event.type) {
                  case "resizestart": {
                    this.tryMakeResizable();
                    this.previousW = this.innerW;
                    this.previousH = this.innerH;
                    pos = this.calcPosition(this.innerX, this.innerY, this.innerW, this.innerH);
                    newSize.width = pos.width;
                    newSize.height = pos.height;
                    this.resizing = newSize;
                    this.isResizing = true;
                    break;
                  }
                  case "resizemove": {
                    var coreEvent = createCoreData(this.lastW, this.lastH, x, y);
                    if (this.renderRtl) {
                      newSize.width = this.resizing.width - coreEvent.deltaX / this.transformScale;
                    } else {
                      newSize.width = this.resizing.width + coreEvent.deltaX / this.transformScale;
                    }
                    newSize.height = this.resizing.height + coreEvent.deltaY / this.transformScale;
                    this.resizing = newSize;
                    break;
                  }
                  case "resizeend": {
                    pos = this.calcPosition(this.innerX, this.innerY, this.innerW, this.innerH);
                    newSize.width = pos.width;
                    newSize.height = pos.height;
                    this.resizing = null;
                    this.isResizing = false;
                    break;
                  }
                }
                pos = this.calcWH(newSize.height, newSize.width);
                if (pos.w < this.minW) {
                  pos.w = this.minW;
                }
                if (pos.w > this.maxW) {
                  pos.w = this.maxW;
                }
                if (pos.h < this.minH) {
                  pos.h = this.minH;
                }
                if (pos.h > this.maxH) {
                  pos.h = this.maxH;
                }
                if (pos.h < 1) {
                  pos.h = 1;
                }
                if (pos.w < 1) {
                  pos.w = 1;
                }
                this.lastW = x;
                this.lastH = y;
                if (this.innerW !== pos.w || this.innerH !== pos.h) {
                  this.$emit("resize", this.i, pos.h, pos.w, newSize.height, newSize.width);
                }
                if (event.type === "resizeend" && (this.previousW !== this.innerW || this.previousH !== this.innerH)) {
                  this.$emit("resized", this.i, pos.h, pos.w, newSize.height, newSize.width);
                }
                this.eventBus.$emit("resizeEvent", event.type, this.i, this.innerX, this.innerY, pos.h, pos.w);
              },
              handleDrag: function handleDrag(event) {
                if (this.static) return;
                if (this.isResizing) return;
                var position = getControlPosition(event);
                if (position === null) return;
                var x = position.x, y = position.y;
                var newPosition = {
                  top: 0,
                  left: 0
                };
                switch (event.type) {
                  case "dragstart": {
                    this.previousX = this.innerX;
                    this.previousY = this.innerY;
                    var parentRect = event.target.offsetParent.getBoundingClientRect();
                    var clientRect = event.target.getBoundingClientRect();
                    var cLeft = clientRect.left / this.transformScale;
                    var pLeft = parentRect.left / this.transformScale;
                    var cRight = clientRect.right / this.transformScale;
                    var pRight = parentRect.right / this.transformScale;
                    var cTop = clientRect.top / this.transformScale;
                    var pTop = parentRect.top / this.transformScale;
                    if (this.renderRtl) {
                      newPosition.left = (cRight - pRight) * -1;
                    } else {
                      newPosition.left = cLeft - pLeft;
                    }
                    newPosition.top = cTop - pTop;
                    this.dragging = newPosition;
                    this.isDragging = true;
                    break;
                  }
                  case "dragend": {
                    if (!this.isDragging) return;
                    var _parentRect = event.target.offsetParent.getBoundingClientRect();
                    var _clientRect = event.target.getBoundingClientRect();
                    var _cLeft = _clientRect.left / this.transformScale;
                    var _pLeft = _parentRect.left / this.transformScale;
                    var _cRight = _clientRect.right / this.transformScale;
                    var _pRight = _parentRect.right / this.transformScale;
                    var _cTop = _clientRect.top / this.transformScale;
                    var _pTop = _parentRect.top / this.transformScale;
                    if (this.renderRtl) {
                      newPosition.left = (_cRight - _pRight) * -1;
                    } else {
                      newPosition.left = _cLeft - _pLeft;
                    }
                    newPosition.top = _cTop - _pTop;
                    this.dragging = null;
                    this.isDragging = false;
                    break;
                  }
                  case "dragmove": {
                    var coreEvent = createCoreData(this.lastX, this.lastY, x, y);
                    if (this.renderRtl) {
                      newPosition.left = this.dragging.left - coreEvent.deltaX / this.transformScale;
                    } else {
                      newPosition.left = this.dragging.left + coreEvent.deltaX / this.transformScale;
                    }
                    newPosition.top = this.dragging.top + coreEvent.deltaY / this.transformScale;
                    if (this.bounded) {
                      var bottomBoundary = event.target.offsetParent.clientHeight - this.calcGridItemWHPx(this.h, this.rowHeight, this.margin[1]);
                      newPosition.top = this.clamp(newPosition.top, 0, bottomBoundary);
                      var colWidth = this.calcColWidth();
                      var rightBoundary = this.containerWidth - this.calcGridItemWHPx(this.w, colWidth, this.margin[0]);
                      newPosition.left = this.clamp(newPosition.left, 0, rightBoundary);
                    }
                    this.dragging = newPosition;
                    break;
                  }
                }
                var pos;
                if (this.renderRtl) {
                  pos = this.calcXY(newPosition.top, newPosition.left);
                } else {
                  pos = this.calcXY(newPosition.top, newPosition.left);
                }
                this.lastX = x;
                this.lastY = y;
                if (this.innerX !== pos.x || this.innerY !== pos.y) {
                  this.$emit("move", this.i, pos.x, pos.y);
                }
                if (event.type === "dragend" && (this.previousX !== this.innerX || this.previousY !== this.innerY)) {
                  this.$emit("moved", this.i, pos.x, pos.y);
                }
                this.eventBus.$emit("dragEvent", event.type, this.i, pos.x, pos.y, this.innerH, this.innerW);
              },
              calcPosition: function calcPosition(x, y, w, h) {
                var colWidth = this.calcColWidth();
                var out;
                if (this.renderRtl) {
                  out = {
                    right: Math.round(colWidth * x + (x + 1) * this.margin[0]),
                    top: Math.round(this.rowHeight * y + (y + 1) * this.margin[1]),
                    // 0 * Infinity === NaN, which causes problems with resize constriants;
                    // Fix this if it occurs.
                    // Note we do it here rather than later because Math.round(Infinity) causes deopt
                    width: w === Infinity ? w : Math.round(colWidth * w + Math.max(0, w - 1) * this.margin[0]),
                    height: h === Infinity ? h : Math.round(this.rowHeight * h + Math.max(0, h - 1) * this.margin[1])
                  };
                } else {
                  out = {
                    left: Math.round(colWidth * x + (x + 1) * this.margin[0]),
                    top: Math.round(this.rowHeight * y + (y + 1) * this.margin[1]),
                    // 0 * Infinity === NaN, which causes problems with resize constriants;
                    // Fix this if it occurs.
                    // Note we do it here rather than later because Math.round(Infinity) causes deopt
                    width: w === Infinity ? w : Math.round(colWidth * w + Math.max(0, w - 1) * this.margin[0]),
                    height: h === Infinity ? h : Math.round(this.rowHeight * h + Math.max(0, h - 1) * this.margin[1])
                  };
                }
                return out;
              },
              /**
               * Translate x and y coordinates from pixels to grid units.
               * @param  {Number} top  Top position (relative to parent) in pixels.
               * @param  {Number} left Left position (relative to parent) in pixels.
               * @return {Object} x and y in grid units.
               */
              // TODO check if this function needs change in order to support rtl.
              calcXY: function calcXY(top, left) {
                var colWidth = this.calcColWidth();
                var x = Math.round((left - this.margin[0]) / (colWidth + this.margin[0]));
                var y = Math.round((top - this.margin[1]) / (this.rowHeight + this.margin[1]));
                x = Math.max(Math.min(x, this.cols - this.innerW), 0);
                y = Math.max(Math.min(y, this.maxRows - this.innerH), 0);
                return {
                  x,
                  y
                };
              },
              // Helper for generating column width
              calcColWidth: function calcColWidth() {
                var colWidth = (this.containerWidth - this.margin[0] * (this.cols + 1)) / this.cols;
                return colWidth;
              },
              // This can either be called:
              // calcGridItemWHPx(w, colWidth, margin[0])
              // or
              // calcGridItemWHPx(h, rowHeight, margin[1])
              calcGridItemWHPx: function calcGridItemWHPx(gridUnits, colOrRowSize, marginPx) {
                if (!Number.isFinite(gridUnits)) return gridUnits;
                return Math.round(colOrRowSize * gridUnits + Math.max(0, gridUnits - 1) * marginPx);
              },
              // Similar to _.clamp
              clamp: function clamp(num, lowerBound, upperBound) {
                return Math.max(Math.min(num, upperBound), lowerBound);
              },
              /**
               * Given a height and width in pixel values, calculate grid units.
               * @param  {Number} height Height in pixels.
               * @param  {Number} width  Width in pixels.
               * @param  {Boolean} autoSizeFlag  function autoSize identifier.
               * @return {Object} w, h as grid units.
               */
              calcWH: function calcWH(height, width) {
                var autoSizeFlag = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                var colWidth = this.calcColWidth();
                var w = Math.round((width + this.margin[0]) / (colWidth + this.margin[0]));
                var h = 0;
                if (!autoSizeFlag) {
                  h = Math.round((height + this.margin[1]) / (this.rowHeight + this.margin[1]));
                } else {
                  h = Math.ceil((height + this.margin[1]) / (this.rowHeight + this.margin[1]));
                }
                w = Math.max(Math.min(w, this.cols - this.innerX), 0);
                h = Math.max(Math.min(h, this.maxRows - this.innerY), 0);
                return {
                  w,
                  h
                };
              },
              updateWidth: function updateWidth(width, colNum) {
                this.containerWidth = width;
                if (colNum !== void 0 && colNum !== null) {
                  this.cols = colNum;
                }
              },
              compact: function compact() {
                this.createStyle();
              },
              tryMakeDraggable: function tryMakeDraggable() {
                var self2 = this;
                if (this.interactObj === null || this.interactObj === void 0) {
                  this.interactObj = _interactjs_interact(this.$refs.item);
                  if (!this.useStyleCursor) {
                    this.interactObj.styleCursor(false);
                  }
                }
                if (this.draggable && !this.static) {
                  var opts = _objectSpread({
                    ignoreFrom: this.dragIgnoreFrom,
                    allowFrom: this.dragAllowFrom
                  }, this.dragOption);
                  this.interactObj.draggable(opts);
                  if (!this.dragEventSet) {
                    this.dragEventSet = true;
                    this.interactObj.on("dragstart dragmove dragend", function(event) {
                      self2.handleDrag(event);
                    });
                  }
                } else {
                  this.interactObj.draggable({
                    enabled: false
                  });
                }
              },
              tryMakeResizable: function tryMakeResizable() {
                var self2 = this;
                if (this.interactObj === null || this.interactObj === void 0) {
                  this.interactObj = _interactjs_interact(this.$refs.item);
                  if (!this.useStyleCursor) {
                    this.interactObj.styleCursor(false);
                  }
                }
                if (this.resizable && !this.static) {
                  var maximum = this.calcPosition(0, 0, this.maxW, this.maxH);
                  var minimum = this.calcPosition(0, 0, this.minW, this.minH);
                  var opts = _objectSpread({
                    // allowFrom: "." + this.resizableHandleClass.trim().replace(" ", "."),
                    edges: {
                      left: false,
                      right: "." + this.resizableHandleClass.trim().replace(" ", "."),
                      bottom: "." + this.resizableHandleClass.trim().replace(" ", "."),
                      top: false
                    },
                    ignoreFrom: this.resizeIgnoreFrom,
                    restrictSize: {
                      min: {
                        height: minimum.height * this.transformScale,
                        width: minimum.width * this.transformScale
                      },
                      max: {
                        height: maximum.height * this.transformScale,
                        width: maximum.width * this.transformScale
                      }
                    }
                  }, this.resizeOption);
                  if (this.preserveAspectRatio) {
                    opts.modifiers = [_interactjs_interact.modifiers.aspectRatio({
                      ratio: "preserve"
                    })];
                  }
                  this.interactObj.resizable(opts);
                  if (!this.resizeEventSet) {
                    this.resizeEventSet = true;
                    this.interactObj.on("resizestart resizemove resizeend", function(event) {
                      self2.handleResize(event);
                    });
                  }
                } else {
                  this.interactObj.resizable({
                    enabled: false
                  });
                }
              },
              autoSize: function autoSize() {
                this.previousW = this.innerW;
                this.previousH = this.innerH;
                var newSize = this.$slots.default[0].elm.getBoundingClientRect();
                var pos = this.calcWH(newSize.height, newSize.width, true);
                if (pos.w < this.minW) {
                  pos.w = this.minW;
                }
                if (pos.w > this.maxW) {
                  pos.w = this.maxW;
                }
                if (pos.h < this.minH) {
                  pos.h = this.minH;
                }
                if (pos.h > this.maxH) {
                  pos.h = this.maxH;
                }
                if (pos.h < 1) {
                  pos.h = 1;
                }
                if (pos.w < 1) {
                  pos.w = 1;
                }
                if (this.innerW !== pos.w || this.innerH !== pos.h) {
                  this.$emit("resize", this.i, pos.h, pos.w, newSize.height, newSize.width);
                }
                if (this.previousW !== pos.w || this.previousH !== pos.h) {
                  this.$emit("resized", this.i, pos.h, pos.w, newSize.height, newSize.width);
                  this.eventBus.$emit("resizeEvent", "resizeend", this.i, this.innerX, this.innerY, pos.h, pos.w);
                }
              }
            }
          };
          var components_GridItemvue_type_script_lang_js_ = GridItemvue_type_script_lang_js_;
          __webpack_require__("5ed4");
          var componentNormalizer = __webpack_require__("2877");
          var component = Object(componentNormalizer[
            "a"
            /* default */
          ])(
            components_GridItemvue_type_script_lang_js_,
            render66,
            staticRenderFns2,
            false,
            null,
            null,
            null
          );
          __webpack_exports__["a"] = component.exports;
        }
      ),
      /***/
      "be13": (
        /***/
        function(module2, exports) {
          module2.exports = function(it) {
            if (it == void 0) throw TypeError("Can't call method on  " + it);
            return it;
          };
        }
      ),
      /***/
      "c274": (
        /***/
        function(module2, exports, __webpack_require__) {
          var utils2 = __webpack_require__("50bf");
          module2.exports = function batchProcessorMaker(options) {
            options = options || {};
            var reporter = options.reporter;
            var asyncProcess = utils2.getOption(options, "async", true);
            var autoProcess = utils2.getOption(options, "auto", true);
            if (autoProcess && !asyncProcess) {
              reporter && reporter.warn("Invalid options combination. auto=true and async=false is invalid. Setting async=true.");
              asyncProcess = true;
            }
            var batch = Batch();
            var asyncFrameHandler;
            var isProcessing = false;
            function addFunction(level, fn) {
              if (!isProcessing && autoProcess && asyncProcess && batch.size() === 0) {
                processBatchAsync();
              }
              batch.add(level, fn);
            }
            function processBatch() {
              isProcessing = true;
              while (batch.size()) {
                var processingBatch = batch;
                batch = Batch();
                processingBatch.process();
              }
              isProcessing = false;
            }
            function forceProcessBatch(localAsyncProcess) {
              if (isProcessing) {
                return;
              }
              if (localAsyncProcess === void 0) {
                localAsyncProcess = asyncProcess;
              }
              if (asyncFrameHandler) {
                cancelFrame(asyncFrameHandler);
                asyncFrameHandler = null;
              }
              if (localAsyncProcess) {
                processBatchAsync();
              } else {
                processBatch();
              }
            }
            function processBatchAsync() {
              asyncFrameHandler = requestFrame(processBatch);
            }
            function cancelFrame(listener) {
              var cancel = clearTimeout;
              return cancel(listener);
            }
            function requestFrame(callback) {
              var raf2 = function(fn) {
                return setTimeout(fn, 0);
              };
              return raf2(callback);
            }
            return {
              add: addFunction,
              force: forceProcessBatch
            };
          };
          function Batch() {
            var batch = {};
            var size2 = 0;
            var topLevel2 = 0;
            var bottomLevel2 = 0;
            function add2(level, fn) {
              if (!fn) {
                fn = level;
                level = 0;
              }
              if (level > topLevel2) {
                topLevel2 = level;
              } else if (level < bottomLevel2) {
                bottomLevel2 = level;
              }
              if (!batch[level]) {
                batch[level] = [];
              }
              batch[level].push(fn);
              size2++;
            }
            function process2() {
              for (var level = bottomLevel2; level <= topLevel2; level++) {
                var fns = batch[level];
                for (var i = 0; i < fns.length; i++) {
                  var fn = fns[i];
                  fn();
                }
              }
            }
            function getSize() {
              return size2;
            }
            return {
              add: add2,
              process: process2,
              size: getSize
            };
          }
        }
      ),
      /***/
      "c366": (
        /***/
        function(module2, exports, __webpack_require__) {
          var toIObject = __webpack_require__("6821");
          var toLength = __webpack_require__("9def");
          var toAbsoluteIndex = __webpack_require__("77f1");
          module2.exports = function(IS_INCLUDES) {
            return function($this, el, fromIndex) {
              var O = toIObject($this);
              var length = toLength(O.length);
              var index2 = toAbsoluteIndex(fromIndex, length);
              var value;
              if (IS_INCLUDES && el != el) while (length > index2) {
                value = O[index2++];
                if (value != value) return true;
              }
              else for (; length > index2; index2++) if (IS_INCLUDES || index2 in O) {
                if (O[index2] === el) return IS_INCLUDES || index2 || 0;
              }
              return !IS_INCLUDES && -1;
            };
          };
        }
      ),
      /***/
      "c5f6": (
        /***/
        function(module2, exports, __webpack_require__) {
          var global2 = __webpack_require__("7726");
          var has2 = __webpack_require__("69a8");
          var cof = __webpack_require__("2d95");
          var inheritIfRequired = __webpack_require__("5dbc");
          var toPrimitive = __webpack_require__("6a99");
          var fails = __webpack_require__("79e5");
          var gOPN = __webpack_require__("9093").f;
          var gOPD = __webpack_require__("11e9").f;
          var dP = __webpack_require__("86cc").f;
          var $trim = __webpack_require__("aa77").trim;
          var NUMBER = "Number";
          var $Number = global2[NUMBER];
          var Base = $Number;
          var proto = $Number.prototype;
          var BROKEN_COF = cof(__webpack_require__("2aeb")(proto)) == NUMBER;
          var TRIM = "trim" in String.prototype;
          var toNumber2 = function(argument) {
            var it = toPrimitive(argument, false);
            if (typeof it == "string" && it.length > 2) {
              it = TRIM ? it.trim() : $trim(it, 3);
              var first = it.charCodeAt(0);
              var third, radix, maxCode;
              if (first === 43 || first === 45) {
                third = it.charCodeAt(2);
                if (third === 88 || third === 120) return NaN;
              } else if (first === 48) {
                switch (it.charCodeAt(1)) {
                  case 66:
                  case 98:
                    radix = 2;
                    maxCode = 49;
                    break;
                  // fast equal /^0b[01]+$/i
                  case 79:
                  case 111:
                    radix = 8;
                    maxCode = 55;
                    break;
                  // fast equal /^0o[0-7]+$/i
                  default:
                    return +it;
                }
                for (var digits = it.slice(2), i = 0, l = digits.length, code2; i < l; i++) {
                  code2 = digits.charCodeAt(i);
                  if (code2 < 48 || code2 > maxCode) return NaN;
                }
                return parseInt(digits, radix);
              }
            }
            return +it;
          };
          if (!$Number(" 0o1") || !$Number("0b1") || $Number("+0x1")) {
            $Number = function Number2(value) {
              var it = arguments.length < 1 ? 0 : value;
              var that = this;
              return that instanceof $Number && (BROKEN_COF ? fails(function() {
                proto.valueOf.call(that);
              }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber2(it)), that, $Number) : toNumber2(it);
            };
            for (var keys = __webpack_require__("9e1e") ? gOPN(Base) : (
              // ES3:
              "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(",")
            ), j = 0, key; keys.length > j; j++) {
              if (has2(Base, key = keys[j]) && !has2($Number, key)) {
                dP($Number, key, gOPD(Base, key));
              }
            }
            $Number.prototype = proto;
            proto.constructor = $Number;
            __webpack_require__("2aba")(global2, NUMBER, $Number);
          }
        }
      ),
      /***/
      "c69a": (
        /***/
        function(module2, exports, __webpack_require__) {
          module2.exports = !__webpack_require__("9e1e") && !__webpack_require__("79e5")(function() {
            return Object.defineProperty(__webpack_require__("230e")("div"), "a", { get: function() {
              return 7;
            } }).a != 7;
          });
        }
      ),
      /***/
      "c8ba": (
        /***/
        function(module2, exports) {
          var g;
          g = /* @__PURE__ */ function() {
            return this;
          }();
          try {
            g = g || new Function("return this")();
          } catch (e) {
            if (typeof window === "object") g = window;
          }
          module2.exports = g;
        }
      ),
      /***/
      "c946": (
        /***/
        function(module2, exports, __webpack_require__) {
          var forEach2 = __webpack_require__("b770").forEach;
          module2.exports = function(options) {
            options = options || {};
            var reporter = options.reporter;
            var batchProcessor = options.batchProcessor;
            var getState = options.stateHandler.getState;
            options.stateHandler.hasState;
            var idHandler = options.idHandler;
            if (!batchProcessor) {
              throw new Error("Missing required dependency: batchProcessor");
            }
            if (!reporter) {
              throw new Error("Missing required dependency: reporter.");
            }
            var scrollbarSizes = getScrollbarSizes();
            var styleId = "erd_scroll_detection_scrollbar_style";
            var detectionContainerClass = "erd_scroll_detection_container";
            function initDocument(targetDocument) {
              injectScrollStyle(targetDocument, styleId, detectionContainerClass);
            }
            initDocument(window.document);
            function buildCssTextString(rules) {
              var seperator = options.important ? " !important; " : "; ";
              return (rules.join(seperator) + seperator).trim();
            }
            function getScrollbarSizes() {
              var width = 500;
              var height = 500;
              var child = document.createElement("div");
              child.style.cssText = buildCssTextString(["position: absolute", "width: " + width * 2 + "px", "height: " + height * 2 + "px", "visibility: hidden", "margin: 0", "padding: 0"]);
              var container = document.createElement("div");
              container.style.cssText = buildCssTextString(["position: absolute", "width: " + width + "px", "height: " + height + "px", "overflow: scroll", "visibility: none", "top: " + -width * 3 + "px", "left: " + -height * 3 + "px", "visibility: hidden", "margin: 0", "padding: 0"]);
              container.appendChild(child);
              document.body.insertBefore(container, document.body.firstChild);
              var widthSize = width - container.clientWidth;
              var heightSize = height - container.clientHeight;
              document.body.removeChild(container);
              return {
                width: widthSize,
                height: heightSize
              };
            }
            function injectScrollStyle(targetDocument, styleId2, containerClass) {
              function injectStyle(style22, method) {
                method = method || function(element) {
                  targetDocument.head.appendChild(element);
                };
                var styleElement = targetDocument.createElement("style");
                styleElement.innerHTML = style22;
                styleElement.id = styleId2;
                method(styleElement);
                return styleElement;
              }
              if (!targetDocument.getElementById(styleId2)) {
                var containerAnimationClass = containerClass + "_animation";
                var containerAnimationActiveClass = containerClass + "_animation_active";
                var style2 = "/* Created by the element-resize-detector library. */\n";
                style2 += "." + containerClass + " > div::-webkit-scrollbar { " + buildCssTextString(["display: none"]) + " }\n\n";
                style2 += "." + containerAnimationActiveClass + " { " + buildCssTextString(["-webkit-animation-duration: 0.1s", "animation-duration: 0.1s", "-webkit-animation-name: " + containerAnimationClass, "animation-name: " + containerAnimationClass]) + " }\n";
                style2 += "@-webkit-keyframes " + containerAnimationClass + " { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }\n";
                style2 += "@keyframes " + containerAnimationClass + " { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }";
                injectStyle(style2);
              }
            }
            function addAnimationClass(element) {
              element.className += " " + detectionContainerClass + "_animation_active";
            }
            function addEvent(el, name, cb) {
              if (el.addEventListener) {
                el.addEventListener(name, cb);
              } else if (el.attachEvent) {
                el.attachEvent("on" + name, cb);
              } else {
                return reporter.error("[scroll] Don't know how to add event listeners.");
              }
            }
            function removeEvent(el, name, cb) {
              if (el.removeEventListener) {
                el.removeEventListener(name, cb);
              } else if (el.detachEvent) {
                el.detachEvent("on" + name, cb);
              } else {
                return reporter.error("[scroll] Don't know how to remove event listeners.");
              }
            }
            function getExpandElement(element) {
              return getState(element).container.childNodes[0].childNodes[0].childNodes[0];
            }
            function getShrinkElement(element) {
              return getState(element).container.childNodes[0].childNodes[0].childNodes[1];
            }
            function addListener(element, listener) {
              var listeners = getState(element).listeners;
              if (!listeners.push) {
                throw new Error("Cannot add listener to an element that is not detectable.");
              }
              getState(element).listeners.push(listener);
            }
            function makeDetectable(options2, element, callback) {
              if (!callback) {
                callback = element;
                element = options2;
                options2 = null;
              }
              options2 = options2 || {};
              function debug() {
                if (options2.debug) {
                  var args = Array.prototype.slice.call(arguments);
                  args.unshift(idHandler.get(element), "Scroll: ");
                  if (reporter.log.apply) {
                    reporter.log.apply(null, args);
                  } else {
                    for (var i = 0; i < args.length; i++) {
                      reporter.log(args[i]);
                    }
                  }
                }
              }
              function isDetached(element2) {
                function isInDocument(element3) {
                  var isInShadowRoot = element3.getRootNode && element3.getRootNode().contains(element3);
                  return element3 === element3.ownerDocument.body || element3.ownerDocument.body.contains(element3) || isInShadowRoot;
                }
                if (!isInDocument(element2)) {
                  return true;
                }
                if (window.getComputedStyle(element2) === null) {
                  return true;
                }
                return false;
              }
              function isUnrendered(element2) {
                var container = getState(element2).container.childNodes[0];
                var style2 = window.getComputedStyle(container);
                return !style2.width || style2.width.indexOf("px") === -1;
              }
              function getStyle2() {
                var elementStyle = window.getComputedStyle(element);
                var style2 = {};
                style2.position = elementStyle.position;
                style2.width = element.offsetWidth;
                style2.height = element.offsetHeight;
                style2.top = elementStyle.top;
                style2.right = elementStyle.right;
                style2.bottom = elementStyle.bottom;
                style2.left = elementStyle.left;
                style2.widthCSS = elementStyle.width;
                style2.heightCSS = elementStyle.height;
                return style2;
              }
              function storeStartSize() {
                var style2 = getStyle2();
                getState(element).startSize = {
                  width: style2.width,
                  height: style2.height
                };
                debug("Element start size", getState(element).startSize);
              }
              function initListeners() {
                getState(element).listeners = [];
              }
              function storeStyle() {
                debug("storeStyle invoked.");
                if (!getState(element)) {
                  debug("Aborting because element has been uninstalled");
                  return;
                }
                var style2 = getStyle2();
                getState(element).style = style2;
              }
              function storeCurrentSize(element2, width, height) {
                getState(element2).lastWidth = width;
                getState(element2).lastHeight = height;
              }
              function getExpandChildElement(element2) {
                return getExpandElement(element2).childNodes[0];
              }
              function getWidthOffset() {
                return 2 * scrollbarSizes.width + 1;
              }
              function getHeightOffset() {
                return 2 * scrollbarSizes.height + 1;
              }
              function getExpandWidth(width) {
                return width + 10 + getWidthOffset();
              }
              function getExpandHeight(height) {
                return height + 10 + getHeightOffset();
              }
              function getShrinkWidth(width) {
                return width * 2 + getWidthOffset();
              }
              function getShrinkHeight(height) {
                return height * 2 + getHeightOffset();
              }
              function positionScrollbars(element2, width, height) {
                var expand = getExpandElement(element2);
                var shrink = getShrinkElement(element2);
                var expandWidth = getExpandWidth(width);
                var expandHeight = getExpandHeight(height);
                var shrinkWidth = getShrinkWidth(width);
                var shrinkHeight = getShrinkHeight(height);
                expand.scrollLeft = expandWidth;
                expand.scrollTop = expandHeight;
                shrink.scrollLeft = shrinkWidth;
                shrink.scrollTop = shrinkHeight;
              }
              function injectContainerElement() {
                var container = getState(element).container;
                if (!container) {
                  container = document.createElement("div");
                  container.className = detectionContainerClass;
                  container.style.cssText = buildCssTextString(["visibility: hidden", "display: inline", "width: 0px", "height: 0px", "z-index: -1", "overflow: hidden", "margin: 0", "padding: 0"]);
                  getState(element).container = container;
                  addAnimationClass(container);
                  element.appendChild(container);
                  var onAnimationStart = function() {
                    getState(element).onRendered && getState(element).onRendered();
                  };
                  addEvent(container, "animationstart", onAnimationStart);
                  getState(element).onAnimationStart = onAnimationStart;
                }
                return container;
              }
              function injectScrollElements() {
                function alterPositionStyles() {
                  var style2 = getState(element).style;
                  if (style2.position === "static") {
                    element.style.setProperty("position", "relative", options2.important ? "important" : "");
                    var removeRelativeStyles = function(reporter2, element2, style22, property) {
                      function getNumericalValue(value2) {
                        return value2.replace(/[^-\d\.]/g, "");
                      }
                      var value = style22[property];
                      if (value !== "auto" && getNumericalValue(value) !== "0") {
                        reporter2.warn("An element that is positioned static has style." + property + "=" + value + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + property + " will be set to 0. Element: ", element2);
                        element2.style[property] = 0;
                      }
                    };
                    removeRelativeStyles(reporter, element, style2, "top");
                    removeRelativeStyles(reporter, element, style2, "right");
                    removeRelativeStyles(reporter, element, style2, "bottom");
                    removeRelativeStyles(reporter, element, style2, "left");
                  }
                }
                function getLeftTopBottomRightCssText(left, top, bottom, right) {
                  left = !left ? "0" : left + "px";
                  top = !top ? "0" : top + "px";
                  bottom = !bottom ? "0" : bottom + "px";
                  right = !right ? "0" : right + "px";
                  return ["left: " + left, "top: " + top, "right: " + right, "bottom: " + bottom];
                }
                debug("Injecting elements");
                if (!getState(element)) {
                  debug("Aborting because element has been uninstalled");
                  return;
                }
                alterPositionStyles();
                var rootContainer = getState(element).container;
                if (!rootContainer) {
                  rootContainer = injectContainerElement();
                }
                var scrollbarWidth = scrollbarSizes.width;
                var scrollbarHeight = scrollbarSizes.height;
                var containerContainerStyle = buildCssTextString(["position: absolute", "flex: none", "overflow: hidden", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%", "left: 0px", "top: 0px"]);
                var containerStyle = buildCssTextString(["position: absolute", "flex: none", "overflow: hidden", "z-index: -1", "visibility: hidden"].concat(getLeftTopBottomRightCssText(-(1 + scrollbarWidth), -(1 + scrollbarHeight), -scrollbarHeight, -scrollbarWidth)));
                var expandStyle = buildCssTextString(["position: absolute", "flex: none", "overflow: scroll", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%"]);
                var shrinkStyle = buildCssTextString(["position: absolute", "flex: none", "overflow: scroll", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%"]);
                var expandChildStyle = buildCssTextString(["position: absolute", "left: 0", "top: 0"]);
                var shrinkChildStyle = buildCssTextString(["position: absolute", "width: 200%", "height: 200%"]);
                var containerContainer = document.createElement("div");
                var container = document.createElement("div");
                var expand = document.createElement("div");
                var expandChild = document.createElement("div");
                var shrink = document.createElement("div");
                var shrinkChild = document.createElement("div");
                containerContainer.dir = "ltr";
                containerContainer.style.cssText = containerContainerStyle;
                containerContainer.className = detectionContainerClass;
                container.className = detectionContainerClass;
                container.style.cssText = containerStyle;
                expand.style.cssText = expandStyle;
                expandChild.style.cssText = expandChildStyle;
                shrink.style.cssText = shrinkStyle;
                shrinkChild.style.cssText = shrinkChildStyle;
                expand.appendChild(expandChild);
                shrink.appendChild(shrinkChild);
                container.appendChild(expand);
                container.appendChild(shrink);
                containerContainer.appendChild(container);
                rootContainer.appendChild(containerContainer);
                function onExpandScroll() {
                  var state = getState(element);
                  if (state && state.onExpand) {
                    state.onExpand();
                  } else {
                    debug("Aborting expand scroll handler: element has been uninstalled");
                  }
                }
                function onShrinkScroll() {
                  var state = getState(element);
                  if (state && state.onShrink) {
                    state.onShrink();
                  } else {
                    debug("Aborting shrink scroll handler: element has been uninstalled");
                  }
                }
                addEvent(expand, "scroll", onExpandScroll);
                addEvent(shrink, "scroll", onShrinkScroll);
                getState(element).onExpandScroll = onExpandScroll;
                getState(element).onShrinkScroll = onShrinkScroll;
              }
              function registerListenersAndPositionElements() {
                function updateChildSizes(element2, width, height) {
                  var expandChild = getExpandChildElement(element2);
                  var expandWidth = getExpandWidth(width);
                  var expandHeight = getExpandHeight(height);
                  expandChild.style.setProperty("width", expandWidth + "px", options2.important ? "important" : "");
                  expandChild.style.setProperty("height", expandHeight + "px", options2.important ? "important" : "");
                }
                function updateDetectorElements(done) {
                  var width = element.offsetWidth;
                  var height = element.offsetHeight;
                  var sizeChanged = width !== getState(element).lastWidth || height !== getState(element).lastHeight;
                  debug("Storing current size", width, height);
                  storeCurrentSize(element, width, height);
                  batchProcessor.add(0, function performUpdateChildSizes() {
                    if (!sizeChanged) {
                      return;
                    }
                    if (!getState(element)) {
                      debug("Aborting because element has been uninstalled");
                      return;
                    }
                    if (!areElementsInjected()) {
                      debug("Aborting because element container has not been initialized");
                      return;
                    }
                    if (options2.debug) {
                      var w = element.offsetWidth;
                      var h = element.offsetHeight;
                      if (w !== width || h !== height) {
                        reporter.warn(idHandler.get(element), "Scroll: Size changed before updating detector elements.");
                      }
                    }
                    updateChildSizes(element, width, height);
                  });
                  batchProcessor.add(1, function updateScrollbars() {
                    if (!getState(element)) {
                      debug("Aborting because element has been uninstalled");
                      return;
                    }
                    if (!areElementsInjected()) {
                      debug("Aborting because element container has not been initialized");
                      return;
                    }
                    positionScrollbars(element, width, height);
                  });
                  if (sizeChanged && done) {
                    batchProcessor.add(2, function() {
                      if (!getState(element)) {
                        debug("Aborting because element has been uninstalled");
                        return;
                      }
                      if (!areElementsInjected()) {
                        debug("Aborting because element container has not been initialized");
                        return;
                      }
                      done();
                    });
                  }
                }
                function areElementsInjected() {
                  return !!getState(element).container;
                }
                function notifyListenersIfNeeded() {
                  function isFirstNotify() {
                    return getState(element).lastNotifiedWidth === void 0;
                  }
                  debug("notifyListenersIfNeeded invoked");
                  var state = getState(element);
                  if (isFirstNotify() && state.lastWidth === state.startSize.width && state.lastHeight === state.startSize.height) {
                    return debug("Not notifying: Size is the same as the start size, and there has been no notification yet.");
                  }
                  if (state.lastWidth === state.lastNotifiedWidth && state.lastHeight === state.lastNotifiedHeight) {
                    return debug("Not notifying: Size already notified");
                  }
                  debug("Current size not notified, notifying...");
                  state.lastNotifiedWidth = state.lastWidth;
                  state.lastNotifiedHeight = state.lastHeight;
                  forEach2(getState(element).listeners, function(listener) {
                    listener(element);
                  });
                }
                function handleRender() {
                  debug("startanimation triggered.");
                  if (isUnrendered(element)) {
                    debug("Ignoring since element is still unrendered...");
                    return;
                  }
                  debug("Element rendered.");
                  var expand = getExpandElement(element);
                  var shrink = getShrinkElement(element);
                  if (expand.scrollLeft === 0 || expand.scrollTop === 0 || shrink.scrollLeft === 0 || shrink.scrollTop === 0) {
                    debug("Scrollbars out of sync. Updating detector elements...");
                    updateDetectorElements(notifyListenersIfNeeded);
                  }
                }
                function handleScroll() {
                  debug("Scroll detected.");
                  if (isUnrendered(element)) {
                    debug("Scroll event fired while unrendered. Ignoring...");
                    return;
                  }
                  updateDetectorElements(notifyListenersIfNeeded);
                }
                debug("registerListenersAndPositionElements invoked.");
                if (!getState(element)) {
                  debug("Aborting because element has been uninstalled");
                  return;
                }
                getState(element).onRendered = handleRender;
                getState(element).onExpand = handleScroll;
                getState(element).onShrink = handleScroll;
                var style2 = getState(element).style;
                updateChildSizes(element, style2.width, style2.height);
              }
              function finalizeDomMutation() {
                debug("finalizeDomMutation invoked.");
                if (!getState(element)) {
                  debug("Aborting because element has been uninstalled");
                  return;
                }
                var style2 = getState(element).style;
                storeCurrentSize(element, style2.width, style2.height);
                positionScrollbars(element, style2.width, style2.height);
              }
              function ready() {
                callback(element);
              }
              function install2() {
                debug("Installing...");
                initListeners();
                storeStartSize();
                batchProcessor.add(0, storeStyle);
                batchProcessor.add(1, injectScrollElements);
                batchProcessor.add(2, registerListenersAndPositionElements);
                batchProcessor.add(3, finalizeDomMutation);
                batchProcessor.add(4, ready);
              }
              debug("Making detectable...");
              if (isDetached(element)) {
                debug("Element is detached");
                injectContainerElement();
                debug("Waiting until element is attached...");
                getState(element).onRendered = function() {
                  debug("Element is now attached");
                  install2();
                };
              } else {
                install2();
              }
            }
            function uninstall(element) {
              var state = getState(element);
              if (!state) {
                return;
              }
              state.onExpandScroll && removeEvent(getExpandElement(element), "scroll", state.onExpandScroll);
              state.onShrinkScroll && removeEvent(getShrinkElement(element), "scroll", state.onShrinkScroll);
              state.onAnimationStart && removeEvent(state.container, "animationstart", state.onAnimationStart);
              state.container && element.removeChild(state.container);
            }
            return {
              makeDetectable,
              addListener,
              uninstall,
              initDocument
            };
          };
        }
      ),
      /***/
      "ca5a": (
        /***/
        function(module2, exports) {
          var id = 0;
          var px = Math.random();
          module2.exports = function(key) {
            return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36));
          };
        }
      ),
      /***/
      "cadf": (
        /***/
        function(module2, exports, __webpack_require__) {
          var addToUnscopables = __webpack_require__("9c6c");
          var step = __webpack_require__("d53b");
          var Iterators = __webpack_require__("84f2");
          var toIObject = __webpack_require__("6821");
          module2.exports = __webpack_require__("01f9")(Array, "Array", function(iterated, kind) {
            this._t = toIObject(iterated);
            this._i = 0;
            this._k = kind;
          }, function() {
            var O = this._t;
            var kind = this._k;
            var index2 = this._i++;
            if (!O || index2 >= O.length) {
              this._t = void 0;
              return step(1);
            }
            if (kind == "keys") return step(0, index2);
            if (kind == "values") return step(0, O[index2]);
            return step(0, [index2, O[index2]]);
          }, "values");
          Iterators.Arguments = Iterators.Array;
          addToUnscopables("keys");
          addToUnscopables("values");
          addToUnscopables("entries");
        }
      ),
      /***/
      "cb7c": (
        /***/
        function(module2, exports, __webpack_require__) {
          var isObject2 = __webpack_require__("d3f4");
          module2.exports = function(it) {
            if (!isObject2(it)) throw TypeError(it + " is not an object!");
            return it;
          };
        }
      ),
      /***/
      "ce10": (
        /***/
        function(module2, exports, __webpack_require__) {
          var has2 = __webpack_require__("69a8");
          var toIObject = __webpack_require__("6821");
          var arrayIndexOf = __webpack_require__("c366")(false);
          var IE_PROTO = __webpack_require__("613b")("IE_PROTO");
          module2.exports = function(object, names) {
            var O = toIObject(object);
            var i = 0;
            var result = [];
            var key;
            for (key in O) if (key != IE_PROTO) has2(O, key) && result.push(key);
            while (names.length > i) if (has2(O, key = names[i++])) {
              ~arrayIndexOf(result, key) || result.push(key);
            }
            return result;
          };
        }
      ),
      /***/
      "d3f4": (
        /***/
        function(module2, exports) {
          module2.exports = function(it) {
            return typeof it === "object" ? it !== null : typeof it === "function";
          };
        }
      ),
      /***/
      "d53b": (
        /***/
        function(module2, exports) {
          module2.exports = function(done, value) {
            return { value, done: !!done };
          };
        }
      ),
      /***/
      "d6eb": (
        /***/
        function(module2, exports, __webpack_require__) {
          var prop = "_erd";
          function initState2(element) {
            element[prop] = {};
            return getState(element);
          }
          function getState(element) {
            return element[prop];
          }
          function cleanState(element) {
            delete element[prop];
          }
          module2.exports = {
            initState: initState2,
            getState,
            cleanState
          };
        }
      ),
      /***/
      "d8e8": (
        /***/
        function(module2, exports) {
          module2.exports = function(it) {
            if (typeof it != "function") throw TypeError(it + " is not a function!");
            return it;
          };
        }
      ),
      /***/
      "e11e": (
        /***/
        function(module2, exports) {
          module2.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
        }
      ),
      /***/
      "e279": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          __webpack_require__("1156");
        }
      ),
      /***/
      "eec4": (
        /***/
        function(module2, exports, __webpack_require__) {
          var forEach2 = __webpack_require__("b770").forEach;
          var elementUtilsMaker = __webpack_require__("5be5");
          var listenerHandlerMaker = __webpack_require__("49ad");
          var idGeneratorMaker = __webpack_require__("2cef");
          var idHandlerMaker = __webpack_require__("5058");
          var reporterMaker = __webpack_require__("abb4");
          var browserDetector = __webpack_require__("18e9");
          var batchProcessorMaker = __webpack_require__("c274");
          var stateHandler = __webpack_require__("d6eb");
          var objectStrategyMaker = __webpack_require__("18d2");
          var scrollStrategyMaker = __webpack_require__("c946");
          function isCollection(obj) {
            return Array.isArray(obj) || obj.length !== void 0;
          }
          function toArray2(collection) {
            if (!Array.isArray(collection)) {
              var array = [];
              forEach2(collection, function(obj) {
                array.push(obj);
              });
              return array;
            } else {
              return collection;
            }
          }
          function isElement2(obj) {
            return obj && obj.nodeType === 1;
          }
          module2.exports = function(options) {
            options = options || {};
            var idHandler;
            if (options.idHandler) {
              idHandler = {
                get: function(element) {
                  return options.idHandler.get(element, true);
                },
                set: options.idHandler.set
              };
            } else {
              var idGenerator = idGeneratorMaker();
              var defaultIdHandler = idHandlerMaker({
                idGenerator,
                stateHandler
              });
              idHandler = defaultIdHandler;
            }
            var reporter = options.reporter;
            if (!reporter) {
              var quiet = reporter === false;
              reporter = reporterMaker(quiet);
            }
            var batchProcessor = getOption(options, "batchProcessor", batchProcessorMaker({ reporter }));
            var globalOptions = {};
            globalOptions.callOnAdd = !!getOption(options, "callOnAdd", true);
            globalOptions.debug = !!getOption(options, "debug", false);
            var eventListenerHandler = listenerHandlerMaker(idHandler);
            var elementUtils = elementUtilsMaker({
              stateHandler
            });
            var detectionStrategy;
            var desiredStrategy = getOption(options, "strategy", "object");
            var importantCssRules = getOption(options, "important", false);
            var strategyOptions = {
              reporter,
              batchProcessor,
              stateHandler,
              idHandler,
              important: importantCssRules
            };
            if (desiredStrategy === "scroll") {
              if (browserDetector.isLegacyOpera()) {
                reporter.warn("Scroll strategy is not supported on legacy Opera. Changing to object strategy.");
                desiredStrategy = "object";
              } else if (browserDetector.isIE(9)) {
                reporter.warn("Scroll strategy is not supported on IE9. Changing to object strategy.");
                desiredStrategy = "object";
              }
            }
            if (desiredStrategy === "scroll") {
              detectionStrategy = scrollStrategyMaker(strategyOptions);
            } else if (desiredStrategy === "object") {
              detectionStrategy = objectStrategyMaker(strategyOptions);
            } else {
              throw new Error("Invalid strategy name: " + desiredStrategy);
            }
            var onReadyCallbacks = {};
            function listenTo(options2, elements, listener) {
              function onResizeCallback(element) {
                var listeners = eventListenerHandler.get(element);
                forEach2(listeners, function callListenerProxy(listener2) {
                  listener2(element);
                });
              }
              function addListener(callOnAdd2, element, listener2) {
                eventListenerHandler.add(element, listener2);
                if (callOnAdd2) {
                  listener2(element);
                }
              }
              if (!listener) {
                listener = elements;
                elements = options2;
                options2 = {};
              }
              if (!elements) {
                throw new Error("At least one element required.");
              }
              if (!listener) {
                throw new Error("Listener required.");
              }
              if (isElement2(elements)) {
                elements = [elements];
              } else if (isCollection(elements)) {
                elements = toArray2(elements);
              } else {
                return reporter.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
              }
              var elementsReady = 0;
              var callOnAdd = getOption(options2, "callOnAdd", globalOptions.callOnAdd);
              var onReadyCallback = getOption(options2, "onReady", function noop2() {
              });
              var debug = getOption(options2, "debug", globalOptions.debug);
              forEach2(elements, function attachListenerToElement(element) {
                if (!stateHandler.getState(element)) {
                  stateHandler.initState(element);
                  idHandler.set(element);
                }
                var id = idHandler.get(element);
                debug && reporter.log("Attaching listener to element", id, element);
                if (!elementUtils.isDetectable(element)) {
                  debug && reporter.log(id, "Not detectable.");
                  if (elementUtils.isBusy(element)) {
                    debug && reporter.log(id, "System busy making it detectable");
                    addListener(callOnAdd, element, listener);
                    onReadyCallbacks[id] = onReadyCallbacks[id] || [];
                    onReadyCallbacks[id].push(function onReady() {
                      elementsReady++;
                      if (elementsReady === elements.length) {
                        onReadyCallback();
                      }
                    });
                    return;
                  }
                  debug && reporter.log(id, "Making detectable...");
                  elementUtils.markBusy(element, true);
                  return detectionStrategy.makeDetectable({ debug, important: importantCssRules }, element, function onElementDetectable(element2) {
                    debug && reporter.log(id, "onElementDetectable");
                    if (stateHandler.getState(element2)) {
                      elementUtils.markAsDetectable(element2);
                      elementUtils.markBusy(element2, false);
                      detectionStrategy.addListener(element2, onResizeCallback);
                      addListener(callOnAdd, element2, listener);
                      var state = stateHandler.getState(element2);
                      if (state && state.startSize) {
                        var width = element2.offsetWidth;
                        var height = element2.offsetHeight;
                        if (state.startSize.width !== width || state.startSize.height !== height) {
                          onResizeCallback(element2);
                        }
                      }
                      if (onReadyCallbacks[id]) {
                        forEach2(onReadyCallbacks[id], function(callback) {
                          callback();
                        });
                      }
                    } else {
                      debug && reporter.log(id, "Element uninstalled before being detectable.");
                    }
                    delete onReadyCallbacks[id];
                    elementsReady++;
                    if (elementsReady === elements.length) {
                      onReadyCallback();
                    }
                  });
                }
                debug && reporter.log(id, "Already detecable, adding listener.");
                addListener(callOnAdd, element, listener);
                elementsReady++;
              });
              if (elementsReady === elements.length) {
                onReadyCallback();
              }
            }
            function uninstall(elements) {
              if (!elements) {
                return reporter.error("At least one element is required.");
              }
              if (isElement2(elements)) {
                elements = [elements];
              } else if (isCollection(elements)) {
                elements = toArray2(elements);
              } else {
                return reporter.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
              }
              forEach2(elements, function(element) {
                eventListenerHandler.removeAllListeners(element);
                detectionStrategy.uninstall(element);
                stateHandler.cleanState(element);
              });
            }
            function initDocument(targetDocument) {
              detectionStrategy.initDocument && detectionStrategy.initDocument(targetDocument);
            }
            return {
              listenTo,
              removeListener: eventListenerHandler.removeListener,
              removeAllListeners: eventListenerHandler.removeAllListeners,
              uninstall,
              initDocument
            };
          };
          function getOption(options, name, defaultValue) {
            var value = options[name];
            if ((value === void 0 || value === null) && defaultValue !== void 0) {
              return defaultValue;
            }
            return value;
          }
        }
      ),
      /***/
      "f1ae": (
        /***/
        function(module2, exports, __webpack_require__) {
          var $defineProperty = __webpack_require__("86cc");
          var createDesc = __webpack_require__("4630");
          module2.exports = function(object, index2, value) {
            if (index2 in object) $defineProperty.f(object, index2, createDesc(0, value));
            else object[index2] = value;
          };
        }
      ),
      /***/
      "f6fd": (
        /***/
        function(module2, exports) {
          (function(document2) {
            var currentScript = "currentScript", scripts = document2.getElementsByTagName("script");
            if (!(currentScript in document2)) {
              Object.defineProperty(document2, currentScript, {
                get: function() {
                  try {
                    throw new Error();
                  } catch (err) {
                    var i, res = (/.*at [^\(]*\((.*):.+:.+\)$/ig.exec(err.stack) || [false])[1];
                    for (i in scripts) {
                      if (scripts[i].src == res || scripts[i].readyState == "interactive") {
                        return scripts[i];
                      }
                    }
                    return null;
                  }
                }
              });
            }
          })(document);
        }
      ),
      /***/
      "f751": (
        /***/
        function(module2, exports, __webpack_require__) {
          var $export = __webpack_require__("5ca1");
          $export($export.S + $export.F, "Object", { assign: __webpack_require__("7333") });
        }
      ),
      /***/
      "fa5b": (
        /***/
        function(module2, exports, __webpack_require__) {
          module2.exports = __webpack_require__("5537")("native-function-to-string", Function.toString);
        }
      ),
      /***/
      "fab2": (
        /***/
        function(module2, exports, __webpack_require__) {
          var document2 = __webpack_require__("7726").document;
          module2.exports = document2 && document2.documentElement;
        }
      ),
      /***/
      "fb15": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          __webpack_require__.r(__webpack_exports__);
          __webpack_require__.d(__webpack_exports__, "install", function() {
            return (
              /* reexport */
              components[
                "d"
                /* install */
              ]
            );
          });
          __webpack_require__.d(__webpack_exports__, "GridLayout", function() {
            return (
              /* reexport */
              components[
                "b"
                /* GridLayout */
              ]
            );
          });
          __webpack_require__.d(__webpack_exports__, "GridItem", function() {
            return (
              /* reexport */
              components[
                "a"
                /* GridItem */
              ]
            );
          });
          if (typeof window !== "undefined") {
            {
              __webpack_require__("f6fd");
            }
            var i;
            if ((i = window.document.currentScript) && (i = i.src.match(/(.+\/)[^/]+\.js(\?.*)?$/))) {
              __webpack_require__.p = i[1];
            }
          }
          var components = __webpack_require__("2af9");
          __webpack_exports__["default"] = components[
            "c"
            /* default */
          ];
        }
      ),
      /***/
      "fca0": (
        /***/
        function(module2, exports, __webpack_require__) {
          var $export = __webpack_require__("5ca1");
          var _isFinite = __webpack_require__("7726").isFinite;
          $export($export.S, "Number", {
            isFinite: function isFinite2(it) {
              return typeof it == "number" && _isFinite(it);
            }
          });
        }
      ),
      /***/
      "fdef": (
        /***/
        function(module2, exports) {
          module2.exports = "	\n\v\f\r   ᠎             　\u2028\u2029\uFEFF";
        }
      )
      /******/
    })["default"];
  })(vueGridLayout_common);
  return vueGridLayout_common.exports;
}
var vueGridLayout_commonExports = requireVueGridLayout_common();
function bind$1(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const { iterator, toStringTag } = Symbol;
const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global$1;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind$1(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props2, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props2 && Object.assign(constructor.prototype, props2);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props2;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props2 = Object.getOwnPropertyNames(sourceObj);
    i = props2.length;
    while (i-- > 0) {
      prop = props2[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches2;
  const arr = [];
  while ((matches2 = regExp.exec(str)) !== null) {
    arr.push(matches2);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer2(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target2 = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target2[key] = reducedValue);
        });
        stack[i] = void 0;
        return target2;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token2, callbacks2) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token2) {
        callbacks2.length && callbacks2.shift()();
      }
    }, false);
    return (cb) => {
      callbacks2.push(cb);
      _global.postMessage(token2, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process$1 !== "undefined" && process$1.nextTick || _setImmediate;
const isIterable = (thing) => thing != null && isFunction(thing[iterator]);
const utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset2, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer2[offset2 + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset2 + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer2[offset2 + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value, offset2, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset2 + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset2 + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer2[offset2 + i - d] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer2;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new GlobalUint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new GlobalUint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (GlobalArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
  Object.setPrototypeOf(Buffer2, GlobalUint8Array);
  function assertSize(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc(size2, fill, encoding) {
    assertSize(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer2.alloc = function(size2, fill, encoding) {
    return alloc(size2, fill, encoding);
  };
  function allocUnsafe(size2) {
    assertSize(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe(size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe(size2);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, GlobalUint8Array)) {
      const copy = new GlobalUint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new GlobalUint8Array(array);
    } else if (length === void 0) {
      buf = new GlobalUint8Array(array, byteOffset);
    } else {
      buf = new GlobalUint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer2(b) {
    return b != null && b._isBuffer === true && b !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a, b) {
    if (isInstance(a, GlobalUint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b, GlobalUint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for (let i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i = 0; i < list.length; ++i) {
      let buf = list[i];
      if (isInstance(buf, GlobalUint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          GlobalUint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b, n2, m) {
    const i = b[n2];
    b[n2] = b[m];
    b[m] = i;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString3() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b) {
    if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer2.compare(this, b) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    let str = "";
    const max2 = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target2, start, end, thisStart, thisEnd) {
    if (isInstance(target2, GlobalUint8Array)) {
      target2 = Buffer2.from(target2, target2.offset, target2.byteLength);
    }
    if (!Buffer2.isBuffer(target2)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target2
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target2 ? target2.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target2.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target2) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target2.slice(start, end);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof GlobalUint8Array.prototype.indexOf === "function") {
        if (dir) {
          return GlobalUint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return GlobalUint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found) return i;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset2, length) {
    offset2 = Number(offset2) || 0;
    const remaining = buf.length - offset2;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i;
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) return i;
      buf[offset2 + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset2, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset2), buf, offset2, length);
  }
  function asciiWrite(buf, string, offset2, length) {
    return blitBuffer(asciiToBytes(string), buf, offset2, length);
  }
  function base64Write(buf, string, offset2, length) {
    return blitBuffer(base64ToBytes(string), buf, offset2, length);
  }
  function ucs2Write(buf, string, offset2, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset2), buf, offset2, length);
  }
  Buffer2.prototype.write = function write(string, offset2, length, encoding) {
    if (offset2 === void 0) {
      encoding = "utf8";
      length = this.length;
      offset2 = 0;
    } else if (length === void 0 && typeof offset2 === "string") {
      encoding = offset2;
      length = this.length;
      offset2 = 0;
    } else if (isFinite(offset2)) {
      offset2 = offset2 >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset2;
    if (length === void 0 || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset2 < 0) || offset2 > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset2, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset2, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset2, length);
        case "base64":
          return base64Write(this, string, offset2, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset2, length);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON2() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while (i < end) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset2, ext, length) {
    if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
    if (offset2 + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset2, byteLength3, this.length);
    let val = this[offset2];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset2 + i] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset2, byteLength3, this.length);
    }
    let val = this[offset2 + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset2 + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 1, this.length);
    return this[offset2];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 2, this.length);
    return this[offset2] | this[offset2 + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 2, this.length);
    return this[offset2] << 8 | this[offset2 + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const lo = first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24;
    const hi = this[++offset2] + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
    const lo = this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset2, byteLength3, this.length);
    let val = this[offset2];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset2 + i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset2, byteLength3, this.length);
    let i = byteLength3;
    let mul = 1;
    let val = this[offset2 + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset2 + --i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 1, this.length);
    if (!(this[offset2] & 128)) return this[offset2];
    return (255 - this[offset2] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 2, this.length);
    const val = this[offset2] | this[offset2 + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 2, this.length);
    const val = this[offset2 + 1] | this[offset2] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const val = this[offset2 + 4] + this[offset2 + 5] * 2 ** 8 + this[offset2 + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, false, 52, 8);
  };
  function checkInt(buf, value, offset2, ext, max2, min2) {
    if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds');
    if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset2, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset2] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset2 + i] = value / mul & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset2, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    this[offset2 + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset2 + i] = value / mul & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 1, 255, 0);
    this[offset2] = value & 255;
    return offset2 + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 2, 65535, 0);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    return offset2 + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 2, 65535, 0);
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
    return offset2 + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 4, 4294967295, 0);
    this[offset2 + 3] = value >>> 24;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 1] = value >>> 8;
    this[offset2] = value & 255;
    return offset2 + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 4, 4294967295, 0);
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
    return offset2 + 4;
  };
  function wrtBigUInt64LE(buf, value, offset2, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset2, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset2++] = hi;
    hi = hi >> 8;
    buf[offset2++] = hi;
    hi = hi >> 8;
    buf[offset2++] = hi;
    hi = hi >> 8;
    buf[offset2++] = hi;
    return offset2;
  }
  function wrtBigUInt64BE(buf, value, offset2, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset2, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset2 + 7] = lo;
    lo = lo >> 8;
    buf[offset2 + 6] = lo;
    lo = lo >> 8;
    buf[offset2 + 5] = lo;
    lo = lo >> 8;
    buf[offset2 + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset2 + 3] = hi;
    hi = hi >> 8;
    buf[offset2 + 2] = hi;
    hi = hi >> 8;
    buf[offset2 + 1] = hi;
    hi = hi >> 8;
    buf[offset2] = hi;
    return offset2 + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset2 = 0) {
    return wrtBigUInt64LE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset2 = 0) {
    return wrtBigUInt64BE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset2, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset2] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset2 + i - 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i] = (value / mul >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset2, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset2 + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset2 + i + 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i] = (value / mul >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset2] = value & 255;
    return offset2 + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 2, 32767, -32768);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    return offset2 + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 2, 32767, -32768);
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
    return offset2 + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 4, 2147483647, -2147483648);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 3] = value >>> 24;
    return offset2 + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
    return offset2 + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset2 = 0) {
    return wrtBigUInt64LE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset2 = 0) {
    return wrtBigUInt64BE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset2, ext, max2, min2) {
    if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
    if (offset2 < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset2, littleEndian, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset2, 4);
    }
    ieee754$1.write(buf, value, offset2, littleEndian, 23, 4);
    return offset2 + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {
    return writeFloat(this, value, offset2, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {
    return writeFloat(this, value, offset2, false, noAssert);
  };
  function writeDouble(buf, value, offset2, littleEndian, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset2, 8);
    }
    ieee754$1.write(buf, value, offset2, littleEndian, 52, 8);
    return offset2 + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {
    return writeDouble(this, value, offset2, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {
    return writeDouble(this, value, offset2, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target2, targetStart, start, end) {
    if (!Buffer2.isBuffer(target2)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target2.length) targetStart = target2.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target2.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target2.length - targetStart < end - start) {
      end = target2.length - targetStart + start;
    }
    const len = end - start;
    if (this === target2 && typeof GlobalUint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      GlobalUint8Array.prototype.set.call(
        target2,
        this.subarray(start, end),
        targetStart
      );
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };
  const errors = {};
  function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function checkBounds(buf, offset2, byteLength3) {
    validateNumber(offset2, "offset");
    if (buf[offset2] === void 0 || buf[offset2 + byteLength3] === void 0) {
      boundsError(offset2, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min2, max2, buf, offset2, byteLength3) {
    if (value > max2 || value < min2) {
      const n2 = typeof min2 === "bigint" ? "n" : "";
      let range;
      {
        if (min2 === 0 || min2 === BigInt(0)) {
          range = `>= 0${n2} and < 2${n2} ** ${(byteLength3 + 1) * 8}${n2}`;
        } else {
          range = `>= -(2${n2} ** ${(byteLength3 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n2}`;
        }
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset2, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      "offset",
      `>= ${0} and <= ${length}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset2, length) {
    let i;
    for (i = 0; i < length; ++i) {
      if (i + offset2 >= dst.length || i >= src.length) break;
      dst[i + offset2] = src[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
const Buffer = buffer.Buffer;
function AxiosError$1(message, code2, config2, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config2 && (this.config = config2);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils$1.inherits(AxiosError$1, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype$1 = AxiosError$1.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code2) => {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError$1, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError$1.from = (error, code2, config2, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError$1.call(axiosError, error.message, code2, config2, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}
function removeBrackets(key) {
  return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token2, i) {
    token2 = removeBrackets(token2);
    return !dots && i ? "[" + token2 + "]" : token2;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData$1(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$1.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils$1.isDate(value)) {
      return value.toISOString();
    }
    if (utils$1.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils$1.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index2) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils$1.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils$1.forEach(value, function each(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$1.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer2(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData$1(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  if (utils$1.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$2 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const _navigator = typeof navigator === "object" && navigator || void 0;
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform$1 = {
  ...utils,
  ...platform$2
};
function toURLEncodedForm(data, options) {
  return toFormData$1(data, new platform$1.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform$1.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target2, index2) {
    let name = path[index2++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path.length;
    name = !name && utils$1.isArray(target2) ? target2.length : name;
    if (isLast) {
      if (utils$1.hasOwnProp(target2, name)) {
        target2[name] = [target2[name], value];
      } else {
        target2[name] = value;
      }
      return !isNumericKey;
    }
    if (!target2[name] || !utils$1.isObject(target2[name])) {
      target2[name] = [];
    }
    const result = buildPath(path, value, target2[name], index2);
    if (result && utils$1.isArray(target2[name])) {
      target2[name] = arrayToObject(target2[name]);
    }
    return !isNumericKey;
  }
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$1.isObject(data);
    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$1.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData$1(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform$1.classes.FormData,
    Blob: platform$1.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils$1.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$1.isString(value)) return;
  if (utils$1.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils$1.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
let AxiosHeaders$1 = class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$1.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils$1.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$1.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils$1.forEach(this, (value, header) => {
      const key = utils$1.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed2 = new this(first);
    targets.forEach((target2) => computed2.set(target2));
    return computed2;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders$1);
function transformData(fns, response) {
  const config2 = this || defaults;
  const context = response || config2;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils$1.forEach(fns, function transform(fn) {
    data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel$1(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError$1(message, config2, request) {
  AxiosError$1.call(this, message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config2, request);
  this.name = "CanceledError";
}
utils$1.inherits(CanceledError$1, AxiosError$1, {
  __CANCEL__: true
});
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError$1(
      "Request failed with status code " + response.status,
      [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer2;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer2) {
      clearTimeout(timer2);
      timer2 = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer2) {
        timer2 = setTimeout(() => {
          timer2 = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
const isURLSameOrigin = platform$1.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform$1.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform$1.origin),
  platform$1.navigator && /(msie|trident)/i.test(platform$1.navigator.userAgent)
) : () => true;
const cookies = platform$1.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$1.isString(path) && cookie.push("path=" + path);
      utils$1.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
function mergeConfig$1(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target2, source, prop, caseless) {
    if (utils$1.isPlainObject(target2) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({ caseless }, target2, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a, prop, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
  };
  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}
const resolveConfig = (config2) => {
  const newConfig = mergeConfig$1({}, config2);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders$1.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config2.params, config2.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils$1.isFormData(data)) {
    if (platform$1.hasStandardBrowserEnv || platform$1.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token2) => token2.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform$1.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config2);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config2,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config2, request));
      request = null;
    };
    request.onerror = function handleError2() {
      reject(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config2, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError$1(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
        config2,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError$1(null, config2, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform$1.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config2));
      return;
    }
    request.send(requestData || null);
  });
};
const composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
      }
    };
    let timer2 = timeout && setTimeout(() => {
      timer2 = null;
      onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer2 && clearTimeout(timer2);
        timer2 = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils$1.asap(unsubscribe);
    return signal;
  }
};
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
    }
  }, {
    highWaterMark: 2
  });
};
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform$1.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_2, config2) => {
      throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config2);
    });
  });
})(new Response());
const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils$1.isBlob(body)) {
    return body.size;
  }
  if (utils$1.isSpecCompliantForm(body)) {
    const _request = new Request(platform$1.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils$1.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils$1.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
const resolveBodyLength = async (headers, body) => {
  const length = utils$1.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
const fetchAdapter = isFetchSupported && (async (config2) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config2);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request, fetchOptions);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config2);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders$1.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config: config2,
        request
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config2, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError$1.from(err, err && err.code, config2, request);
  }
});
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$1.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError$1(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError$1(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError$1(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders$1.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config2.adapter || defaults.adapter);
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel$1(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const VERSION$1 = "1.10.0";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError$1(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError$1.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
validators$1.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
let Axios$1 = class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config2) {
    try {
      return await this._request(configOrUrl, config2);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig$1(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    if (config2.allowAbsoluteUrls !== void 0) ;
    else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config2.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config2.allowAbsoluteUrls = true;
    }
    validator.assertOptions(config2, {
      baseUrl: validators.spelling("baseURL"),
      withXsrfToken: validators.spelling("withXSRFToken")
    }, true);
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config2.method]
    );
    headers && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig$1(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
};
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios$1.prototype[method] = function(url, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config2) {
      return this.request(mergeConfig$1(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios$1.prototype[method] = generateHTTPMethod();
  Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
});
let CancelToken$1 = class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token2 = this;
    this.promise.then((cancel) => {
      if (!token2._listeners) return;
      let i = token2._listeners.length;
      while (i-- > 0) {
        token2._listeners[i](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token2.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token2.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config2, request) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError$1(message, config2, request);
      resolvePromise(token2.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token2 = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token: token2,
      cancel
    };
  }
};
function spread$1(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError$1(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode$1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
  HttpStatusCode$1[value] = key;
});
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind$1(Axios$1.prototype.request, context);
  utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils$1.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create2(instanceConfig) {
    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError$1;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData$1;
axios.AxiosError = AxiosError$1;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread$1;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const {
  Axios: Axios2,
  AxiosError,
  CanceledError,
  isCancel,
  CancelToken: CancelToken2,
  VERSION,
  all: all2,
  Cancel,
  isAxiosError,
  spread,
  toFormData,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode,
  formToJSON,
  getAdapter,
  mergeConfig
} = axios;
let token;
const observers = [];
function getRequestToken() {
  if (token === void 0) {
    token = document.head.dataset.requesttoken ?? null;
  }
  return token;
}
function onRequestTokenUpdate(observer) {
  observers.push(observer);
}
subscribe("csrf-token-update", (e) => {
  token = e.token;
  observers.forEach((observer) => {
    try {
      observer(token);
    } catch (e2) {
      console.error("Error updating CSRF token observer", e2);
    }
  });
});
distExports.getBuilder("public").persist().build();
const RETRY_KEY = Symbol("csrf-retry");
const onError$2 = (axios2) => async (error) => {
  var _a2;
  const { config: config2, response, request } = error;
  const responseURL = request == null ? void 0 : request.responseURL;
  const status = response == null ? void 0 : response.status;
  if (status === 412 && ((_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.message) === "CSRF check failed" && config2[RETRY_KEY] === void 0) {
    console.warn("Request to ".concat(responseURL, " failed because of a CSRF mismatch. Fetching a new token"));
    const { data: { token: token2 } } = await axios2.get(_("/csrftoken"));
    console.debug("New request token ".concat(token2, " fetched"));
    axios2.defaults.headers.requesttoken = token2;
    return axios2({
      ...config2,
      headers: {
        ...config2.headers,
        requesttoken: token2
      },
      [RETRY_KEY]: true
    });
  }
  return Promise.reject(error);
};
const RETRY_DELAY_KEY = Symbol("retryDelay");
const onError$1 = (axios2) => async (error) => {
  var _a2;
  const { config: config2, response, request } = error;
  const responseURL = request == null ? void 0 : request.responseURL;
  const status = response == null ? void 0 : response.status;
  const headers = response == null ? void 0 : response.headers;
  if (status === 503 && headers["x-nextcloud-maintenance-mode"] === "1" && config2.retryIfMaintenanceMode && (!config2[RETRY_DELAY_KEY] || config2[RETRY_DELAY_KEY] <= 32)) {
    const retryDelay = ((_a2 = config2[RETRY_DELAY_KEY]) != null ? _a2 : 1) * 2;
    console.warn("Request to ".concat(responseURL, " failed because of maintenance mode. Retrying in ").concat(retryDelay, "s"));
    await new Promise((resolve) => {
      setTimeout(resolve, retryDelay * 1e3);
    });
    return axios2({
      ...config2,
      [RETRY_DELAY_KEY]: retryDelay
    });
  }
  return Promise.reject(error);
};
const onError = async (error) => {
  var _a2;
  const { config: config2, response, request } = error;
  const responseURL = request == null ? void 0 : request.responseURL;
  const status = response == null ? void 0 : response.status;
  if (status === 401 && ((_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.message) === "Current user is not logged in" && config2.reloadExpiredSession && (window == null ? void 0 : window.location)) {
    console.error("Request to ".concat(responseURL, " failed because the user session expired. Reloading the page …"));
    window.location.reload();
  }
  return Promise.reject(error);
};
var _a;
const client = axios.create({
  headers: {
    requesttoken: (_a = getRequestToken()) != null ? _a : "",
    "X-Requested-With": "XMLHttpRequest"
  }
});
const cancelableClient = Object.assign(client, {
  CancelToken: axios.CancelToken,
  isCancel: axios.isCancel
});
cancelableClient.interceptors.response.use((r) => r, onError$2(cancelableClient));
cancelableClient.interceptors.response.use((r) => r, onError$1(cancelableClient));
cancelableClient.interceptors.response.use((r) => r, onError);
onRequestTokenUpdate((token2) => {
  client.defaults.headers.requesttoken = token2;
});
const _sfc_main$W = {
  name: "CogIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$W = function render6() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon cog-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$W = [];
var __component__$X = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$W,
  _sfc_render$W,
  _sfc_staticRenderFns$W,
  false,
  null,
  null
);
const CogIcon = __component__$X.exports;
const _sfc_main$V = {
  name: "CloseIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$V = function render7() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon close-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$V = [];
var __component__$W = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$V,
  _sfc_render$V,
  _sfc_staticRenderFns$V,
  false,
  null,
  null
);
const CloseIcon = __component__$W.exports;
const _sfc_main$U = {
  name: "CalendarWidget",
  props: {
    widget: {
      type: Object,
      required: true
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    return {
      events: [],
      loading: true
    };
  },
  computed: {
    maxEvents() {
      return this.settings.maxEvents || 5;
    },
    displayMode() {
      if (this.settings.displayMode) {
        return this.settings.displayMode;
      }
      const widgetWidth = this.widget.w || 4;
      const widgetHeight = this.widget.h || 4;
      if (widgetWidth >= 8 && widgetHeight >= 6) {
        return "calendar";
      } else if (widgetWidth >= 6 || widgetHeight >= 5) {
        return "detailed";
      } else if (widgetWidth >= 4 && widgetHeight >= 3) {
        return "list";
      } else {
        return "compact";
      }
    },
    currentMonthName() {
      return (/* @__PURE__ */ new Date()).toLocaleDateString([], { month: "long", year: "numeric" });
    },
    weekDays() {
      const days = [];
      const startOfWeek = /* @__PURE__ */ new Date();
      startOfWeek.setDate(startOfWeek.getDate() - startOfWeek.getDay() + 1);
      for (let i = 0; i < 7; i++) {
        const day = new Date(startOfWeek);
        day.setDate(startOfWeek.getDate() + i);
        days.push(day.toLocaleDateString([], { weekday: "short" }));
      }
      return days;
    },
    calendarDays() {
      const today = /* @__PURE__ */ new Date();
      const currentMonth = today.getMonth();
      const currentYear = today.getFullYear();
      const firstDay = new Date(currentYear, currentMonth, 1);
      const startDate = new Date(firstDay);
      const startDayOfWeek = firstDay.getDay();
      const daysToSubtract = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;
      startDate.setDate(firstDay.getDate() - daysToSubtract);
      const days = [];
      const currentDate = new Date(startDate);
      for (let i = 0; i < 42; i++) {
        const isCurrentMonth = currentDate.getMonth() === currentMonth;
        const isToday = currentDate.toDateString() === today.toDateString();
        const dayEvents = this.events.filter((event) => {
          const eventDate = new Date(event.start);
          return eventDate.toDateString() === currentDate.toDateString();
        });
        days.push({
          date: currentDate.toISOString(),
          dayNumber: currentDate.getDate(),
          isCurrentMonth,
          isToday,
          events: dayEvents
        });
        currentDate.setDate(currentDate.getDate() + 1);
      }
      return days;
    }
  },
  async mounted() {
    await this.loadEvents();
  },
  watch: {
    // Watch for widget dimension changes to trigger display mode recalculation
    "widget.w"() {
      this.$forceUpdate();
    },
    "widget.h"() {
      this.$forceUpdate();
    }
  },
  methods: {
    t: translate,
    async loadEvents() {
      try {
        const response = await cancelableClient.get(_("/apps/dashy/api/calendar/events"));
        this.events = response.data.events.map((event) => ({
          ...event,
          start: new Date(event.start)
        }));
      } catch (error) {
        console.error("Failed to load calendar events:", error);
        this.events = [];
      } finally {
        this.loading = false;
      }
    },
    formatEventTime(date) {
      const now = /* @__PURE__ */ new Date();
      const diffHours = Math.floor((date - now) / (1e3 * 60 * 60));
      const diffDays = Math.floor(diffHours / 24);
      if (diffDays === 0) {
        return date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
      } else if (diffDays === 1) {
        return translate("dashy", "Tomorrow");
      } else if (diffDays < 7) {
        return date.toLocaleDateString([], { weekday: "long" });
      } else {
        return date.toLocaleDateString([], { month: "short", day: "numeric" });
      }
    },
    formatCompactTime(date) {
      const now = /* @__PURE__ */ new Date();
      const diffDays = Math.floor((date - now) / (1e3 * 60 * 60 * 24));
      if (diffDays === 0) {
        return date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
      } else if (diffDays === 1) {
        return "Tom";
      } else if (diffDays < 7) {
        return date.toLocaleDateString([], { weekday: "short" });
      } else {
        return date.toLocaleDateString([], { month: "numeric", day: "numeric" });
      }
    },
    formatDetailedDate(date) {
      const now = /* @__PURE__ */ new Date();
      const diffDays = Math.floor((date - now) / (1e3 * 60 * 60 * 24));
      if (diffDays === 0) {
        return translate("dashy", "Today");
      } else if (diffDays === 1) {
        return translate("dashy", "Tomorrow");
      } else if (diffDays < 7) {
        return date.toLocaleDateString([], { weekday: "long" });
      } else {
        return date.toLocaleDateString([], { weekday: "long", month: "short", day: "numeric" });
      }
    },
    formatDetailedTime(date) {
      return date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    },
    truncateDescription(description) {
      if (!description) return "";
      return description.length > 100 ? description.substring(0, 100) + "..." : description;
    }
  }
};
var _sfc_render$U = function render8() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "calendar-widget", class: [`view-${_vm.displayMode}`] }, [_vm.loading ? _c("div", { staticClass: "loading" }, [_vm._v(" " + _vm._s(_vm.t("dashy", "Loading calendar events...")) + " ")]) : _vm.events.length === 0 ? _c("div", { staticClass: "no-events" }, [_vm._v(" " + _vm._s(_vm.t("dashy", "No upcoming events")) + " ")]) : _vm.displayMode === "compact" ? _c("div", { staticClass: "events-compact" }, _vm._l(_vm.events.slice(0, _vm.maxEvents), function(event) {
    return _c("div", { key: event.id, staticClass: "event-compact" }, [_c("div", { staticClass: "event-time-compact" }, [_vm._v(" " + _vm._s(_vm.formatCompactTime(event.start)) + " ")]), _c("div", { staticClass: "event-title-compact", attrs: { "title": event.title } }, [_vm._v(" " + _vm._s(event.title) + " ")])]);
  }), 0) : _vm.displayMode === "list" ? _c("div", { staticClass: "events-list" }, _vm._l(_vm.events.slice(0, _vm.maxEvents), function(event) {
    return _c("div", { key: event.id, staticClass: "event-item" }, [_c("div", { staticClass: "event-time" }, [_vm._v(" " + _vm._s(_vm.formatEventTime(event.start)) + " ")]), _c("div", { staticClass: "event-details" }, [_c("div", { staticClass: "event-title" }, [_vm._v(_vm._s(event.title))]), event.location ? _c("div", { staticClass: "event-location" }, [_vm._v(" " + _vm._s(event.location) + " ")]) : _vm._e()])]);
  }), 0) : _vm.displayMode === "detailed" ? _c("div", { staticClass: "events-detailed" }, _vm._l(_vm.events.slice(0, _vm.maxEvents), function(event) {
    return _c("div", { key: event.id, staticClass: "event-detailed" }, [_c("div", { staticClass: "event-header" }, [_c("div", { staticClass: "event-date" }, [_vm._v(" " + _vm._s(_vm.formatDetailedDate(event.start)) + " ")]), _c("div", { staticClass: "event-time-detailed" }, [_vm._v(" " + _vm._s(_vm.formatDetailedTime(event.start)) + " ")])]), _c("div", { staticClass: "event-content" }, [_c("div", { staticClass: "event-title-detailed" }, [_vm._v(_vm._s(event.title))]), event.location ? _c("div", { staticClass: "event-location-detailed" }, [_c("span", { staticClass: "location-icon" }, [_vm._v("📍")]), _vm._v(" " + _vm._s(event.location) + " ")]) : _vm._e(), event.description ? _c("div", { staticClass: "event-description" }, [_vm._v(" " + _vm._s(_vm.truncateDescription(event.description)) + " ")]) : _vm._e()])]);
  }), 0) : _vm.displayMode === "calendar" ? _c("div", { staticClass: "events-calendar" }, [_c("div", { staticClass: "calendar-header" }, [_c("h3", [_vm._v(_vm._s(_vm.currentMonthName))])]), _c("div", { staticClass: "calendar-grid" }, [_c("div", { staticClass: "weekday-header" }, _vm._l(_vm.weekDays, function(day) {
    return _c("div", { key: day, staticClass: "weekday" }, [_vm._v(" " + _vm._s(day) + " ")]);
  }), 0), _c("div", { staticClass: "calendar-days" }, _vm._l(_vm.calendarDays, function(day) {
    return _c("div", { key: day.date, staticClass: "calendar-day", class: {
      "other-month": !day.isCurrentMonth,
      "today": day.isToday,
      "has-events": day.events.length > 0
    } }, [_c("div", { staticClass: "day-number" }, [_vm._v(_vm._s(day.dayNumber))]), day.events.length > 0 ? _c("div", { staticClass: "day-events" }, [_vm._l(day.events.slice(0, 3), function(event) {
      return _c("div", { key: event.id, staticClass: "day-event", attrs: { "title": event.title } }, [_vm._v(" " + _vm._s(event.title) + " ")]);
    }), day.events.length > 3 ? _c("div", { staticClass: "more-events" }, [_vm._v(" +" + _vm._s(day.events.length - 3) + " ")]) : _vm._e()], 2) : _vm._e()]);
  }), 0)])]) : _vm._e()]);
};
var _sfc_staticRenderFns$U = [];
var __component__$V = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$U,
  _sfc_render$U,
  _sfc_staticRenderFns$U,
  false,
  null,
  "62175b7e"
);
const CalendarWidget = __component__$V.exports;
const _sfc_main$T = {
  name: "CheckboxMarkedCircleIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$T = function render9() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon checkbox-marked-circle-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M10,17L5,12L6.41,10.58L10,14.17L17.59,6.58L19,8M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$T = [];
var __component__$U = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$T,
  _sfc_render$T,
  _sfc_staticRenderFns$T,
  false,
  null,
  null
);
const CheckboxMarkedCircleIcon = __component__$U.exports;
const _sfc_main$S = {
  name: "CheckboxBlankCircleOutlineIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$S = function render10() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon checkbox-blank-circle-outline-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$S = [];
var __component__$T = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$S,
  _sfc_render$S,
  _sfc_staticRenderFns$S,
  false,
  null,
  null
);
const CheckboxBlankCircleOutlineIcon = __component__$T.exports;
const _sfc_main$R = {
  name: "TodoWidget",
  components: {
    NcButton,
    PencilIcon,
    CheckboxMarkedCircleIcon,
    CheckboxBlankCircleOutlineIcon
  },
  props: {
    widget: {
      type: Object,
      required: true
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    return {
      tasks: [],
      loading: true,
      saving: false,
      refreshInterval: null,
      currentFilter: "active",
      showTaskEditor: false,
      editingTask: null,
      modalElement: null,
      taskForm: {
        summary: "",
        description: "",
        due: "",
        priority: 0
      }
    };
  },
  computed: {
    maxTasks() {
      return this.settings.maxTasks || 10;
    },
    displayMode() {
      if (this.settings.displayMode) {
        return this.settings.displayMode;
      }
      const widgetWidth = this.widget.w || 4;
      const widgetHeight = this.widget.h || 4;
      if (widgetWidth >= 6 || widgetHeight >= 5) {
        return "detailed";
      } else if (widgetWidth >= 4 && widgetHeight >= 3) {
        return "list";
      } else {
        return "compact";
      }
    },
    filteredTasks() {
      let filtered = this.tasks;
      if (this.currentFilter === "active") {
        filtered = filtered.filter((task) => !task.completed);
      } else if (this.currentFilter === "completed") {
        filtered = filtered.filter((task) => task.completed);
      }
      return filtered.sort((a, b) => {
        if (a.completed !== b.completed) {
          return a.completed ? 1 : -1;
        }
        if (a.priority !== b.priority) {
          return (b.priority || 0) - (a.priority || 0);
        }
        if (a.due && b.due) {
          return new Date(a.due) - new Date(b.due);
        }
        if (a.due) return -1;
        if (b.due) return 1;
        return 0;
      });
    },
    todoTasks() {
      return this.tasks.filter((task) => !task.completed);
    },
    completedTasks() {
      return this.tasks.filter((task) => task.completed);
    }
  },
  async mounted() {
    await this.loadTasks();
    this.setupRefreshInterval();
  },
  beforeDestroy() {
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
    }
    document.removeEventListener("keydown", this.handleEscapeKey);
    this.removeModal();
  },
  watch: {
    // Watch for widget dimension changes to trigger display mode recalculation
    "widget.w"() {
      this.$forceUpdate();
    },
    "widget.h"() {
      this.$forceUpdate();
    },
    // Watch for settings changes
    "settings.refreshInterval"() {
      this.setupRefreshInterval();
    }
  },
  methods: {
    t: translate,
    async loadTasks() {
      try {
        console.log("Loading tasks from:", _("/apps/dashy/api/tasks"));
        const response = await cancelableClient.get(_("/apps/dashy/api/tasks"));
        console.log("Tasks response:", response.data);
        this.tasks = response.data.tasks.map((task) => ({
          ...task,
          due: task.due ? new Date(task.due) : null,
          completedAt: task.completedAt ? new Date(task.completedAt) : null
        }));
      } catch (error) {
        console.error("Failed to load tasks:", error);
        this.tasks = [];
      } finally {
        this.loading = false;
      }
    },
    async toggleTask(taskId) {
      const task = this.tasks.find((t2) => t2.id === taskId);
      if (!task) return;
      const newCompleted = !task.completed;
      try {
        await cancelableClient.put(_("/apps/dashy/api/tasks/" + taskId), {
          completed: newCompleted
        });
        task.completed = newCompleted;
        if (newCompleted) {
          task.completedAt = /* @__PURE__ */ new Date();
        } else {
          task.completedAt = null;
        }
      } catch (error) {
        console.error("Failed to update task:", error);
        task.completed = !newCompleted;
      }
    },
    formatTaskDue(date) {
      const now = /* @__PURE__ */ new Date();
      const diffHours = Math.floor((date - now) / (1e3 * 60 * 60));
      const diffDays = Math.floor(diffHours / 24);
      if (diffDays < 0) {
        return translate("dashy", "Overdue");
      } else if (diffDays === 0) {
        return translate("dashy", "Today");
      } else if (diffDays === 1) {
        return translate("dashy", "Tomorrow");
      } else if (diffDays < 7) {
        return date.toLocaleDateString([], { weekday: "long" });
      } else {
        return date.toLocaleDateString([], { month: "short", day: "numeric" });
      }
    },
    formatCompactDue(date) {
      const now = /* @__PURE__ */ new Date();
      const diffDays = Math.floor((date - now) / (1e3 * 60 * 60 * 24));
      if (diffDays < 0) {
        return "⚠️";
      } else if (diffDays === 0) {
        return "Today";
      } else if (diffDays === 1) {
        return "Tom";
      } else if (diffDays < 7) {
        return date.toLocaleDateString([], { weekday: "short" });
      } else {
        return date.toLocaleDateString([], { month: "numeric", day: "numeric" });
      }
    },
    formatDetailedDue(date) {
      const now = /* @__PURE__ */ new Date();
      const diffDays = Math.floor((date - now) / (1e3 * 60 * 60 * 24));
      if (diffDays < 0) {
        return translate("dashy", "Overdue");
      } else if (diffDays === 0) {
        return translate("dashy", "Due today");
      } else if (diffDays === 1) {
        return translate("dashy", "Due tomorrow");
      } else if (diffDays < 7) {
        return translate("dashy", "Due {day}", { day: date.toLocaleDateString([], { weekday: "long" }) });
      } else {
        return translate("dashy", "Due {date}", { date: date.toLocaleDateString([], { weekday: "long", month: "short", day: "numeric" }) });
      }
    },
    getPriorityIcon(priority) {
      if (priority >= 7) return "🔴";
      if (priority >= 4) return "🟡";
      return "🔵";
    },
    getPriorityText(priority) {
      if (priority >= 7) return translate("dashy", "High");
      if (priority >= 4) return translate("dashy", "Medium");
      return translate("dashy", "Low");
    },
    truncateDescription(description) {
      if (!description) return "";
      return description.length > 100 ? description.substring(0, 100) + "..." : description;
    },
    setupRefreshInterval() {
      if (this.refreshInterval) {
        clearInterval(this.refreshInterval);
      }
      const intervalMinutes = this.settings.refreshInterval || 5;
      this.refreshInterval = setInterval(this.loadTasks, intervalMinutes * 60 * 1e3);
    },
    toggleCompactFilter() {
      this.currentFilter = this.currentFilter === "active" ? "completed" : "active";
    },
    isOverdue(date) {
      if (!date) return false;
      return new Date(date) < /* @__PURE__ */ new Date();
    },
    editTask(task) {
      this.editingTask = task;
      this.taskForm = {
        summary: task.summary || "",
        description: task.description || "",
        due: task.due ? this.formatDateForInput(task.due) : "",
        priority: task.priority || 0
      };
      this.showTaskEditor = true;
      this.createModal();
    },
    addNewTask() {
      this.editingTask = null;
      this.resetTaskForm();
      this.showTaskEditor = true;
      this.createModal();
    },
    closeTaskEditor() {
      this.showTaskEditor = false;
      this.editingTask = null;
      this.resetTaskForm();
      this.removeModal();
    },
    resetTaskForm() {
      this.taskForm = {
        summary: "",
        description: "",
        due: "",
        priority: 0
      };
    },
    formatDateForInput(date) {
      if (!date) return "";
      const d = new Date(date);
      const year = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      const hours = String(d.getHours()).padStart(2, "0");
      const minutes = String(d.getMinutes()).padStart(2, "0");
      return `${year}-${month}-${day}T${hours}:${minutes}`;
    },
    async saveTask() {
      if (!this.taskForm.summary.trim()) return;
      this.saving = true;
      try {
        const taskData = {
          summary: this.taskForm.summary.trim(),
          description: this.taskForm.description.trim(),
          due: this.taskForm.due ? new Date(this.taskForm.due).toISOString() : null,
          priority: parseInt(this.taskForm.priority) || 0
        };
        if (this.editingTask) {
          await cancelableClient.put(_("/apps/dashy/api/tasks/" + this.editingTask.id), taskData);
          Object.assign(this.editingTask, {
            ...taskData,
            due: taskData.due ? new Date(taskData.due) : null
          });
        } else {
          const response = await cancelableClient.post(_("/apps/dashy/api/tasks"), taskData);
          this.tasks.push({
            ...response.data.task,
            due: response.data.task.due ? new Date(response.data.task.due) : null
          });
        }
        this.closeTaskEditor();
      } catch (error) {
        console.error("Failed to save task:", error);
      } finally {
        this.saving = false;
      }
    },
    async deleteTask() {
      if (!this.editingTask) return;
      this.saving = true;
      try {
        await cancelableClient.delete(_("/apps/dashy/api/tasks/" + this.editingTask.id));
        const index2 = this.tasks.findIndex((t2) => t2.id === this.editingTask.id);
        if (index2 !== -1) {
          this.tasks.splice(index2, 1);
        }
        this.closeTaskEditor();
      } catch (error) {
        console.error("Failed to delete task:", error);
      } finally {
        this.saving = false;
      }
    },
    handleEscapeKey(event) {
      if (event.key === "Escape" && this.showTaskEditor) {
        this.closeTaskEditor();
      }
    },
    // Modal management methods
    createModal() {
      if (this.modalElement) return;
      document.addEventListener("keydown", this.handleEscapeKey);
      this.modalElement = document.createElement("div");
      this.modalElement.className = "task-editor-overlay";
      this.modalElement.addEventListener("click", this.handleOverlayClick);
      const modalContent = document.createElement("div");
      modalContent.className = "task-editor-modal";
      modalContent.addEventListener("click", (e) => e.stopPropagation());
      modalContent.innerHTML = this.getModalHTML();
      this.modalElement.appendChild(modalContent);
      document.body.appendChild(this.modalElement);
      this.bindModalEvents();
      setTimeout(() => {
        const titleInput = this.modalElement.querySelector("#task-title");
        if (titleInput) {
          titleInput.focus();
          titleInput.select();
        }
      }, 100);
    },
    removeModal() {
      if (this.modalElement) {
        document.removeEventListener("keydown", this.handleEscapeKey);
        this.modalElement.removeEventListener("click", this.handleOverlayClick);
        document.body.removeChild(this.modalElement);
        this.modalElement = null;
      }
    },
    handleOverlayClick() {
      this.closeTaskEditor();
    },
    updateModal() {
      if (!this.modalElement) return;
      const modalContent = this.modalElement.querySelector(".task-editor-modal");
      if (modalContent) {
        modalContent.innerHTML = this.getModalHTML();
        this.bindModalEvents();
      }
    },
    getModalHTML() {
      const editingTask = this.editingTask;
      const taskForm = this.taskForm;
      const saving = this.saving;
      return `
				<div class="modal-header">
					<h3>${editingTask ? this.t("dashy", "Edit Task") : this.t("dashy", "New Task")}</h3>
					<button class="close-btn" type="button" title="${this.t("dashy", "Close")}">
						<svg viewBox="0 0 24 24" width="18" height="18">
							<path fill="currentColor" d="M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z"/>
						</svg>
					</button>
				</div>
				<form class="task-form">
					<div class="form-group">
						<label for="task-title">${this.t("dashy", "Title")}</label>
						<input
							id="task-title"
							type="text"
							placeholder="${this.t("dashy", "Enter task title...")}"
							required
							value="${this.escapeHtml(taskForm.summary)}"
						>
					</div>
					<div class="form-group">
						<label for="task-description">${this.t("dashy", "Description")}</label>
						<textarea
							id="task-description"
							placeholder="${this.t("dashy", "Add a description...")}"
							rows="3"
						>${this.escapeHtml(taskForm.description)}</textarea>
					</div>
					<div class="form-row">
						<div class="form-group">
							<label for="task-due">${this.t("dashy", "Due Date")}</label>
							<input
								id="task-due"
								type="datetime-local"
								value="${taskForm.due}"
							>
						</div>
						<div class="form-group">
							<label for="task-priority">${this.t("dashy", "Priority")}</label>
							<select id="task-priority">
								<option value="0" ${taskForm.priority == 0 ? "selected" : ""}>${this.t("dashy", "None")}</option>
								<option value="3" ${taskForm.priority == 3 ? "selected" : ""}>${this.t("dashy", "Low")}</option>
								<option value="5" ${taskForm.priority == 5 ? "selected" : ""}>${this.t("dashy", "Medium")}</option>
								<option value="7" ${taskForm.priority == 7 ? "selected" : ""}>${this.t("dashy", "High")}</option>
								<option value="9" ${taskForm.priority == 9 ? "selected" : ""}>${this.t("dashy", "Urgent")}</option>
							</select>
						</div>
					</div>
					<div class="form-actions">
						<button type="button" class="btn-cancel">
							<svg viewBox="0 0 24 24" width="16" height="16">
								<path fill="currentColor" d="M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z"/>
							</svg>
							${this.t("dashy", "Cancel")}
						</button>
						${editingTask ? `
						<button type="button" class="btn-delete" ${saving ? "disabled" : ""}>
							<svg viewBox="0 0 24 24" width="16" height="16">
								<path fill="currentColor" d="M9,3V4H4V6H5V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V6H20V4H15V3H9M7,6H17V19H7V6M9,8V17H11V8H9M13,8V17H15V8H13Z"/>
							</svg>
							${this.t("dashy", "Delete")}
						</button>` : ""}
						<button type="submit" class="btn-save" ${saving || !taskForm.summary.trim() ? "disabled" : ""} id="save-btn">
							<svg viewBox="0 0 24 24" width="16" height="16">
								<path fill="currentColor" d="M15,9H5V5H15M12,19A3,3 0 0,1 9,16A3,3 0 0,1 12,13A3,3 0 0,1 15,16A3,3 0 0,1 12,19M17,3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V7L17,3Z"/>
							</svg>
							${saving ? this.t("dashy", "Saving...") : editingTask ? this.t("dashy", "Update") : this.t("dashy", "Create")}
						</button>
					</div>
				</form>
			`;
    },
    bindModalEvents() {
      if (!this.modalElement) return;
      const form = this.modalElement.querySelector(".task-form");
      if (form) {
        form.addEventListener("submit", (e) => {
          e.preventDefault();
          this.saveTaskFromModal();
        });
      }
      const closeBtn = this.modalElement.querySelector(".close-btn");
      if (closeBtn) {
        closeBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.closeTaskEditor();
        });
      }
      const cancelBtn = this.modalElement.querySelector(".btn-cancel");
      if (cancelBtn) {
        cancelBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.closeTaskEditor();
        });
      }
      const deleteBtn = this.modalElement.querySelector(".btn-delete");
      if (deleteBtn) {
        deleteBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (confirm(this.t("dashy", "Are you sure you want to delete this task?"))) {
            this.deleteTask();
          }
        });
      }
      const titleInput = this.modalElement.querySelector("#task-title");
      const descInput = this.modalElement.querySelector("#task-description");
      const dueInput = this.modalElement.querySelector("#task-due");
      const priorityInput = this.modalElement.querySelector("#task-priority");
      if (titleInput) {
        titleInput.addEventListener("input", (e) => {
          this.taskForm.summary = e.target.value;
          this.updateSaveButton();
        });
      }
      if (descInput) {
        descInput.addEventListener("input", (e) => {
          this.taskForm.description = e.target.value;
        });
      }
      if (dueInput) {
        dueInput.addEventListener("input", (e) => {
          this.taskForm.due = e.target.value;
        });
      }
      if (priorityInput) {
        priorityInput.addEventListener("change", (e) => {
          this.taskForm.priority = parseInt(e.target.value);
        });
      }
    },
    // Helper method to escape HTML in form values
    escapeHtml(text2) {
      if (!text2) return "";
      const div = document.createElement("div");
      div.textContent = text2;
      return div.innerHTML;
    },
    // Update save button state
    updateSaveButton() {
      if (!this.modalElement) return;
      const saveBtn = this.modalElement.querySelector("#save-btn");
      if (saveBtn) {
        const hasTitle = this.taskForm.summary.trim().length > 0;
        saveBtn.disabled = this.saving || !hasTitle;
      }
    },
    async saveTaskFromModal() {
      const titleInput = this.modalElement.querySelector("#task-title");
      const descInput = this.modalElement.querySelector("#task-description");
      const dueInput = this.modalElement.querySelector("#task-due");
      const priorityInput = this.modalElement.querySelector("#task-priority");
      this.taskForm.summary = titleInput.value;
      this.taskForm.description = descInput.value;
      this.taskForm.due = dueInput.value;
      this.taskForm.priority = parseInt(priorityInput.value);
      await this.saveTask();
    }
  }
};
var _sfc_render$R = function render11() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "todo-widget", class: [`view-${_vm.displayMode}`] }, [_vm.displayMode !== "compact" ? _c("div", { staticClass: "widget-header" }, [_c("div", { staticClass: "header-actions" }, [_c("NcButton", { attrs: { "type": "primary", "aria-label": _vm.t("dashy", "Add new task"), "title": _vm.t("dashy", "Add new task") }, on: { "click": _vm.addNewTask }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("svg", { staticClass: "btn-icon", attrs: { "viewBox": "0 0 24 24", "width": "16", "height": "16" } }, [_c("path", { attrs: { "fill": "currentColor", "d": "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" } })])];
  }, proxy: true }], null, false, 2402948988) }, [_vm._v(" " + _vm._s(_vm.t("dashy", "Add Task")) + " ")]), _c("NcButton", { attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Refresh tasks"), "disabled": _vm.loading, "title": _vm.t("dashy", "Refresh tasks") }, on: { "click": _vm.loadTasks }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("svg", { staticClass: "btn-icon", class: { spinning: _vm.loading }, attrs: { "viewBox": "0 0 24 24", "width": "16", "height": "16" } }, [_c("path", { attrs: { "fill": "currentColor", "d": "M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z" } })])];
  }, proxy: true }], null, false, 2165343906) }, [_vm._v(" " + _vm._s(_vm.t("dashy", "Refresh")) + " ")])], 1), _vm.displayMode === "detailed" ? _c("div", { staticClass: "filter-tabs" }, [_c("NcButton", { class: { active: _vm.currentFilter === "all" }, attrs: { "type": "tertiary" }, on: { "click": function($event) {
    _vm.currentFilter = "all";
  } } }, [_vm._v(" " + _vm._s(_vm.t("dashy", "All")) + " (" + _vm._s(_vm.tasks.length) + ") ")]), _c("NcButton", { class: { active: _vm.currentFilter === "active" }, attrs: { "type": "tertiary" }, on: { "click": function($event) {
    _vm.currentFilter = "active";
  } } }, [_vm._v(" " + _vm._s(_vm.t("dashy", "Active")) + " (" + _vm._s(_vm.todoTasks.length) + ") ")]), _c("NcButton", { class: { active: _vm.currentFilter === "completed" }, attrs: { "type": "tertiary" }, on: { "click": function($event) {
    _vm.currentFilter = "completed";
  } } }, [_vm._v(" " + _vm._s(_vm.t("dashy", "Done")) + " (" + _vm._s(_vm.completedTasks.length) + ") ")])], 1) : _vm._e()]) : _vm._e(), _vm.loading ? _c("div", { staticClass: "loading" }, [_vm._v(" " + _vm._s(_vm.t("dashy", "Loading tasks...")) + " ")]) : _vm.filteredTasks.length === 0 ? _c("div", { staticClass: "no-tasks" }, [_c("div", { staticClass: "no-tasks-icon" }, [_vm._v("📝")]), _c("div", { staticClass: "no-tasks-text" }, [_vm._v(_vm._s(_vm.t("dashy", "No tasks found")))]), _vm.displayMode !== "compact" ? _c("button", { staticClass: "custom-primary-btn add-first-task-btn", attrs: { "aria-label": _vm.t("dashy", "Add your first task") }, on: { "click": _vm.addNewTask } }, [_c("svg", { staticClass: "btn-icon", attrs: { "viewBox": "0 0 24 24", "width": "16", "height": "16" } }, [_c("path", { attrs: { "fill": "currentColor", "d": "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" } })]), _c("span", { staticClass: "btn-text" }, [_vm._v(_vm._s(_vm.t("dashy", "Add your first task")))])]) : _vm._e()]) : _vm.displayMode === "compact" ? _c("div", { staticClass: "tasks-compact" }, [_c("div", { staticClass: "compact-header" }, [_c("button", { staticClass: "custom-compact-btn add-task-compact-btn", attrs: { "aria-label": _vm.t("dashy", "Add task"), "title": _vm.t("dashy", "Add new task") }, on: { "click": _vm.addNewTask } }, [_c("svg", { staticClass: "compact-icon", attrs: { "viewBox": "0 0 24 24", "width": "12", "height": "12" } }, [_c("path", { attrs: { "fill": "currentColor", "d": "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" } })])]), _c("div", { staticClass: "compact-filter" }, [_c("NcButton", { staticClass: "compact-btn", class: { active: _vm.currentFilter === "active" }, attrs: { "type": "tertiary", "aria-label": _vm.currentFilter === "active" ? _vm.t("dashy", "Show completed") : _vm.t("dashy", "Show active") }, on: { "click": _vm.toggleCompactFilter }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_vm.currentFilter === "active" ? _c("CheckboxMarkedCircleIcon", { attrs: { "size": 14 } }) : _c("CheckboxBlankCircleOutlineIcon", { attrs: { "size": 14 } })];
  }, proxy: true }]) })], 1)]), _vm._l(_vm.filteredTasks.slice(0, _vm.maxTasks), function(task) {
    return _c("div", { key: task.id, staticClass: "task-compact", class: { completed: task.completed }, on: { "click": function($event) {
      return _vm.editTask(task);
    } } }, [_c("input", { attrs: { "type": "checkbox" }, domProps: { "checked": task.completed }, on: { "change": function($event) {
      return _vm.toggleTask(task.id);
    }, "click": function($event) {
      $event.stopPropagation();
    } } }), _c("div", { staticClass: "task-content-compact" }, [_c("div", { staticClass: "task-title-compact", attrs: { "title": task.summary } }, [_vm._v(" " + _vm._s(task.summary) + " ")]), task.due ? _c("div", { staticClass: "task-due-compact", class: { overdue: _vm.isOverdue(task.due) } }, [_vm._v(" " + _vm._s(_vm.formatCompactDue(task.due)) + " ")]) : _vm._e()]), task.priority && task.priority >= 7 ? _c("div", { staticClass: "task-priority-compact" }, [_vm._v(" " + _vm._s(_vm.getPriorityIcon(task.priority)) + " ")]) : _vm._e()]);
  })], 2) : _vm.displayMode === "list" ? _c("div", { staticClass: "tasks-list" }, _vm._l(_vm.filteredTasks.slice(0, _vm.maxTasks), function(task) {
    return _c("div", { key: task.id, staticClass: "task-item", class: { completed: task.completed, overdue: _vm.isOverdue(task.due) } }, [_c("input", { attrs: { "type": "checkbox" }, domProps: { "checked": task.completed }, on: { "change": function($event) {
      return _vm.toggleTask(task.id);
    } } }), _c("div", { staticClass: "task-content", on: { "click": function($event) {
      return _vm.editTask(task);
    } } }, [_c("div", { staticClass: "task-title" }, [_vm._v(_vm._s(task.summary))]), task.due || task.list ? _c("div", { staticClass: "task-meta" }, [task.due ? _c("span", { staticClass: "task-due" }, [_vm._v(" 📅 " + _vm._s(_vm.formatTaskDue(task.due)) + " ")]) : _vm._e(), task.list ? _c("span", { staticClass: "task-list" }, [_vm._v(" 📋 " + _vm._s(task.list) + " ")]) : _vm._e()]) : _vm._e()]), _c("div", { staticClass: "task-actions" }, [task.priority && task.priority >= 6 ? _c("div", { staticClass: "task-priority" }, [_vm._v(" " + _vm._s(_vm.getPriorityIcon(task.priority)) + " ")]) : _vm._e(), _c("NcButton", { attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Edit task") }, on: { "click": function($event) {
      return _vm.editTask(task);
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("PencilIcon", { attrs: { "size": 16 } })];
    }, proxy: true }], null, true) })], 1)]);
  }), 0) : _vm.displayMode === "detailed" ? _c("div", { staticClass: "tasks-detailed" }, _vm._l(_vm.filteredTasks.slice(0, _vm.maxTasks), function(task) {
    return _c("div", { key: task.id, staticClass: "task-detailed", class: { completed: task.completed } }, [_c("div", { staticClass: "task-header" }, [_c("div", { staticClass: "task-checkbox-wrapper" }, [_c("input", { attrs: { "type": "checkbox" }, domProps: { "checked": task.completed }, on: { "change": function($event) {
      return _vm.toggleTask(task.id);
    } } })]), _c("div", { staticClass: "task-meta" }, [task.due ? _c("div", { staticClass: "task-due-detailed", class: { overdue: _vm.isOverdue(task.due) } }, [_vm._v(" " + _vm._s(_vm.formatDetailedDue(task.due)) + " ")]) : _vm._e(), task.priority ? _c("div", { staticClass: "task-priority-detailed" }, [_vm._v(" " + _vm._s(_vm.getPriorityIcon(task.priority)) + " " + _vm._s(_vm.getPriorityText(task.priority)) + " ")]) : _vm._e()]), _c("NcButton", { staticClass: "task-edit-btn-detailed", attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Edit task") }, on: { "click": function($event) {
      return _vm.editTask(task);
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("PencilIcon", { attrs: { "size": 16 } })];
    }, proxy: true }], null, true) })], 1), _c("div", { staticClass: "task-content", on: { "click": function($event) {
      return _vm.editTask(task);
    } } }, [_c("div", { staticClass: "task-title-detailed" }, [_vm._v(_vm._s(task.summary))]), task.description ? _c("div", { staticClass: "task-description" }, [_vm._v(" " + _vm._s(_vm.truncateDescription(task.description)) + " ")]) : _vm._e(), task.list ? _c("div", { staticClass: "task-list-detailed" }, [_c("span", { staticClass: "list-icon" }, [_vm._v("📋")]), _vm._v(" " + _vm._s(task.list) + " ")]) : _vm._e()])]);
  }), 0) : _vm._e()]);
};
var _sfc_staticRenderFns$R = [];
var __component__$S = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$R,
  _sfc_render$R,
  _sfc_staticRenderFns$R,
  false,
  null,
  "40445a8a"
);
const TodoWidget = __component__$S.exports;
const _sfc_main$Q = {
  name: "ClockWidget",
  props: {
    widget: {
      type: Object,
      required: true
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    return {
      currentTime: "",
      currentDate: "",
      timezone: "",
      timer: null
    };
  },
  mounted() {
    this.updateTime();
    this.timer = setInterval(this.updateTime, 1e3);
  },
  beforeDestroy() {
    if (this.timer) {
      clearInterval(this.timer);
    }
  },
  methods: {
    t: translate,
    updateTime() {
      const now = /* @__PURE__ */ new Date();
      const timeFormat = this.settings.format24h ? "24h" : "12h";
      const timeOptions = {
        hour: "2-digit",
        minute: "2-digit",
        hour12: timeFormat !== "24h"
      };
      if (this.settings.showSeconds) {
        timeOptions.second = "2-digit";
      }
      this.currentTime = now.toLocaleTimeString([], timeOptions);
      const dateOptions = {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric"
      };
      this.currentDate = now.toLocaleDateString([], dateOptions);
      this.timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    }
  }
};
var _sfc_render$Q = function render12() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "clock-widget" }, [_c("div", { staticClass: "time-display" }, [_c("div", { staticClass: "current-time" }, [_vm._v(" " + _vm._s(_vm.currentTime) + " ")]), _c("div", { staticClass: "current-date" }, [_vm._v(" " + _vm._s(_vm.currentDate) + " ")]), _vm.settings.showTimezone ? _c("div", { staticClass: "timezone" }, [_vm._v(" " + _vm._s(_vm.timezone) + " ")]) : _vm._e()])]);
};
var _sfc_staticRenderFns$Q = [];
var __component__$R = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$Q,
  _sfc_render$Q,
  _sfc_staticRenderFns$Q,
  false,
  null,
  "32c68a89"
);
const ClockWidget = __component__$R.exports;
const _sfc_main$P = {
  name: "WeatherSunnyIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$P = function render13() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon weather-sunny-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M12,7A5,5 0 0,1 17,12A5,5 0 0,1 12,17A5,5 0 0,1 7,12A5,5 0 0,1 12,7M12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9M12,2L14.39,5.42C13.65,5.15 12.84,5 12,5C11.16,5 10.35,5.15 9.61,5.42L12,2M3.34,7L7.5,6.65C6.9,7.16 6.36,7.78 5.94,8.5C5.5,9.24 5.25,10 5.11,10.79L3.34,7M3.36,17L5.12,13.23C5.26,14 5.53,14.78 5.95,15.5C6.37,16.24 6.91,16.86 7.5,17.37L3.36,17M20.65,7L18.88,10.79C18.74,10 18.47,9.23 18.05,8.5C17.63,7.78 17.1,7.15 16.5,6.64L20.65,7M20.64,17L16.5,17.36C17.09,16.85 17.62,16.22 18.04,15.5C18.46,14.77 18.73,14 18.87,13.21L20.64,17M12,22L9.59,18.56C10.33,18.83 11.14,19 12,19C12.82,19 13.63,18.83 14.37,18.56L12,22Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$P = [];
var __component__$Q = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$P,
  _sfc_render$P,
  _sfc_staticRenderFns$P,
  false,
  null,
  null
);
const WeatherSunnyIcon = __component__$Q.exports;
const _sfc_main$O = {
  name: "WeatherCloudyIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$O = function render14() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon weather-cloudy-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M6,19A5,5 0 0,1 1,14A5,5 0 0,1 6,9C7,6.65 9.3,5 12,5C15.43,5 18.24,7.66 18.5,11.03L19,11A4,4 0 0,1 23,15A4,4 0 0,1 19,19H6M19,13H17V12A5,5 0 0,0 12,7C9.5,7 7.45,8.82 7.06,11.19C6.73,11.07 6.37,11 6,11A3,3 0 0,0 3,14A3,3 0 0,0 6,17H19A2,2 0 0,0 21,15A2,2 0 0,0 19,13Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$O = [];
var __component__$P = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$O,
  _sfc_render$O,
  _sfc_staticRenderFns$O,
  false,
  null,
  null
);
const WeatherCloudyIcon = __component__$P.exports;
const _sfc_main$N = {
  name: "WeatherPartlyCloudyIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$N = function render15() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon weather-partly-cloudy-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M12.74,5.47C15.1,6.5 16.35,9.03 15.92,11.46C17.19,12.56 18,14.19 18,16V16.17C18.31,16.06 18.65,16 19,16A3,3 0 0,1 22,19A3,3 0 0,1 19,22H6A4,4 0 0,1 2,18A4,4 0 0,1 6,14H6.27C5,12.45 4.6,10.24 5.5,8.26C6.72,5.5 9.97,4.24 12.74,5.47M11.93,7.3C10.16,6.5 8.09,7.31 7.31,9.07C6.85,10.09 6.93,11.22 7.41,12.13C8.5,10.83 10.16,10 12,10C12.7,10 13.38,10.12 14,10.34C13.94,9.06 13.18,7.86 11.93,7.3M13.55,3.64C13,3.4 12.45,3.23 11.88,3.12L14.37,1.82L15.27,4.71C14.76,4.29 14.19,3.93 13.55,3.64M6.09,4.44C5.6,4.79 5.17,5.19 4.8,5.63L4.91,2.82L7.87,3.5C7.25,3.71 6.65,4.03 6.09,4.44M18,9.71C17.91,9.12 17.78,8.55 17.59,8L19.97,9.5L17.92,11.73C18.03,11.08 18.05,10.4 18,9.71M3.04,11.3C3.11,11.9 3.24,12.47 3.43,13L1.06,11.5L3.1,9.28C3,9.93 2.97,10.61 3.04,11.3M19,18H16V16A4,4 0 0,0 12,12A4,4 0 0,0 8,16H6A2,2 0 0,0 4,18A2,2 0 0,0 6,20H19A1,1 0 0,0 20,19A1,1 0 0,0 19,18Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$N = [];
var __component__$O = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$N,
  _sfc_render$N,
  _sfc_staticRenderFns$N,
  false,
  null,
  null
);
const WeatherPartlyCloudyIcon = __component__$O.exports;
const _sfc_main$M = {
  name: "WeatherPouringIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$M = function render16() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon weather-pouring-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M9,12C9.53,12.14 9.85,12.69 9.71,13.22L8.41,18.05C8.27,18.59 7.72,18.9 7.19,18.76C6.65,18.62 6.34,18.07 6.5,17.54L7.78,12.71C7.92,12.17 8.47,11.86 9,12M13,12C13.53,12.14 13.85,12.69 13.71,13.22L11.64,20.95C11.5,21.5 10.95,21.8 10.41,21.66C9.88,21.5 9.56,20.97 9.7,20.43L11.78,12.71C11.92,12.17 12.47,11.86 13,12M17,12C17.53,12.14 17.85,12.69 17.71,13.22L16.41,18.05C16.27,18.59 15.72,18.9 15.19,18.76C14.65,18.62 14.34,18.07 14.5,17.54L15.78,12.71C15.92,12.17 16.47,11.86 17,12M17,10V9A5,5 0 0,0 12,4C9.5,4 7.45,5.82 7.06,8.19C6.73,8.07 6.37,8 6,8A3,3 0 0,0 3,11C3,12.11 3.6,13.08 4.5,13.6V13.59C5,13.87 5.14,14.5 4.87,14.96C4.59,15.43 4,15.6 3.5,15.32V15.33C2,14.47 1,12.85 1,11A5,5 0 0,1 6,6C7,3.65 9.3,2 12,2C15.43,2 18.24,4.66 18.5,8.03L19,8A4,4 0 0,1 23,12C23,13.5 22.2,14.77 21,15.46V15.46C20.5,15.73 19.91,15.57 19.63,15.09C19.36,14.61 19.5,14 20,13.72V13.73C20.6,13.39 21,12.74 21,12A2,2 0 0,0 19,10H17Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$M = [];
var __component__$N = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$M,
  _sfc_render$M,
  _sfc_staticRenderFns$M,
  false,
  null,
  null
);
const WeatherPouring = __component__$N.exports;
const _sfc_main$L = {
  name: "WeatherSnowyIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$L = function render17() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon weather-snowy-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M6,14A1,1 0 0,1 7,15A1,1 0 0,1 6,16A5,5 0 0,1 1,11A5,5 0 0,1 6,6C7,3.65 9.3,2 12,2C15.43,2 18.24,4.66 18.5,8.03L19,8A4,4 0 0,1 23,12A4,4 0 0,1 19,16H18A1,1 0 0,1 17,15A1,1 0 0,1 18,14H19A2,2 0 0,0 21,12A2,2 0 0,0 19,10H17V9A5,5 0 0,0 12,4C9.5,4 7.45,5.82 7.06,8.19C6.73,8.07 6.37,8 6,8A3,3 0 0,0 3,11A3,3 0 0,0 6,14M7.88,18.07L10.07,17.5L8.46,15.88C8.07,15.5 8.07,14.86 8.46,14.46C8.85,14.07 9.5,14.07 9.88,14.46L11.5,16.07L12.07,13.88C12.21,13.34 12.76,13.03 13.29,13.17C13.83,13.31 14.14,13.86 14,14.4L13.41,16.59L15.6,16C16.14,15.86 16.69,16.17 16.83,16.71C16.97,17.24 16.66,17.79 16.12,17.93L13.93,18.5L15.54,20.12C15.93,20.5 15.93,21.15 15.54,21.54C15.15,21.93 14.5,21.93 14.12,21.54L12.5,19.93L11.93,22.12C11.79,22.66 11.24,22.97 10.71,22.83C10.17,22.69 9.86,22.14 10,21.6L10.59,19.41L8.4,20C7.86,20.14 7.31,19.83 7.17,19.29C7.03,18.76 7.34,18.21 7.88,18.07Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$L = [];
var __component__$M = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$L,
  _sfc_render$L,
  _sfc_staticRenderFns$L,
  false,
  null,
  null
);
const WeatherSnowy = __component__$M.exports;
const _sfc_main$K = {
  name: "WeatherWidget",
  props: {
    widget: {
      type: Object,
      required: true
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    return {
      weather: null,
      loading: true,
      error: null,
      refreshInterval: null
    };
  },
  computed: {
    weatherIcon() {
      if (!this.weather) return WeatherSunnyIcon;
      const condition = this.weather.condition.toLowerCase();
      if (condition.includes("rain")) return WeatherPouring;
      if (condition.includes("snow")) return WeatherSnowy;
      if (condition.includes("cloud")) return WeatherCloudyIcon;
      if (condition.includes("partly")) return WeatherPartlyCloudyIcon;
      return WeatherSunnyIcon;
    }
  },
  async mounted() {
    await this.loadWeather();
    this.refreshInterval = setInterval(this.loadWeather, 6e5);
  },
  beforeDestroy() {
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
    }
  },
  methods: {
    t: translate,
    async loadWeather() {
      try {
        this.loading = true;
        this.error = null;
        const params = new URLSearchParams();
        if (this.settings.location) {
          params.append("location", this.settings.location);
        }
        if (this.settings.unit) {
          params.append("unit", this.settings.unit);
        }
        const response = await cancelableClient.get(_("/apps/dashy/api/weather") + "?" + params.toString());
        if (response.data.data.weather) {
          this.weather = response.data.data.weather;
        } else if (response.data.data.error) {
          this.error = response.data.data.error;
        }
      } catch (error) {
        console.error("Failed to load weather:", error);
        this.error = translate("dashy", "Failed to load weather data");
      } finally {
        this.loading = false;
      }
    }
  },
  watch: {
    settings: {
      handler() {
        this.loadWeather();
      },
      deep: true
    }
  }
};
var _sfc_render$K = function render18() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "weather-widget" }, [_vm.loading ? _c("div", { staticClass: "loading" }, [_vm._v(" " + _vm._s(_vm.t("dashy", "Loading weather...")) + " ")]) : _vm.error ? _c("div", { staticClass: "error" }, [_vm._v(" " + _vm._s(_vm.error) + " ")]) : _vm.weather ? _c("div", { staticClass: "weather-content" }, [_c("div", { staticClass: "current-weather" }, [_c("div", { staticClass: "weather-icon" }, [_c(_vm.weatherIcon, { tag: "component", attrs: { "size": 48 } })], 1), _c("div", { staticClass: "weather-info" }, [_c("div", { staticClass: "temperature" }, [_vm._v(" " + _vm._s(Math.round(_vm.weather.temperature)) + "°" + _vm._s(_vm.settings.unit || "C") + " ")]), _c("div", { staticClass: "description" }, [_vm._v(" " + _vm._s(_vm.weather.description) + " ")]), _c("div", { staticClass: "location" }, [_vm._v(" " + _vm._s(_vm.weather.location) + " ")])])]), _vm.settings.showDetails ? _c("div", { staticClass: "weather-details" }, [_c("div", { staticClass: "detail-item" }, [_c("span", { staticClass: "label" }, [_vm._v(_vm._s(_vm.t("dashy", "Feels like")) + ":")]), _c("span", [_vm._v(_vm._s(Math.round(_vm.weather.feelsLike)) + "°" + _vm._s(_vm.settings.unit || "C"))])]), _c("div", { staticClass: "detail-item" }, [_c("span", { staticClass: "label" }, [_vm._v(_vm._s(_vm.t("dashy", "Humidity")) + ":")]), _c("span", [_vm._v(_vm._s(_vm.weather.humidity) + "%")])]), _c("div", { staticClass: "detail-item" }, [_c("span", { staticClass: "label" }, [_vm._v(_vm._s(_vm.t("dashy", "Wind")) + ":")]), _c("span", [_vm._v(_vm._s(_vm.weather.windSpeed) + " km/h")])])]) : _vm._e()]) : _c("div", { staticClass: "no-data" }, [_vm._v(" " + _vm._s(_vm.t("dashy", "No weather data available")) + " ")])]);
};
var _sfc_staticRenderFns$K = [];
var __component__$L = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$K,
  _sfc_render$K,
  _sfc_staticRenderFns$K,
  false,
  null,
  "1728ee86"
);
const WeatherWidget = __component__$L.exports;
const _sfc_main$J = {
  name: "NcLoadingIcon",
  props: {
    /**
     * Specify the size of the loading icon.
     */
    size: {
      type: Number,
      default: 20
    },
    /**
     * The appearance of the loading icon.
     * 'auto' adjusts to the Nextcloud color scheme,
     * 'light' and 'dark' are static.
     */
    appearance: {
      type: String,
      validator(value) {
        return ["auto", "light", "dark"].includes(value);
      },
      default: "auto"
    },
    /**
     * Specify what is loading.
     */
    name: {
      type: String,
      default: ""
    }
  },
  computed: {
    colors() {
      const colors = ["#777", "#CCC"];
      if (this.appearance === "light") {
        return colors;
      } else if (this.appearance === "dark") {
        return colors.reverse();
      }
      return ["var(--color-loading-light)", "var(--color-loading-dark)"];
    }
  }
};
var _sfc_render$J = function render19() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", { staticClass: "material-design-icon loading-icon", attrs: { "aria-label": _vm.name, "role": "img" } }, [_c("svg", { attrs: { "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "fill": _vm.colors[0], "d": "M12,4V2A10,10 0 1,0 22,12H20A8,8 0 1,1 12,4Z" } }), _c("path", { attrs: { "fill": _vm.colors[1], "d": "M12,4V2A10,10 0 0,1 22,12H20A8,8 0 0,0 12,4Z" } }, [_vm.name ? _c("title", [_vm._v(_vm._s(_vm.name))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$J = [];
var __component__$K = /* @__PURE__ */ normalizeComponent$3(
  _sfc_main$J,
  _sfc_render$J,
  _sfc_staticRenderFns$J,
  false,
  null,
  "551209a3"
);
const NcLoadingIcon = __component__$K.exports;
const _sfc_main$I = {
  name: "FolderIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$I = function render20() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon folder-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M10,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V8C22,6.89 21.1,6 20,6H12L10,4Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$I = [];
var __component__$J = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$I,
  _sfc_render$I,
  _sfc_staticRenderFns$I,
  false,
  null,
  null
);
const FolderIcon = __component__$J.exports;
const _sfc_main$H = {
  name: "FileIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$H = function render21() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon file-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M13,9V3.5L18.5,9M6,2C4.89,2 4,2.89 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2H6Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$H = [];
var __component__$I = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$H,
  _sfc_render$H,
  _sfc_staticRenderFns$H,
  false,
  null,
  null
);
const FileIcon = __component__$I.exports;
const _sfc_main$G = {
  name: "FileDocumentIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$G = function render23() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon file-document-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M15,18V16H6V18H15M18,14V12H6V14H18Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$G = [];
var __component__$H = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$G,
  _sfc_render$G,
  _sfc_staticRenderFns$G,
  false,
  null,
  null
);
const FileDocumentIcon = __component__$H.exports;
const _sfc_main$F = {
  name: "FileImageIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$F = function render24() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon file-image-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M6,20H15L18,20V12L14,16L12,14L6,20M8,9A2,2 0 0,0 6,11A2,2 0 0,0 8,13A2,2 0 0,0 10,11A2,2 0 0,0 8,9Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$F = [];
var __component__$G = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$F,
  _sfc_render$F,
  _sfc_staticRenderFns$F,
  false,
  null,
  null
);
const FileImageIcon = __component__$G.exports;
const _sfc_main$E = {
  name: "FileMusicIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$E = function render25() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon file-music-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M13,13H11V18A2,2 0 0,1 9,20A2,2 0 0,1 7,18A2,2 0 0,1 9,16C9.4,16 9.7,16.1 10,16.3V11H13V13M13,9V3.5L18.5,9H13Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$E = [];
var __component__$F = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$E,
  _sfc_render$E,
  _sfc_staticRenderFns$E,
  false,
  null,
  null
);
const FileMusicIcon = __component__$F.exports;
const _sfc_main$D = {
  name: "FileVideoIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$D = function render26() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon file-video-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M17,19V13L14,15.2V13H7V19H14V16.8L17,19Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$D = [];
var __component__$E = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$D,
  _sfc_render$D,
  _sfc_staticRenderFns$D,
  false,
  null,
  null
);
const FileVideoIcon = __component__$E.exports;
const _sfc_main$C = {
  name: "FilePresentationBoxIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$C = function render27() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon file-presentation-box-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M19,16H5V8H19M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$C = [];
var __component__$D = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$C,
  _sfc_render$C,
  _sfc_staticRenderFns$C,
  false,
  null,
  null
);
const FilePresentationIcon = __component__$D.exports;
const _sfc_main$B = {
  name: "GoogleSpreadsheetIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$B = function render28() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon google-spreadsheet-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M19,11V9H11V5H9V9H5V11H9V19H11V11H19M19,3C19.5,3 20,3.2 20.39,3.61C20.8,4 21,4.5 21,5V19C21,19.5 20.8,20 20.39,20.39C20,20.8 19.5,21 19,21H5C4.5,21 4,20.8 3.61,20.39C3.2,20 3,19.5 3,19V5C3,4.5 3.2,4 3.61,3.61C4,3.2 4.5,3 5,3H19Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$B = [];
var __component__$C = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$B,
  _sfc_render$B,
  _sfc_staticRenderFns$B,
  false,
  null,
  null
);
const FileSpreadsheetIcon = __component__$C.exports;
const _sfc_main$A = {
  name: "FilePdfBoxIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$A = function render29() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon file-pdf-box-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3M9.5 11.5C9.5 12.3 8.8 13 8 13H7V15H5.5V9H8C8.8 9 9.5 9.7 9.5 10.5V11.5M14.5 13.5C14.5 14.3 13.8 15 13 15H10.5V9H13C13.8 9 14.5 9.7 14.5 10.5V13.5M18.5 10.5H17V11.5H18.5V13H17V15H15.5V9H18.5V10.5M12 10.5H13V13.5H12V10.5M7 10.5H8V11.5H7V10.5Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$A = [];
var __component__$B = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$A,
  _sfc_render$A,
  _sfc_staticRenderFns$A,
  false,
  null,
  null
);
const FilePdfIcon = __component__$B.exports;
const _sfc_main$z = {
  name: "AlertCircleIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$z = function render30() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon alert-circle-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M13,13H11V7H13M13,17H11V15H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$z = [];
var __component__$A = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$z,
  _sfc_render$z,
  _sfc_staticRenderFns$z,
  false,
  null,
  null
);
const AlertCircleIcon = __component__$A.exports;
const _sfc_main$y = {
  name: "OpenInNewIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$y = function render31() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon open-in-new-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M14,3V5H17.59L7.76,14.83L9.17,16.24L19,6.41V10H21V3M19,19H5V5H12V3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V12H19V19Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$y = [];
var __component__$z = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$y,
  _sfc_render$y,
  _sfc_staticRenderFns$y,
  false,
  null,
  null
);
const OpenInNewIcon = __component__$z.exports;
const _sfc_main$x = {
  name: "RefreshIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$x = function render32() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon refresh-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$x = [];
var __component__$y = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$x,
  _sfc_render$x,
  _sfc_staticRenderFns$x,
  false,
  null,
  null
);
const RefreshIcon = __component__$y.exports;
const _sfc_main$w = {
  name: "ShareIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$w = function render33() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon share-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M21,12L14,5V9C7,10 4,15 3,20C5.5,16.5 9,14.9 14,14.9V19L21,12Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$w = [];
var __component__$x = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$w,
  _sfc_render$w,
  _sfc_staticRenderFns$w,
  false,
  null,
  null
);
const ShareIcon = __component__$x.exports;
const _sfc_main$v = {
  name: "DownloadIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$v = function render34() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon download-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$v = [];
var __component__$w = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$v,
  _sfc_render$v,
  _sfc_staticRenderFns$v,
  false,
  null,
  null
);
const DownloadIcon = __component__$w.exports;
const _sfc_main$u = {
  name: "FilesWidget",
  components: {
    NcButton,
    NcLoadingIcon,
    FolderIcon,
    FileIcon,
    FileDocumentIcon,
    FileImageIcon,
    FileMusicIcon,
    FileVideoIcon,
    FilePresentationIcon,
    FileSpreadsheetIcon,
    FilePdfIcon,
    AlertCircleIcon,
    OpenInNewIcon,
    RefreshIcon,
    ShareIcon,
    DownloadIcon
  },
  props: {
    widget: {
      type: Object,
      required: true
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    return {
      files: [],
      loading: true,
      error: null,
      viewMode: "recent"
      // 'recent' or 'favorites'
    };
  },
  computed: {
    displayMode() {
      if (this.widget.w <= 2 || this.widget.h <= 2) {
        return "compact";
      }
      return "full";
    },
    recentFiles() {
      return [...this.files].filter((file) => file.type === "file").sort((a, b) => b.mtime - a.mtime);
    },
    favoriteFiles() {
      return this.files.filter((file) => file.favorite && file.type === "file");
    },
    displayedFiles() {
      return this.viewMode === "favorites" ? this.favoriteFiles : this.recentFiles;
    }
  },
  async mounted() {
    await this.loadFiles();
  },
  methods: {
    t: translate,
    async loadFiles() {
      try {
        this.loading = true;
        this.error = null;
        const response = await cancelableClient.get(_("/apps/dashy/api/files"));
        this.files = response.data.files || [];
      } catch (error) {
        console.error("Failed to load files:", error);
        if (error.response?.status === 404) {
          this.error = translate("dashy", "Files API not accessible");
        } else {
          this.error = translate("dashy", "Failed to load files");
        }
      } finally {
        this.loading = false;
      }
    },
    getFileIcon(file) {
      if (file.type === "dir") return FolderIcon;
      const extension = file.name.split(".").pop()?.toLowerCase() || "";
      const mimeType = file.mimetype || "";
      if (mimeType.startsWith("image/") || ["jpg", "jpeg", "png", "gif", "svg", "webp"].includes(extension)) {
        return FileImageIcon;
      }
      if (mimeType.includes("document") || ["doc", "docx", "odt", "rtf"].includes(extension)) {
        return FileDocumentIcon;
      }
      if (mimeType.includes("spreadsheet") || ["xls", "xlsx", "ods", "csv"].includes(extension)) {
        return FileSpreadsheetIcon;
      }
      if (mimeType.includes("presentation") || ["ppt", "pptx", "odp"].includes(extension)) {
        return FilePresentationIcon;
      }
      if (mimeType === "application/pdf" || extension === "pdf") {
        return FilePdfIcon;
      }
      if (mimeType.startsWith("audio/") || ["mp3", "wav", "ogg", "flac", "m4a"].includes(extension)) {
        return FileMusicIcon;
      }
      if (mimeType.startsWith("video/") || ["mp4", "avi", "mkv", "mov", "wmv"].includes(extension)) {
        return FileVideoIcon;
      }
      return FileIcon;
    },
    formatFileSize(bytes) {
      if (!bytes) return "0 B";
      const units = ["B", "KB", "MB", "GB"];
      let size2 = bytes;
      let unitIndex = 0;
      while (size2 >= 1024 && unitIndex < units.length - 1) {
        size2 /= 1024;
        unitIndex++;
      }
      return `${Math.round(size2 * 10) / 10} ${units[unitIndex]}`;
    },
    formatDate(timestamp) {
      if (!timestamp) return "";
      const date = new Date(timestamp * 1e3);
      const now = /* @__PURE__ */ new Date();
      const diff = now - date;
      if (diff < 24 * 60 * 60 * 1e3) {
        return date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
      }
      if (diff < 7 * 24 * 60 * 60 * 1e3) {
        return date.toLocaleDateString([], { weekday: "short" });
      }
      return date.toLocaleDateString([], { month: "short", day: "numeric" });
    },
    openFile(file) {
      const fileUrl = _(`/apps/files/?dir=${encodeURIComponent(file.path)}&openfile=${encodeURIComponent(file.id)}`);
      window.open(fileUrl, "_blank");
    },
    openFilesApp() {
      window.open(_("/apps/files"), "_blank");
    },
    shareFile(file) {
      window.open(_(`/apps/files/?dir=${encodeURIComponent(file.path)}&openfile=${encodeURIComponent(file.id)}&view=sharing`), "_blank");
    },
    downloadFile(file) {
      const downloadUrl = _(`/remote.php/webdav${file.path}/${file.name}`);
      const link = document.createElement("a");
      link.href = downloadUrl;
      link.download = file.name;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  }
};
var _sfc_render$u = function render35() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "files-widget" }, [_vm.loading ? _c("div", { staticClass: "loading" }, [_c("NcLoadingIcon", { attrs: { "size": 24 } }), _c("p", [_vm._v(_vm._s(_vm.t("dashy", "Loading files...")))])], 1) : _vm.error ? _c("div", { staticClass: "error" }, [_c("AlertCircleIcon", { attrs: { "size": 24 } }), _c("p", [_vm._v(_vm._s(_vm.error))])], 1) : _c("div", [_vm.displayMode === "compact" ? _c("div", { staticClass: "files-compact" }, [_c("div", { staticClass: "files-count" }, [_c("FolderIcon", { attrs: { "size": 20 } }), _c("span", [_vm._v(_vm._s(_vm.files.length) + " " + _vm._s(_vm.t("dashy", "recent files")))])], 1), _vm.recentFiles.length > 0 ? _c("div", { staticClass: "recent-files" }, _vm._l(_vm.recentFiles.slice(0, 3), function(file) {
    return _c("div", { key: file.id, staticClass: "file-item compact", on: { "click": function($event) {
      return _vm.openFile(file);
    } } }, [_c(_vm.getFileIcon(file), { tag: "component", attrs: { "size": 16 } }), _c("span", { staticClass: "file-name" }, [_vm._v(_vm._s(file.name))])], 1);
  }), 0) : _vm._e()]) : _c("div", { staticClass: "files-list" }, [_c("div", { staticClass: "files-header" }, [_c("h4", [_vm._v(_vm._s(_vm.t("dashy", "Recent Files")))]), _c("div", { staticClass: "header-actions" }, [_c("NcButton", { attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Refresh") }, on: { "click": _vm.loadFiles }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("RefreshIcon", { attrs: { "size": 16 } })];
  }, proxy: true }]) }), _c("NcButton", { attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Open Files app") }, on: { "click": _vm.openFilesApp }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("OpenInNewIcon", { attrs: { "size": 16 } })];
  }, proxy: true }]) })], 1)]), _vm.files.length > 0 ? _c("div", { staticClass: "view-toggle" }, [_c("NcButton", { attrs: { "type": _vm.viewMode === "recent" ? "primary" : "tertiary" }, on: { "click": function($event) {
    _vm.viewMode = "recent";
  } } }, [_vm._v(" " + _vm._s(_vm.t("dashy", "Recent")) + " ")]), _c("NcButton", { attrs: { "type": _vm.viewMode === "favorites" ? "primary" : "tertiary" }, on: { "click": function($event) {
    _vm.viewMode = "favorites";
  } } }, [_vm._v(" " + _vm._s(_vm.t("dashy", "Favorites")) + " ")])], 1) : _vm._e(), _c("div", { staticClass: "file-list" }, _vm._l(_vm.displayedFiles.slice(0, _vm.settings.maxFiles || 15), function(file) {
    return _c("div", { key: file.id, staticClass: "file-item", on: { "click": function($event) {
      return _vm.openFile(file);
    } } }, [_c("div", { staticClass: "file-icon" }, [_c(_vm.getFileIcon(file), { tag: "component", attrs: { "size": 24 } })], 1), _c("div", { staticClass: "file-info" }, [_c("div", { staticClass: "file-name" }, [_vm._v(_vm._s(file.name))]), _c("div", { staticClass: "file-details" }, [_c("span", { staticClass: "file-size" }, [_vm._v(_vm._s(_vm.formatFileSize(file.size)))]), _c("span", { staticClass: "file-modified" }, [_vm._v(_vm._s(_vm.formatDate(file.mtime)))])])]), _c("div", { staticClass: "file-actions" }, [_c("NcButton", { attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Share file") }, on: { "click": function($event) {
      $event.stopPropagation();
      return _vm.shareFile(file);
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("ShareIcon", { attrs: { "size": 16 } })];
    }, proxy: true }], null, true) }), _c("NcButton", { attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Download file") }, on: { "click": function($event) {
      $event.stopPropagation();
      return _vm.downloadFile(file);
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("DownloadIcon", { attrs: { "size": 16 } })];
    }, proxy: true }], null, true) })], 1)]);
  }), 0)])])]);
};
var _sfc_staticRenderFns$u = [];
var __component__$v = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$u,
  _sfc_render$u,
  _sfc_staticRenderFns$u,
  false,
  null,
  "c340aa76"
);
const FilesWidget = __component__$v.exports;
const _sfc_main$t = {
  name: "NoteTextIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$t = function render36() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon note-text-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M14,10H19.5L14,4.5V10M5,3H15L21,9V19A2,2 0 0,1 19,21H5C3.89,21 3,20.1 3,19V5C3,3.89 3.89,3 5,3M5,12V14H19V12H5M5,16V18H14V16H5Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$t = [];
var __component__$u = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$t,
  _sfc_render$t,
  _sfc_staticRenderFns$t,
  false,
  null,
  null
);
const NoteTextIcon = __component__$u.exports;
const _sfc_main$s = {
  name: "NotesWidget",
  components: {
    NcButton,
    NcLoadingIcon,
    NoteTextIcon,
    AlertCircleIcon,
    OpenInNewIcon,
    RefreshIcon,
    PlusIcon,
    PencilIcon
  },
  props: {
    widget: {
      type: Object,
      required: true
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    return {
      notes: [],
      loading: true,
      error: null,
      showQuickNote: false,
      showPreview: false,
      quickNote: {
        title: "",
        content: "",
        id: null
      },
      previewNote: {},
      noteModalElement: null,
      previewModalElement: null
    };
  },
  computed: {
    displayMode() {
      if (this.widget.w <= 2 || this.widget.h <= 2) {
        return "compact";
      }
      return "full";
    },
    recentNotes() {
      return [...this.notes].sort((a, b) => b.modified - a.modified);
    },
    displayedNotes() {
      return this.recentNotes;
    }
  },
  async mounted() {
    await this.loadNotes();
  },
  beforeDestroy() {
    this.removeNoteModal();
    this.removePreviewModal();
  },
  methods: {
    t: translate,
    async loadNotes() {
      console.log("Loading notes with settings:", this.settings);
      try {
        this.loading = true;
        this.error = null;
        let apiUrl = _("/apps/dashy/api/notes");
        if (this.settings.notesFolder) {
          apiUrl += `?folder=${encodeURIComponent(this.settings.notesFolder)}`;
        }
        console.log("Notes API URL:", apiUrl);
        const response = await cancelableClient.get(apiUrl);
        console.log("Notes API response:", response.data);
        this.notes = response.data.notes || [];
      } catch (error) {
        console.error("Failed to load notes:", error);
        console.error("Error response:", error.response);
        if (error.response?.status === 404) {
          this.error = translate("dashy", "Notes API not accessible");
        } else {
          this.error = translate("dashy", "Failed to load notes");
        }
      } finally {
        this.loading = false;
      }
    },
    getPreview(content) {
      if (!content) return translate("dashy", "No content");
      const stripped = content.replace(/<[^>]*>/g, "").trim();
      return stripped.length > 100 ? stripped.substring(0, 100) + "..." : stripped;
    },
    formatDate(timestamp) {
      if (!timestamp) return "";
      const date = new Date(timestamp * 1e3);
      const day = String(date.getDate()).padStart(2, "0");
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const year = String(date.getFullYear()).substring(2);
      const hours = String(date.getHours()).padStart(2, "0");
      const minutes = String(date.getMinutes()).padStart(2, "0");
      return `${day}.${month}.${year}, ${hours}:${minutes}`;
    },
    openNote(note) {
      if (this.isNotesAppAvailable()) {
        window.open(_(`/apps/notes/${note.id}`), "_blank");
      } else {
        this.editNote(note);
      }
    },
    editNote(note) {
      this.quickNote = {
        id: note.id,
        title: note.title || "",
        content: note.content || ""
      };
      this.showQuickNote = true;
      this.createNoteModal();
    },
    createNote() {
      this.quickNote = {
        title: "",
        content: "",
        id: null
      };
      this.showQuickNote = true;
      this.createNoteModal();
    },
    openNotesApp() {
      if (this.isNotesAppAvailable()) {
        window.open(_("/apps/notes"), "_blank");
      } else {
        this.createNote();
      }
    },
    closeQuickNote() {
      this.showQuickNote = false;
      this.removeNoteModal();
      this.quickNote = { title: "", content: "", id: null };
    },
    handleNoteModalEscapeKey(event) {
      if (event.key === "Escape" && this.showQuickNote) {
        this.closeQuickNote();
      }
    },
    createNoteModal() {
      if (this.noteModalElement) return;
      document.addEventListener("keydown", this.handleNoteModalEscapeKey);
      this.noteModalElement = document.createElement("div");
      this.noteModalElement.className = "note-editor-overlay";
      this.noteModalElement.addEventListener("click", this.handleNoteModalOverlayClick);
      const modalContent = document.createElement("div");
      modalContent.className = "note-editor-modal";
      modalContent.addEventListener("click", (e) => e.stopPropagation());
      modalContent.innerHTML = this.getNoteModalHTML();
      this.noteModalElement.appendChild(modalContent);
      document.body.appendChild(this.noteModalElement);
      this.bindNoteModalEvents();
      setTimeout(() => {
        const titleInput = this.noteModalElement.querySelector("#note-title");
        if (titleInput) {
          titleInput.focus();
          if (this.quickNote.title) {
            titleInput.select();
          }
        }
      }, 100);
    },
    removeNoteModal() {
      if (this.noteModalElement) {
        document.removeEventListener("keydown", this.handleNoteModalEscapeKey);
        this.noteModalElement.removeEventListener("click", this.handleNoteModalOverlayClick);
        document.body.removeChild(this.noteModalElement);
        this.noteModalElement = null;
      }
    },
    handleNoteModalOverlayClick() {
      this.closeQuickNote();
    },
    getNoteModalHTML() {
      return `
				<div class="modal-header">
					<h3>${this.quickNote.id ? this.t("dashy", "Edit Note") : this.t("dashy", "Create Note")}</h3>
					<button class="close-btn" type="button" title="Close">✕</button>
				</div>
				<div class="modal-content">
					<form class="note-form">
						<div class="form-group">
							<label for="note-title">${this.t("dashy", "Title")}</label>
							<input
								id="note-title"
								type="text"
								placeholder="${this.t("dashy", "Note title...")}"
								value="${this.quickNote.title}"
								class="note-title-input"
							>
						</div>
						<div class="form-group">
							<label for="note-content">${this.t("dashy", "Content")}</label>
							<textarea
								id="note-content"
								placeholder="${this.t("dashy", "Write your note here...")}"
								rows="12"
								class="note-content-input"
							>${this.quickNote.content}</textarea>
						</div>
						<div class="form-actions">
							<button type="button" class="btn-cancel">${this.t("dashy", "Cancel")}</button>
							<button type="submit" class="btn-save">${this.t("dashy", "Save Note")}</button>
						</div>
					</form>
				</div>
			`;
    },
    bindNoteModalEvents() {
      if (!this.noteModalElement) return;
      const form = this.noteModalElement.querySelector(".note-form");
      form.addEventListener("submit", (e) => {
        e.preventDefault();
        this.saveQuickNote();
      });
      const closeBtn = this.noteModalElement.querySelector(".close-btn");
      if (closeBtn) {
        closeBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.closeQuickNote();
        });
      }
      const cancelBtn = this.noteModalElement.querySelector(".btn-cancel");
      if (cancelBtn) {
        cancelBtn.addEventListener("click", (e) => {
          e.preventDefault();
          this.closeQuickNote();
        });
      }
      const titleInput = this.noteModalElement.querySelector("#note-title");
      const contentTextarea = this.noteModalElement.querySelector("#note-content");
      titleInput?.addEventListener("input", (e) => {
        this.quickNote.title = e.target.value;
      });
      contentTextarea?.addEventListener("input", (e) => {
        this.quickNote.content = e.target.value;
      });
    },
    async saveQuickNote() {
      try {
        const titleInput = this.noteModalElement.querySelector("#note-title");
        const contentTextarea = this.noteModalElement.querySelector("#note-content");
        const noteData = {
          title: titleInput.value || this.t("dashy", "Untitled"),
          content: contentTextarea.value,
          folder: this.settings.notesFolder || ""
        };
        if (this.quickNote.id) {
          await cancelableClient.put(_(`/apps/dashy/api/notes/${this.quickNote.id}`), noteData);
        } else {
          await cancelableClient.post(_("/apps/dashy/api/notes"), noteData);
        }
        await this.loadNotes();
        this.closeQuickNote();
      } catch (error) {
        console.error("Failed to save note:", error);
      }
    },
    isNotesAppAvailable() {
      return document.querySelector('a[href*="/apps/notes"]') !== null;
    },
    showNotePreview(note) {
      this.previewNote = { ...note };
      this.showPreview = true;
      this.createPreviewModal();
    },
    closeNotePreview() {
      this.showPreview = false;
      this.removePreviewModal();
      this.previewNote = {};
    },
    editPreviewNote() {
      this.editNote(this.previewNote);
      this.closeNotePreview();
    },
    handlePreviewModalEscapeKey(event) {
      if (event.key === "Escape" && this.showPreview) {
        this.closeNotePreview();
      }
    },
    createPreviewModal() {
      if (this.previewModalElement) return;
      document.addEventListener("keydown", this.handlePreviewModalEscapeKey);
      this.previewModalElement = document.createElement("div");
      this.previewModalElement.className = "note-preview-overlay";
      this.previewModalElement.addEventListener("click", this.handlePreviewModalOverlayClick);
      const modalContent = document.createElement("div");
      modalContent.className = "note-preview-modal";
      modalContent.addEventListener("click", (e) => e.stopPropagation());
      modalContent.innerHTML = this.getPreviewModalHTML();
      this.previewModalElement.appendChild(modalContent);
      document.body.appendChild(this.previewModalElement);
      this.bindPreviewModalEvents();
    },
    removePreviewModal() {
      if (this.previewModalElement) {
        document.removeEventListener("keydown", this.handlePreviewModalEscapeKey);
        this.previewModalElement.removeEventListener("click", this.handlePreviewModalOverlayClick);
        document.body.removeChild(this.previewModalElement);
        this.previewModalElement = null;
      }
    },
    handlePreviewModalOverlayClick() {
      this.closeNotePreview();
    },
    getPreviewModalHTML() {
      return `
				<div class="modal-header">
					<h3>${this.previewNote.title || this.t("dashy", "Untitled")}</h3>
					<button class="close-btn" type="button" title="Close">✕</button>
				</div>
				<div class="modal-content">
					<div class="note-preview-content">
						<div class="note-meta-info">
							<span class="note-created-date">${this.t("dashy", "Created")}: ${this.formatDate(this.previewNote.created || this.previewNote.modified)}</span>
							${this.previewNote.category ? `<span class="note-category-badge">${this.previewNote.category}</span>` : ""}
						</div>
						<div class="note-content-display">
							${this.previewNote.content}
						</div>
					</div>
					<div class="modal-actions">
						<button type="button" class="btn-cancel">${this.t("dashy", "Close")}</button>
						<button type="button" class="btn-save">${this.t("dashy", "Edit")}</button>
					</div>
				</div>
			`;
    },
    bindPreviewModalEvents() {
      if (!this.previewModalElement) return;
      const closeBtn = this.previewModalElement.querySelector(".close-btn");
      if (closeBtn) {
        closeBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.closeNotePreview();
        });
      }
      const cancelBtn = this.previewModalElement.querySelector(".btn-cancel");
      if (cancelBtn) {
        cancelBtn.addEventListener("click", (e) => {
          e.preventDefault();
          this.closeNotePreview();
        });
      }
      const editBtn = this.previewModalElement.querySelector(".btn-save");
      if (editBtn) {
        editBtn.addEventListener("click", (e) => {
          e.preventDefault();
          this.editPreviewNote();
        });
      }
    }
  }
};
var _sfc_render$s = function render37() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "notes-widget" }, [_vm.loading ? _c("div", { staticClass: "loading" }, [_c("NcLoadingIcon", { attrs: { "size": 24 } }), _c("p", [_vm._v(_vm._s(_vm.t("dashy", "Loading notes...")))])], 1) : _vm.error ? _c("div", { staticClass: "error" }, [_c("AlertCircleIcon", { attrs: { "size": 24 } }), _c("p", [_vm._v(_vm._s(_vm.error))])], 1) : _c("div", [_vm.displayMode === "compact" ? _c("div", { staticClass: "notes-compact" }, [_c("div", { staticClass: "notes-count" }, [_c("NoteTextIcon", { attrs: { "size": 20 } }), _c("span", [_vm._v(_vm._s(_vm.notes.length) + " " + _vm._s(_vm.t("dashy", "notes")))])], 1), _vm.recentNotes.length > 0 ? _c("div", { staticClass: "recent-notes" }, _vm._l(_vm.recentNotes.slice(0, 3), function(note) {
    return _c("div", { key: note.id, staticClass: "note-item compact", on: { "click": function($event) {
      return _vm.openNote(note);
    } } }, [_c("div", { staticClass: "note-content" }, [_c("div", { staticClass: "note-title" }, [_vm._v(_vm._s(note.title || _vm.t("dashy", "Untitled")))]), _c("div", { staticClass: "note-preview" }, [_vm._v(_vm._s(_vm.getPreview(note.content)))])])]);
  }), 0) : _vm._e()]) : _c("div", { staticClass: "notes-list" }, [_c("div", { staticClass: "notes-header" }, [_c("h4", [_vm._v(_vm._s(_vm.t("dashy", "Recent Notes")))]), _c("div", { staticClass: "header-actions" }, [_c("NcButton", { attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Create new note") }, on: { "click": _vm.createNote }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("PlusIcon", { attrs: { "size": 16 } })];
  }, proxy: true }]) }), _c("NcButton", { attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Refresh") }, on: { "click": _vm.loadNotes }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("RefreshIcon", { attrs: { "size": 16 } })];
  }, proxy: true }]) }), _c("NcButton", { attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Open Notes app") }, on: { "click": _vm.openNotesApp }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("OpenInNewIcon", { attrs: { "size": 16 } })];
  }, proxy: true }]) })], 1)]), _c("div", { staticClass: "note-list" }, _vm._l(_vm.displayedNotes.slice(0, _vm.settings.maxNotes || 10), function(note) {
    return _c("div", { key: note.id, staticClass: "note-item", on: { "click": function($event) {
      return _vm.showNotePreview(note);
    } } }, [_c("div", { staticClass: "note-icon" }, [_c("NoteTextIcon", { attrs: { "size": 24 } })], 1), _c("div", { staticClass: "note-info" }, [_c("div", { staticClass: "note-title" }, [_vm._v(_vm._s(note.title || _vm.t("dashy", "Untitled")))]), _c("div", { staticClass: "note-preview" }, [_vm._v(_vm._s(_vm.getPreview(note.content)))]), _c("div", { staticClass: "note-meta" }, [note.category ? _c("span", { staticClass: "note-category" }, [_vm._v(_vm._s(note.category))]) : _vm._e(), _c("span", { staticClass: "note-created" }, [_vm._v(_vm._s(_vm.formatDate(note.created || note.modified)))])])]), _c("div", { staticClass: "note-actions" }, [_c("NcButton", { attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Edit note") }, on: { "click": function($event) {
      $event.stopPropagation();
      return _vm.editNote(note);
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("PencilIcon", { attrs: { "size": 16 } })];
    }, proxy: true }], null, true) })], 1)]);
  }), 0)])])]);
};
var _sfc_staticRenderFns$s = [];
var __component__$t = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$s,
  _sfc_render$s,
  _sfc_staticRenderFns$s,
  false,
  null,
  "8a48eb8e"
);
const NotesWidget = __component__$t.exports;
const ScopeComponent = (Component) => {
  if (!Component.mounted) {
    Component.mounted = [];
  } else if (!Array.isArray(Component.mounted)) {
    Component.mounted = [Component.mounted];
  }
  Component.mounted.push(function() {
    this.$el.setAttribute(`data-v-${"6d5f1cd"}`, "");
  });
};
var mdiChevronLeft = "M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z";
var mdiChevronRight = "M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z";
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var isInert = function isInert2(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node && isInert2(node.parentNode);
  return result;
};
var isContentEditable = function isContentEditable2(node) {
  var _node$getAttribute2;
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter2) {
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter2);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node) {
  return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node) {
  if (!node) {
    throw new Error("No node provided");
  }
  if (node.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
  var tabIndex = getTabIndex(node);
  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isNodeAttached = function isNodeAttached2(node) {
  var _nodeRoot;
  var nodeRoot = node && getRootNode(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (isNodeAttached(node)) {
      return !node.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode2 = node.parentElement;
    while (parentNode2) {
      if (parentNode2.tagName === "FIELDSET" && parentNode2.disabled) {
        for (var i = 0; i < parentNode2.children.length; i++) {
          var child = parentNode2.children.item(i);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode2, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode2 = parentNode2.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
var isFocusable = function isFocusable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};
/*!
* focus-trap 7.6.5
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n2 = Array(a); e < a; e++) n2[e] = r[e];
  return n2;
}
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}
function _defineProperty(e, r, t2) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t2, e;
}
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys(e, r) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t2 = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t2), true).forEach(function(r2) {
      _defineProperty(e, r2, t2[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t2, r2));
    });
  }
  return e;
}
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}
function _toPrimitive(t2, r) {
  if ("object" != typeof t2 || !t2) return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t2, r);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t2);
}
function _toPropertyKey(t2) {
  var i = _toPrimitive(t2, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t2 = {}.toString.call(r).slice(8, -1);
    return "Object" === t2 && r.constructor && (t2 = r.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r, a) : void 0;
  }
}
var activeFocusTraps = {
  activateTrap: function activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      var activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap._setPausedState(true);
      }
    }
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap: function deactivateTrap(trapStack, trap) {
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0 && !trapStack[trapStack.length - 1]._isManuallyPaused()) {
      trapStack[trapStack.length - 1]._setPausedState(false);
    }
  }
};
var isSelectableInput = function isSelectableInput2(node) {
  return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
};
var isEscapeEvent = function isEscapeEvent2(e) {
  return (e === null || e === void 0 ? void 0 : e.key) === "Escape" || (e === null || e === void 0 ? void 0 : e.key) === "Esc" || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;
};
var isTabEvent = function isTabEvent2(e) {
  return (e === null || e === void 0 ? void 0 : e.key) === "Tab" || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;
};
var isKeyForward = function isKeyForward2(e) {
  return isTabEvent(e) && !e.shiftKey;
};
var isKeyBackward = function isKeyBackward2(e) {
  return isTabEvent(e) && e.shiftKey;
};
var delay = function delay2(fn) {
  return setTimeout(fn, 0);
};
var valueOrHandler = function valueOrHandler2(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === "function" ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget2(event) {
  return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
};
var internalTrapStack = [];
var createFocusTrap = function createFocusTrap2(elements, userOptions) {
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
  var config2 = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true,
    isKeyForward,
    isKeyBackward
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   posTabIndexesFound: boolean,
    //   firstTabbableNode: HTMLElement|undefined,
    //   lastTabbableNode: HTMLElement|undefined,
    //   firstDomTabbableNode: HTMLElement|undefined,
    //   lastDomTabbableNode: HTMLElement|undefined,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    manuallyPaused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0,
    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
    recentNavEvent: void 0
  };
  var trap;
  var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config2[configOptionName || optionName];
  };
  var findContainerIndex = function findContainerIndex2(element, event) {
    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === "function" ? event.composedPath() : void 0;
    return state.containerGroups.findIndex(function(_ref) {
      var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node) {
        return node === element;
      });
    });
  };
  var getNodeForOption = function getNodeForOption2(optionName) {
    var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$hasFallback = _ref2.hasFallback, hasFallback = _ref2$hasFallback === void 0 ? false : _ref2$hasFallback, _ref2$params = _ref2.params, params = _ref2$params === void 0 ? [] : _ref2$params;
    var optionValue = config2[optionName];
    if (typeof optionValue === "function") {
      optionValue = optionValue.apply(void 0, _toConsumableArray(params));
    }
    if (optionValue === true) {
      optionValue = void 0;
    }
    if (!optionValue) {
      if (optionValue === void 0 || optionValue === false) {
        return optionValue;
      }
      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue;
    if (typeof optionValue === "string") {
      try {
        node = doc.querySelector(optionValue);
      } catch (err) {
        throw new Error("`".concat(optionName, '` appears to be an invalid selector; error="').concat(err.message, '"'));
      }
      if (!node) {
        if (!hasFallback) {
          throw new Error("`".concat(optionName, "` as selector refers to no known node"));
        }
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode2() {
    var node = getNodeForOption("initialFocus", {
      hasFallback: true
    });
    if (node === false) {
      return false;
    }
    if (node === void 0 || node && !isFocusable(node, config2.tabbableOptions)) {
      if (findContainerIndex(doc.activeElement) >= 0) {
        node = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
        node = firstTabbableNode || getNodeForOption("fallbackFocus");
      }
    } else if (node === null) {
      node = getNodeForOption("fallbackFocus");
    }
    if (!node) {
      throw new Error("Your focus-trap needs to have at least one focusable element");
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes2() {
    state.containerGroups = state.containers.map(function(container) {
      var tabbableNodes = tabbable(container, config2.tabbableOptions);
      var focusableNodes = focusable(container, config2.tabbableOptions);
      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
      var firstDomTabbableNode = focusableNodes.find(function(node) {
        return isTabbable(node);
      });
      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node) {
        return isTabbable(node);
      });
      var posTabIndexesFound = !!tabbableNodes.find(function(node) {
        return getTabIndex(node) > 0;
      });
      return {
        container,
        tabbableNodes,
        focusableNodes,
        /** True if at least one node with positive `tabindex` was found in this container. */
        posTabIndexesFound,
        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
        firstTabbableNode,
        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
        lastTabbableNode,
        // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
        //  because that API doesn't work with Shadow DOM as well as it should (@see
        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
        //  to address an edge case related to positive tabindex support, this seems like a much easier,
        //  "close enough most of the time" alternative for positive tabindexes which should generally
        //  be avoided anyway...
        /** First tabbable node in container, __DOM__ order; `undefined` if none. */
        firstDomTabbableNode,
        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
        lastDomTabbableNode,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node) {
          var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var nodeIdx = tabbableNodes.indexOf(node);
          if (nodeIdx < 0) {
            if (forward) {
              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function(el) {
                return isTabbable(el);
              });
            }
            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function(el) {
              return isTabbable(el);
            });
          }
          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function(group) {
      return group.tabbableNodes.length > 0;
    });
    if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    }
    if (state.containerGroups.find(function(g) {
      return g.posTabIndexesFound;
    }) && state.containerGroups.length > 1) {
      throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
    }
  };
  var _getActiveElement = function getActiveElement(el) {
    var activeElement = el.activeElement;
    if (!activeElement) {
      return;
    }
    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
      return _getActiveElement(activeElement.shadowRoot);
    }
    return activeElement;
  };
  var _tryFocus = function tryFocus(node) {
    if (node === false) {
      return;
    }
    if (node === _getActiveElement(document)) {
      return;
    }
    if (!node || !node.focus) {
      _tryFocus(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config2.preventScroll
    });
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
    var node = getNodeForOption("setReturnFocus", {
      params: [previousActiveElement]
    });
    return node ? node : node === false ? false : previousActiveElement;
  };
  var findNextNavNode = function findNextNavNode2(_ref3) {
    var target2 = _ref3.target, event = _ref3.event, _ref3$isBackward = _ref3.isBackward, isBackward = _ref3$isBackward === void 0 ? false : _ref3$isBackward;
    target2 = target2 || getActualTarget(event);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      var containerIndex = findContainerIndex(target2, event);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
      if (containerIndex < 0) {
        if (isBackward) {
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (isBackward) {
        var startOfGroupIndex = state.tabbableGroups.findIndex(function(_ref4) {
          var firstTabbableNode = _ref4.firstTabbableNode;
          return target2 === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target2 || isFocusable(target2, config2.tabbableOptions) && !isTabbable(target2, config2.tabbableOptions) && !containerGroup.nextTabbableNode(target2, false))) {
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = getTabIndex(target2) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
        } else if (!isTabEvent(event)) {
          destinationNode = containerGroup.nextTabbableNode(target2, false);
        }
      } else {
        var lastOfGroupIndex = state.tabbableGroups.findIndex(function(_ref5) {
          var lastTabbableNode = _ref5.lastTabbableNode;
          return target2 === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target2 || isFocusable(target2, config2.tabbableOptions) && !isTabbable(target2, config2.tabbableOptions) && !containerGroup.nextTabbableNode(target2))) {
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = getTabIndex(target2) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
        } else if (!isTabEvent(event)) {
          destinationNode = containerGroup.nextTabbableNode(target2);
        }
      }
    } else {
      destinationNode = getNodeForOption("fallbackFocus");
    }
    return destinationNode;
  };
  var checkPointerDown = function checkPointerDown2(e) {
    var target2 = getActualTarget(e);
    if (findContainerIndex(target2, e) >= 0) {
      return;
    }
    if (valueOrHandler(config2.clickOutsideDeactivates, e)) {
      trap.deactivate({
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked (and if not focusable, to "nothing"); by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node), whether the
        //  outside click was on a focusable node or not
        returnFocus: config2.returnFocusOnDeactivate
      });
      return;
    }
    if (valueOrHandler(config2.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
  };
  var checkFocusIn = function checkFocusIn2(event) {
    var target2 = getActualTarget(event);
    var targetContained = findContainerIndex(target2, event) >= 0;
    if (targetContained || target2 instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target2;
      }
    } else {
      event.stopImmediatePropagation();
      var nextNode;
      var navAcrossContainers = true;
      if (state.mostRecentlyFocusedNode) {
        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
          if (tabbableNodes.length > 0) {
            var mruTabIdx = tabbableNodes.findIndex(function(node) {
              return node === state.mostRecentlyFocusedNode;
            });
            if (mruTabIdx >= 0) {
              if (config2.isKeyForward(state.recentNavEvent)) {
                if (mruTabIdx + 1 < tabbableNodes.length) {
                  nextNode = tabbableNodes[mruTabIdx + 1];
                  navAcrossContainers = false;
                }
              } else {
                if (mruTabIdx - 1 >= 0) {
                  nextNode = tabbableNodes[mruTabIdx - 1];
                  navAcrossContainers = false;
                }
              }
            }
          }
        } else {
          if (!state.containerGroups.some(function(g) {
            return g.tabbableNodes.some(function(n2) {
              return getTabIndex(n2) > 0;
            });
          })) {
            navAcrossContainers = false;
          }
        }
      } else {
        navAcrossContainers = false;
      }
      if (navAcrossContainers) {
        nextNode = findNextNavNode({
          // move FROM the MRU node, not event-related node (which will be the node that is
          //  outside the trap causing the focus escape we're trying to fix)
          target: state.mostRecentlyFocusedNode,
          isBackward: config2.isKeyBackward(state.recentNavEvent)
        });
      }
      if (nextNode) {
        _tryFocus(nextNode);
      } else {
        _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    }
    state.recentNavEvent = void 0;
  };
  var checkKeyNav = function checkKeyNav2(event) {
    var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    state.recentNavEvent = event;
    var destinationNode = findNextNavNode({
      event,
      isBackward
    });
    if (destinationNode) {
      if (isTabEvent(event)) {
        event.preventDefault();
      }
      _tryFocus(destinationNode);
    }
  };
  var checkTabKey = function checkTabKey2(event) {
    if (config2.isKeyForward(event) || config2.isKeyBackward(event)) {
      checkKeyNav(event, config2.isKeyBackward(event));
    }
  };
  var checkEscapeKey = function checkEscapeKey2(event) {
    if (isEscapeEvent(event) && valueOrHandler(config2.escapeDeactivates, event) !== false) {
      event.preventDefault();
      trap.deactivate();
    }
  };
  var checkClick = function checkClick2(e) {
    var target2 = getActualTarget(e);
    if (findContainerIndex(target2, e) >= 0) {
      return;
    }
    if (valueOrHandler(config2.clickOutsideDeactivates, e)) {
      return;
    }
    if (valueOrHandler(config2.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
    e.stopImmediatePropagation();
  };
  var addListeners2 = function addListeners3() {
    if (!state.active) {
      return;
    }
    activeFocusTraps.activateTrap(trapStack, trap);
    state.delayInitialFocusTimer = config2.delayInitialFocus ? delay(function() {
      _tryFocus(getInitialFocusNode());
    }) : _tryFocus(getInitialFocusNode());
    doc.addEventListener("focusin", checkFocusIn, true);
    doc.addEventListener("mousedown", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("touchstart", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("click", checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkTabKey, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkEscapeKey);
    return trap;
  };
  var removeListeners2 = function removeListeners3() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener("focusin", checkFocusIn, true);
    doc.removeEventListener("mousedown", checkPointerDown, true);
    doc.removeEventListener("touchstart", checkPointerDown, true);
    doc.removeEventListener("click", checkClick, true);
    doc.removeEventListener("keydown", checkTabKey, true);
    doc.removeEventListener("keydown", checkEscapeKey);
    return trap;
  };
  var checkDomRemoval = function checkDomRemoval2(mutations) {
    var isFocusedNodeRemoved = mutations.some(function(mutation) {
      var removedNodes = Array.from(mutation.removedNodes);
      return removedNodes.some(function(node) {
        return node === state.mostRecentlyFocusedNode;
      });
    });
    if (isFocusedNodeRemoved) {
      _tryFocus(getInitialFocusNode());
    }
  };
  var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
  var updateObservedNodes = function updateObservedNodes2() {
    if (!mutationObserver) {
      return;
    }
    mutationObserver.disconnect();
    if (state.active && !state.paused) {
      state.containers.map(function(container) {
        mutationObserver.observe(container, {
          subtree: true,
          childList: true
        });
      });
    }
  };
  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, "onActivate");
      var onPostActivate = getOption(activateOptions, "onPostActivate");
      var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = _getActiveElement(doc);
      onActivate === null || onActivate === void 0 || onActivate();
      var finishActivation = function finishActivation2() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners2();
        updateObservedNodes();
        onPostActivate === null || onPostActivate === void 0 || onPostActivate();
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config2.onDeactivate,
        onPostDeactivate: config2.onPostDeactivate,
        checkCanReturnFocus: config2.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer);
      state.delayInitialFocusTimer = void 0;
      removeListeners2();
      state.active = false;
      state.paused = false;
      updateObservedNodes();
      activeFocusTraps.deactivateTrap(trapStack, trap);
      var onDeactivate = getOption(options, "onDeactivate");
      var onPostDeactivate = getOption(options, "onPostDeactivate");
      var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
      var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
      onDeactivate === null || onDeactivate === void 0 || onDeactivate();
      var finishDeactivation = function finishDeactivation2() {
        delay(function() {
          if (returnFocus) {
            _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause(pauseOptions) {
      if (!state.active) {
        return this;
      }
      state.manuallyPaused = true;
      return this._setPausedState(true, pauseOptions);
    },
    unpause: function unpause(unpauseOptions) {
      if (!state.active) {
        return this;
      }
      state.manuallyPaused = false;
      if (trapStack[trapStack.length - 1] !== this) {
        return this;
      }
      return this._setPausedState(false, unpauseOptions);
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function(element) {
        return typeof element === "string" ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      updateObservedNodes();
      return this;
    }
  };
  Object.defineProperties(trap, {
    _isManuallyPaused: {
      value: function value() {
        return state.manuallyPaused;
      }
    },
    _setPausedState: {
      value: function value(paused, options) {
        if (state.paused === paused) {
          return this;
        }
        state.paused = paused;
        if (paused) {
          var onPause = getOption(options, "onPause");
          var onPostPause = getOption(options, "onPostPause");
          onPause === null || onPause === void 0 || onPause();
          removeListeners2();
          updateObservedNodes();
          onPostPause === null || onPostPause === void 0 || onPostPause();
        } else {
          var onUnpause = getOption(options, "onUnpause");
          var onPostUnpause = getOption(options, "onPostUnpause");
          onUnpause === null || onUnpause === void 0 || onUnpause();
          updateTabbableNodes();
          addListeners2();
          updateObservedNodes();
          onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
        }
        return this;
      }
    }
  });
  trap.updateContainerElements(elements);
  return trap;
};
const GenRandomId = (length) => {
  return Math.random().toString(36).replace(/[^a-z]+/g, "").slice(0, 5);
};
function getTrapStack() {
  window._nc_focus_trap ??= [];
  return window._nc_focus_trap;
}
function createTrapStackController() {
  let pausedStack = [];
  return {
    /**
     * Pause the current focus-trap stack
     */
    pause() {
      pausedStack = [...getTrapStack()];
      for (const trap of pausedStack) {
        trap.pause();
      }
    },
    /**
     * Unpause the paused focus trap stack
     */
    unpause() {
      for (const trap of pausedStack) {
        trap.unpause();
      }
      pausedStack = [];
    }
  };
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].includes(getBasePlacement(placement)) ? "x" : "y";
}
function getLengthFromAxis(axis) {
  return axis === "y" ? "height" : "width";
}
function computeCoordsFromPlacement(_ref) {
  let {
    reference,
    floating,
    placement
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  let coords;
  switch (getBasePlacement(placement)) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  switch (getAlignment(placement)) {
    case "start":
      coords[mainAxis] = coords[mainAxis] - (reference[length] / 2 - floating[length] / 2);
      break;
    case "end":
      coords[mainAxis] = coords[mainAxis] + (reference[length] / 2 - floating[length] / 2);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement({
    ...rects,
    placement
  });
  let statefulPlacement = placement;
  let middlewareData = {};
  for (let i = 0; i < middleware.length; i++) {
    const {
      name,
      fn
    } = middleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: data != null ? data : {}
    };
    if (reset) {
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement({
          ...rects,
          placement: statefulPlacement
        }));
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getSideObjectFromPadding(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
async function detectOverflow(middlewareArguments, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = "clippingParents",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = await platform2.getClippingClientRect({
    element: await platform2.isElement(element) ? element : element.contextElement || await platform2.getDocumentElement({
      element: elements.floating
    }),
    boundary,
    rootBoundary
  });
  const elementClientRect = rectToClientRect(await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: elementContext === "floating" ? {
      ...rects.floating,
      x,
      y
    } : rects.reference,
    offsetParent: await platform2.getOffsetParent({
      element: elements.floating
    }),
    strategy
  }));
  return {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
}
const min$1 = Math.min;
const max$1 = Math.max;
function within(min$1$1, value, max$1$1) {
  return max$1(min$1$1, min$1(value, max$1$1));
}
const arrow = (options) => ({
  name: "arrow",
  options,
  async fn(middlewareArguments) {
    const {
      element,
      padding = 0
    } = options != null ? options : {};
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2
    } = middlewareArguments;
    if (element == null) {
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x,
      y
    };
    const basePlacement = getBasePlacement(placement);
    const axis = getMainAxisFromPlacement(basePlacement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform2.getDimensions({
      element
    });
    const minProp = axis === "y" ? "top" : "left";
    const maxProp = axis === "y" ? "bottom" : "right";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await platform2.getOffsetParent({
      element
    });
    const clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    const centerToReference = endDiff / 2 - startDiff / 2;
    const min2 = paddingObject[minProp];
    const max2 = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = within(min2, center, max2);
    return {
      data: {
        [axis]: offset2,
        centerOffset: center - offset2
      }
    };
  }
});
const hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (matched) => hash$1[matched]);
}
function getAlignmentSides(placement, rects) {
  const isStart = getAlignment(placement) === "start";
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === "x" ? isStart ? "right" : "left" : isStart ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}
const hash = {
  start: "end",
  end: "start"
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (matched) => hash[matched]);
}
const basePlacements = ["top", "right", "bottom", "left"];
const allPlacements = /* @__PURE__ */ basePlacements.reduce((acc, basePlacement) => acc.concat(basePlacement, basePlacement + "-start", basePlacement + "-end"), []);
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getBasePlacement(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
const autoPlacement = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _middlewareData$autoP5, _placementsSortedByLe;
      const {
        x,
        y,
        rects,
        middlewareData,
        placement
      } = middlewareArguments;
      const {
        alignment = null,
        allowedPlacements = allPlacements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = options;
      if ((_middlewareData$autoP = middlewareData.autoPlacement) != null && _middlewareData$autoP.skip) {
        return {};
      }
      const placements2 = getPlacementList(alignment, autoAlignment, allowedPlacements);
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const currentIndex = (_middlewareData$autoP2 = (_middlewareData$autoP3 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP3.index) != null ? _middlewareData$autoP2 : 0;
      const currentPlacement = placements2[currentIndex];
      const {
        main,
        cross
      } = getAlignmentSides(currentPlacement, rects);
      if (placement !== currentPlacement) {
        return {
          x,
          y,
          reset: {
            placement: placements2[0]
          }
        };
      }
      const currentOverflows = [overflow[getBasePlacement(currentPlacement)], overflow[main], overflow[cross]];
      const allOverflows = [...(_middlewareData$autoP4 = (_middlewareData$autoP5 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP5.overflows) != null ? _middlewareData$autoP4 : [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements2[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);
      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find((_ref) => {
        let {
          overflows
        } = _ref;
        return overflows.every((overflow2) => overflow2 <= 0);
      })) == null ? void 0 : _placementsSortedByLe.placement;
      return {
        data: {
          skip: true
        },
        reset: {
          placement: placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement
        }
      };
    }
  };
};
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
const flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$flip, _middlewareData$flip2;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement
      } = middlewareArguments;
      if ((_middlewareData$flip = middlewareData.flip) != null && _middlewareData$flip.skip) {
        return {};
      }
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        flipAlignment = true,
        ...detectOverflowOptions
      } = options;
      const basePlacement = getBasePlacement(placement);
      const isBasePlacement = basePlacement === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[basePlacement]);
      }
      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects);
        overflows.push(overflow[main], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side) => side <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip3;
        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip3 = middlewareData.flip) == null ? void 0 : _middlewareData$flip3.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = "bottom";
        switch (fallbackStrategy) {
          case "bestFit": {
            var _overflowsData$slice$;
            const placement2 = (_overflowsData$slice$ = overflowsData.slice().sort((a, b) => a.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0) - b.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0))[0]) == null ? void 0 : _overflowsData$slice$.placement;
            if (placement2) {
              resetPlacement = placement2;
            }
            break;
          }
          case "initialPlacement":
            resetPlacement = initialPlacement;
            break;
        }
        return {
          data: {
            skip: true
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
function convertValueToCoords(_ref) {
  let {
    placement,
    rects,
    value
  } = _ref;
  const basePlacement = getBasePlacement(placement);
  const multiplier = ["left", "top"].includes(basePlacement) ? -1 : 1;
  const rawValue = typeof value === "function" ? value({
    ...rects,
    placement
  }) : value;
  const {
    mainAxis,
    crossAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0
  } : {
    mainAxis: 0,
    crossAxis: 0,
    ...rawValue
  };
  return getMainAxisFromPlacement(basePlacement) === "x" ? {
    x: crossAxis,
    y: mainAxis * multiplier
  } : {
    x: mainAxis * multiplier,
    y: crossAxis
  };
}
const offset = function(value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: "offset",
    options: value,
    fn(middlewareArguments) {
      const {
        x,
        y,
        placement,
        rects
      } = middlewareArguments;
      const diffCoords = convertValueToCoords({
        placement,
        rects,
        value
      });
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
function getCrossAxis(axis) {
  return axis === "x" ? "y" : "x";
}
const shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(middlewareArguments) {
      const {
        x,
        y,
        placement
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = options;
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getBasePlacement(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...middlewareArguments,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};
const size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$size;
      const {
        placement,
        rects,
        middlewareData
      } = middlewareArguments;
      const {
        apply: apply2,
        ...detectOverflowOptions
      } = options;
      if ((_middlewareData$size = middlewareData.size) != null && _middlewareData$size.skip) {
        return {};
      }
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const basePlacement = getBasePlacement(placement);
      const isEnd = getAlignment(placement) === "end";
      let heightSide;
      let widthSide;
      if (basePlacement === "top" || basePlacement === "bottom") {
        heightSide = basePlacement;
        widthSide = isEnd ? "left" : "right";
      } else {
        widthSide = basePlacement;
        heightSide = isEnd ? "top" : "bottom";
      }
      const xMin = max$1(overflow.left, 0);
      const xMax = max$1(overflow.right, 0);
      const yMin = max$1(overflow.top, 0);
      const yMax = max$1(overflow.bottom, 0);
      const dimensions = {
        height: rects.floating.height - (["left", "right"].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$1(overflow.top, overflow.bottom)) : overflow[heightSide]),
        width: rects.floating.width - (["top", "bottom"].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$1(overflow.left, overflow.right)) : overflow[widthSide])
      };
      apply2 == null ? void 0 : apply2({
        ...dimensions,
        ...rects
      });
      return {
        data: {
          skip: true
        },
        reset: {
          rects: true
        }
      };
    }
  };
};
function isWindow(value) {
  return (value == null ? void 0 : value.toString()) === "[object Window]";
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (!isWindow(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeName(node) {
  return isWindow(node) ? "" : node ? (node.nodeName || "").toLowerCase() : "";
}
function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow(value).Element;
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function isShadowRoot(node) {
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isScrollParent(element) {
  const {
    overflow,
    overflowX,
    overflowY
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const isFirefox = navigator.userAgent.toLowerCase().includes("firefox");
  const css = getComputedStyle$1(element);
  return css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].includes(css.willChange) || isFirefox && css.willChange === "filter" || isFirefox && (css.filter ? css.filter !== "none" : false);
}
const min = Math.min;
const max = Math.max;
const round = Math.round;
function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  const clientRect = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  return {
    width: clientRect.width / scaleX,
    height: clientRect.height / scaleY,
    top: clientRect.top / scaleY,
    right: clientRect.right / scaleX,
    bottom: clientRect.bottom / scaleY,
    left: clientRect.left / scaleX,
    x: clientRect.left / scaleX,
    y: clientRect.top / scaleY
  };
}
function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll(element) {
  if (isWindow(element)) {
    return {
      scrollLeft: element.pageXOffset,
      scrollTop: element.pageYOffset
    };
  }
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function isScaled(element) {
  const rect = getBoundingClientRect(element);
  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(element, isOffsetParentAnElement && isScaled(offsetParent));
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // @ts-ignore
    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    node.parentNode || // DOM Element detected
    (isShadowRoot(node) ? node.host : null) || // ShadowRoot detected
    getDocumentElement(node)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !["html", "body"].includes(getNodeName(currentNode))) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  const window2 = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getDimensions(element) {
  return {
    width: element.offsetWidth,
    height: element.offsetHeight
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    ...rect,
    x: rect.x - scroll.scrollLeft + offsets.x,
    y: rect.y - scroll.scrollTop + offsets.y
  };
}
function getViewportRect(element) {
  const win = getWindow(element);
  const html2 = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html2.clientWidth;
  let height = html2.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) < 0.01) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  const html2 = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max(html2.scrollWidth, html2.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max(html2.scrollHeight, html2.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body || html2).direction === "rtl") {
    x += max(html2.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getScrollParent(node) {
  if (["html", "body", "#document"].includes(getNodeName(node))) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function getScrollParents(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollParent = getScrollParent(node);
  const isBody = scrollParent === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollParent);
  const target2 = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  const updatedList = list.concat(target2);
  return isBody ? updatedList : (
    // @ts-ignore: isBody tells us target will be an HTMLElement here
    updatedList.concat(getScrollParents(getParentNode(target2)))
  );
}
function contains(parent, child) {
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    do {
      if (next && parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getInnerBoundingClientRect(element) {
  const clientRect = getBoundingClientRect(element);
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  return {
    top,
    left,
    x: left,
    y: top,
    right: left + element.clientWidth,
    bottom: top + element.clientHeight,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getClientRectFromClippingParent(element, clippingParent) {
  if (clippingParent === "viewport") {
    return rectToClientRect(getViewportRect(element));
  }
  if (isElement(clippingParent)) {
    return getInnerBoundingClientRect(clippingParent);
  }
  return rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  const clippingParents = getScrollParents(getParentNode(element));
  const canEscapeClipping = ["absolute", "fixed"].includes(getComputedStyle$1(element).position);
  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents.filter((clippingParent) => isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body");
}
function getClippingClientRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary
  } = _ref;
  const mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  const clippingParents = [...mainClippingParents, rootBoundary];
  const firstClippingParent = clippingParents[0];
  const clippingRect = clippingParents.reduce((accRect, clippingParent) => {
    const rect = getClientRectFromClippingParent(element, clippingParent);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingParent(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
const platform = {
  getElementRects: (_ref) => {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    return {
      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),
      floating: {
        ...getDimensions(floating),
        x: 0,
        y: 0
      }
    };
  },
  convertOffsetParentRelativeRectToViewportRelativeRect: (args) => convertOffsetParentRelativeRectToViewportRelativeRect(args),
  getOffsetParent: (_ref2) => {
    let {
      element
    } = _ref2;
    return getOffsetParent(element);
  },
  isElement: (value) => isElement(value),
  getDocumentElement: (_ref3) => {
    let {
      element
    } = _ref3;
    return getDocumentElement(element);
  },
  getClippingClientRect: (args) => getClippingClientRect(args),
  getDimensions: (_ref4) => {
    let {
      element
    } = _ref4;
    return getDimensions(element);
  },
  getClientRects: (_ref5) => {
    let {
      element
    } = _ref5;
    return element.getClientRects();
  }
};
const computePosition = (reference, floating, options) => computePosition$1(reference, floating, {
  platform,
  ...options
});
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target2 = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target2[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target2[prop] = source[prop];
    }
  return target2;
};
function assign(to, from) {
  for (const key in from) {
    if (Object.prototype.hasOwnProperty.call(from, key)) {
      if (typeof from[key] === "object" && to[key]) {
        assign(to[key], from[key]);
      } else {
        to[key] = from[key];
      }
    }
  }
}
const config = {
  disabled: false,
  distance: 5,
  skidding: 0,
  container: "body",
  boundary: void 0,
  instantMove: false,
  disposeTimeout: 5e3,
  popperTriggers: [],
  strategy: "absolute",
  preventOverflow: true,
  flip: true,
  shift: true,
  overflowPadding: 0,
  arrowPadding: 0,
  arrowOverflow: true,
  themes: {
    tooltip: {
      placement: "top",
      triggers: ["hover", "focus", "touch"],
      hideTriggers: (events2) => [...events2, "click"],
      delay: {
        show: 200,
        hide: 0
      },
      handleResize: false,
      html: false,
      loadingContent: "..."
    },
    dropdown: {
      placement: "bottom",
      triggers: ["click"],
      delay: 0,
      handleResize: true,
      autoHide: true
    },
    menu: {
      $extend: "dropdown",
      triggers: ["hover", "focus"],
      popperTriggers: ["hover", "focus"],
      delay: {
        show: 0,
        hide: 400
      }
    }
  }
};
function getDefaultConfig(theme, key) {
  let themeConfig = config.themes[theme] || {};
  let value;
  do {
    value = themeConfig[key];
    if (typeof value === "undefined") {
      if (themeConfig.$extend) {
        themeConfig = config.themes[themeConfig.$extend] || {};
      } else {
        themeConfig = null;
        value = config[key];
      }
    } else {
      themeConfig = null;
    }
  } while (themeConfig);
  return value;
}
function getThemeClasses(theme) {
  const result = [theme];
  let themeConfig = config.themes[theme] || {};
  do {
    if (themeConfig.$extend && !themeConfig.$resetCss) {
      result.push(themeConfig.$extend);
      themeConfig = config.themes[themeConfig.$extend] || {};
    } else {
      themeConfig = null;
    }
  } while (themeConfig);
  return result.map((c) => `v-popper--theme-${c}`);
}
function getAllParentThemes(theme) {
  const result = [theme];
  let themeConfig = config.themes[theme] || {};
  do {
    if (themeConfig.$extend) {
      result.push(themeConfig.$extend);
      themeConfig = config.themes[themeConfig.$extend] || {};
    } else {
      themeConfig = null;
    }
  } while (themeConfig);
  return result;
}
let supportsPassive = false;
if (typeof window !== "undefined") {
  supportsPassive = false;
  try {
    const opts = Object.defineProperty({}, "passive", {
      get() {
        supportsPassive = true;
      }
    });
    window.addEventListener("test", null, opts);
  } catch (e) {
  }
}
let isIOS = false;
if (typeof window !== "undefined" && typeof navigator !== "undefined") {
  isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
}
const placements = ["auto", "top", "bottom", "left", "right"].reduce((acc, base) => acc.concat([
  base,
  `${base}-start`,
  `${base}-end`
]), []);
const SHOW_EVENT_MAP = {
  hover: "mouseenter",
  focus: "focus",
  click: "click",
  touch: "touchstart"
};
const HIDE_EVENT_MAP = {
  hover: "mouseleave",
  focus: "blur",
  click: "click",
  touch: "touchend"
};
function removeFromArray(array, item) {
  const index2 = array.indexOf(item);
  if (index2 !== -1) {
    array.splice(index2, 1);
  }
}
function nextFrame() {
  return new Promise((resolve) => requestAnimationFrame(() => {
    requestAnimationFrame(resolve);
  }));
}
const shownPoppers = [];
let hidingPopper = null;
const shownPoppersByTheme = {};
function getShownPoppersByTheme(theme) {
  let list = shownPoppersByTheme[theme];
  if (!list) {
    list = shownPoppersByTheme[theme] = [];
  }
  return list;
}
let Element$1 = function() {
};
if (typeof window !== "undefined") {
  Element$1 = window.Element;
}
function defaultPropFactory(prop) {
  return function() {
    const props2 = this.$props;
    return getDefaultConfig(props2.theme, prop);
  };
}
const PROVIDE_KEY = "__floating-vue__popper";
var PrivatePopper = () => ({
  name: "VPopper",
  props: {
    theme: {
      type: String,
      required: true
    },
    targetNodes: {
      type: Function,
      required: true
    },
    referenceNode: {
      type: Function,
      required: true
    },
    popperNode: {
      type: Function,
      required: true
    },
    shown: {
      type: Boolean,
      default: false
    },
    showGroup: {
      type: String,
      default: null
    },
    ariaId: {
      default: null
    },
    disabled: {
      type: Boolean,
      default: defaultPropFactory("disabled")
    },
    positioningDisabled: {
      type: Boolean,
      default: defaultPropFactory("positioningDisabled")
    },
    placement: {
      type: String,
      default: defaultPropFactory("placement"),
      validator: (value) => placements.includes(value)
    },
    delay: {
      type: [String, Number, Object],
      default: defaultPropFactory("delay")
    },
    distance: {
      type: [Number, String],
      default: defaultPropFactory("distance")
    },
    skidding: {
      type: [Number, String],
      default: defaultPropFactory("skidding")
    },
    triggers: {
      type: Array,
      default: defaultPropFactory("triggers")
    },
    showTriggers: {
      type: [Array, Function],
      default: defaultPropFactory("showTriggers")
    },
    hideTriggers: {
      type: [Array, Function],
      default: defaultPropFactory("hideTriggers")
    },
    popperTriggers: {
      type: Array,
      default: defaultPropFactory("popperTriggers")
    },
    popperShowTriggers: {
      type: [Array, Function],
      default: defaultPropFactory("popperShowTriggers")
    },
    popperHideTriggers: {
      type: [Array, Function],
      default: defaultPropFactory("popperHideTriggers")
    },
    container: {
      type: [String, Object, Element$1, Boolean],
      default: defaultPropFactory("container")
    },
    boundary: {
      type: [String, Element$1],
      default: defaultPropFactory("boundary")
    },
    strategy: {
      type: String,
      validator: (value) => ["absolute", "fixed"].includes(value),
      default: defaultPropFactory("strategy")
    },
    autoHide: {
      type: [Boolean, Function],
      default: defaultPropFactory("autoHide")
    },
    handleResize: {
      type: Boolean,
      default: defaultPropFactory("handleResize")
    },
    instantMove: {
      type: Boolean,
      default: defaultPropFactory("instantMove")
    },
    eagerMount: {
      type: Boolean,
      default: defaultPropFactory("eagerMount")
    },
    popperClass: {
      type: [String, Array, Object],
      default: defaultPropFactory("popperClass")
    },
    computeTransformOrigin: {
      type: Boolean,
      default: defaultPropFactory("computeTransformOrigin")
    },
    autoMinSize: {
      type: Boolean,
      default: defaultPropFactory("autoMinSize")
    },
    autoSize: {
      type: [Boolean, String],
      default: defaultPropFactory("autoSize")
    },
    autoMaxSize: {
      type: Boolean,
      default: defaultPropFactory("autoMaxSize")
    },
    autoBoundaryMaxSize: {
      type: Boolean,
      default: defaultPropFactory("autoBoundaryMaxSize")
    },
    preventOverflow: {
      type: Boolean,
      default: defaultPropFactory("preventOverflow")
    },
    overflowPadding: {
      type: [Number, String],
      default: defaultPropFactory("overflowPadding")
    },
    arrowPadding: {
      type: [Number, String],
      default: defaultPropFactory("arrowPadding")
    },
    arrowOverflow: {
      type: Boolean,
      default: defaultPropFactory("arrowOverflow")
    },
    flip: {
      type: Boolean,
      default: defaultPropFactory("flip")
    },
    shift: {
      type: Boolean,
      default: defaultPropFactory("shift")
    },
    shiftCrossAxis: {
      type: Boolean,
      default: defaultPropFactory("shiftCrossAxis")
    },
    noAutoFocus: {
      type: Boolean,
      default: defaultPropFactory("noAutoFocus")
    }
  },
  provide() {
    return {
      [PROVIDE_KEY]: {
        parentPopper: this
      }
    };
  },
  inject: {
    [PROVIDE_KEY]: { default: null }
  },
  data() {
    return {
      isShown: false,
      isMounted: false,
      skipTransition: false,
      classes: {
        showFrom: false,
        showTo: false,
        hideFrom: false,
        hideTo: true
      },
      result: {
        x: 0,
        y: 0,
        placement: "",
        strategy: this.strategy,
        arrow: {
          x: 0,
          y: 0,
          centerOffset: 0
        },
        transformOrigin: null
      },
      shownChildren: /* @__PURE__ */ new Set(),
      lastAutoHide: true
    };
  },
  computed: {
    popperId() {
      return this.ariaId != null ? this.ariaId : this.randomId;
    },
    shouldMountContent() {
      return this.eagerMount || this.isMounted;
    },
    slotData() {
      return {
        popperId: this.popperId,
        isShown: this.isShown,
        shouldMountContent: this.shouldMountContent,
        skipTransition: this.skipTransition,
        autoHide: typeof this.autoHide === "function" ? this.lastAutoHide : this.autoHide,
        show: this.show,
        hide: this.hide,
        handleResize: this.handleResize,
        onResize: this.onResize,
        classes: __spreadProps(__spreadValues({}, this.classes), {
          popperClass: this.popperClass
        }),
        result: this.positioningDisabled ? null : this.result
      };
    },
    parentPopper() {
      var _a2;
      return (_a2 = this[PROVIDE_KEY]) == null ? void 0 : _a2.parentPopper;
    },
    hasPopperShowTriggerHover() {
      var _a2, _b;
      return ((_a2 = this.popperTriggers) == null ? void 0 : _a2.includes("hover")) || ((_b = this.popperShowTriggers) == null ? void 0 : _b.includes("hover"));
    }
  },
  watch: __spreadValues(__spreadValues({
    shown: "$_autoShowHide",
    disabled(value) {
      if (value) {
        this.dispose();
      } else {
        this.init();
      }
    },
    async container() {
      if (this.isShown) {
        this.$_ensureTeleport();
        await this.$_computePosition();
      }
    }
  }, [
    "triggers",
    "positioningDisabled"
  ].reduce((acc, prop) => {
    acc[prop] = "$_refreshListeners";
    return acc;
  }, {})), [
    "placement",
    "distance",
    "skidding",
    "boundary",
    "strategy",
    "overflowPadding",
    "arrowPadding",
    "preventOverflow",
    "shift",
    "shiftCrossAxis",
    "flip"
  ].reduce((acc, prop) => {
    acc[prop] = "$_computePosition";
    return acc;
  }, {})),
  created() {
    this.$_isDisposed = true;
    this.randomId = `popper_${[Math.random(), Date.now()].map((n2) => n2.toString(36).substring(2, 10)).join("_")}`;
    if (this.autoMinSize) {
      console.warn('[floating-vue] `autoMinSize` option is deprecated. Use `autoSize="min"` instead.');
    }
    if (this.autoMaxSize) {
      console.warn("[floating-vue] `autoMaxSize` option is deprecated. Use `autoBoundaryMaxSize` instead.");
    }
  },
  mounted() {
    this.init();
    this.$_detachPopperNode();
  },
  activated() {
    this.$_autoShowHide();
  },
  deactivated() {
    this.hide();
  },
  beforeDestroy() {
    this.dispose();
  },
  methods: {
    show({ event = null, skipDelay = false, force = false } = {}) {
      var _a2, _b;
      if (((_a2 = this.parentPopper) == null ? void 0 : _a2.lockedChild) && this.parentPopper.lockedChild !== this)
        return;
      this.$_pendingHide = false;
      if (force || !this.disabled) {
        if (((_b = this.parentPopper) == null ? void 0 : _b.lockedChild) === this) {
          this.parentPopper.lockedChild = null;
        }
        this.$_scheduleShow(event, skipDelay);
        this.$emit("show");
        this.$_showFrameLocked = true;
        requestAnimationFrame(() => {
          this.$_showFrameLocked = false;
        });
      }
      this.$emit("update:shown", true);
    },
    hide({ event = null, skipDelay = false, skipAiming = false } = {}) {
      var _a2;
      if (this.$_hideInProgress)
        return;
      if (this.shownChildren.size > 0) {
        this.$_pendingHide = true;
        return;
      }
      if (!skipAiming && this.hasPopperShowTriggerHover && this.$_isAimingPopper()) {
        if (this.parentPopper) {
          this.parentPopper.lockedChild = this;
          clearTimeout(this.parentPopper.lockedChildTimer);
          this.parentPopper.lockedChildTimer = setTimeout(() => {
            if (this.parentPopper.lockedChild === this) {
              this.parentPopper.lockedChild.hide({ skipDelay });
              this.parentPopper.lockedChild = null;
            }
          }, 1e3);
        }
        return;
      }
      if (((_a2 = this.parentPopper) == null ? void 0 : _a2.lockedChild) === this) {
        this.parentPopper.lockedChild = null;
      }
      this.$_pendingHide = false;
      this.$_scheduleHide(event, skipDelay);
      this.$emit("hide");
      this.$emit("update:shown", false);
    },
    init() {
      if (!this.$_isDisposed)
        return;
      this.$_isDisposed = false;
      this.isMounted = false;
      this.$_events = [];
      this.$_preventShow = false;
      this.$_referenceNode = this.referenceNode();
      this.$_targetNodes = this.targetNodes().filter((e) => e.nodeType === e.ELEMENT_NODE);
      this.$_popperNode = this.popperNode();
      this.$_innerNode = this.$_popperNode.querySelector(".v-popper__inner");
      this.$_arrowNode = this.$_popperNode.querySelector(".v-popper__arrow-container");
      this.$_swapTargetAttrs("title", "data-original-title");
      this.$_detachPopperNode();
      if (this.triggers.length) {
        this.$_addEventListeners();
      }
      if (this.shown) {
        this.show();
      }
    },
    dispose() {
      if (this.$_isDisposed)
        return;
      this.$_isDisposed = true;
      this.$_removeEventListeners();
      this.hide({ skipDelay: true });
      this.$_detachPopperNode();
      this.isMounted = false;
      this.isShown = false;
      this.$_updateParentShownChildren(false);
      this.$_swapTargetAttrs("data-original-title", "title");
      this.$emit("dispose");
    },
    async onResize() {
      if (this.isShown) {
        await this.$_computePosition();
        this.$emit("resize");
      }
    },
    async $_computePosition() {
      var _a2;
      if (this.$_isDisposed || this.positioningDisabled)
        return;
      const options2 = {
        strategy: this.strategy,
        middleware: []
      };
      if (this.distance || this.skidding) {
        options2.middleware.push(offset({
          mainAxis: this.distance,
          crossAxis: this.skidding
        }));
      }
      const isPlacementAuto = this.placement.startsWith("auto");
      if (isPlacementAuto) {
        options2.middleware.push(autoPlacement({
          alignment: (_a2 = this.placement.split("-")[1]) != null ? _a2 : ""
        }));
      } else {
        options2.placement = this.placement;
      }
      if (this.preventOverflow) {
        if (this.shift) {
          options2.middleware.push(shift({
            padding: this.overflowPadding,
            boundary: this.boundary,
            crossAxis: this.shiftCrossAxis
          }));
        }
        if (!isPlacementAuto && this.flip) {
          options2.middleware.push(flip({
            padding: this.overflowPadding,
            boundary: this.boundary
          }));
        }
      }
      options2.middleware.push(arrow({
        element: this.$_arrowNode,
        padding: this.arrowPadding
      }));
      if (this.arrowOverflow) {
        options2.middleware.push({
          name: "arrowOverflow",
          fn: ({ placement, rects, middlewareData }) => {
            let overflow;
            const { centerOffset } = middlewareData.arrow;
            if (placement.startsWith("top") || placement.startsWith("bottom")) {
              overflow = Math.abs(centerOffset) > rects.reference.width / 2;
            } else {
              overflow = Math.abs(centerOffset) > rects.reference.height / 2;
            }
            return {
              data: {
                overflow
              }
            };
          }
        });
      }
      if (this.autoMinSize || this.autoSize) {
        const autoSize = this.autoSize ? this.autoSize : this.autoMinSize ? "min" : null;
        options2.middleware.push({
          name: "autoSize",
          fn: ({ rects, placement, middlewareData }) => {
            var _a22;
            if ((_a22 = middlewareData.autoSize) == null ? void 0 : _a22.skip) {
              return {};
            }
            let width;
            let height;
            if (placement.startsWith("top") || placement.startsWith("bottom")) {
              width = rects.reference.width;
            } else {
              height = rects.reference.height;
            }
            this.$_innerNode.style[autoSize === "min" ? "minWidth" : autoSize === "max" ? "maxWidth" : "width"] = width != null ? `${width}px` : null;
            this.$_innerNode.style[autoSize === "min" ? "minHeight" : autoSize === "max" ? "maxHeight" : "height"] = height != null ? `${height}px` : null;
            return {
              data: {
                skip: true
              },
              reset: {
                rects: true
              }
            };
          }
        });
      }
      if (this.autoMaxSize || this.autoBoundaryMaxSize) {
        this.$_innerNode.style.maxWidth = null;
        this.$_innerNode.style.maxHeight = null;
        options2.middleware.push(size({
          boundary: this.boundary,
          padding: this.overflowPadding,
          apply: ({ width, height }) => {
            this.$_innerNode.style.maxWidth = width != null ? `${width}px` : null;
            this.$_innerNode.style.maxHeight = height != null ? `${height}px` : null;
          }
        }));
      }
      const data = await computePosition(this.$_referenceNode, this.$_popperNode, options2);
      Object.assign(this.result, {
        x: data.x,
        y: data.y,
        placement: data.placement,
        strategy: data.strategy,
        arrow: __spreadValues(__spreadValues({}, data.middlewareData.arrow), data.middlewareData.arrowOverflow)
      });
    },
    $_scheduleShow(event = null, skipDelay = false) {
      this.$_updateParentShownChildren(true);
      this.$_hideInProgress = false;
      clearTimeout(this.$_scheduleTimer);
      if (hidingPopper && this.instantMove && hidingPopper.instantMove && hidingPopper !== this.parentPopper) {
        hidingPopper.$_applyHide(true);
        this.$_applyShow(true);
        return;
      }
      if (skipDelay) {
        this.$_applyShow();
      } else {
        this.$_scheduleTimer = setTimeout(this.$_applyShow.bind(this), this.$_computeDelay("show"));
      }
    },
    $_scheduleHide(event = null, skipDelay = false) {
      if (this.shownChildren.size > 0) {
        this.$_pendingHide = true;
        return;
      }
      this.$_updateParentShownChildren(false);
      this.$_hideInProgress = true;
      clearTimeout(this.$_scheduleTimer);
      if (this.isShown) {
        hidingPopper = this;
      }
      if (skipDelay) {
        this.$_applyHide();
      } else {
        this.$_scheduleTimer = setTimeout(this.$_applyHide.bind(this), this.$_computeDelay("hide"));
      }
    },
    $_computeDelay(type) {
      const delay3 = this.delay;
      return parseInt(delay3 && delay3[type] || delay3 || 0);
    },
    async $_applyShow(skipTransition = false) {
      clearTimeout(this.$_disposeTimer);
      clearTimeout(this.$_scheduleTimer);
      this.skipTransition = skipTransition;
      if (this.isShown) {
        return;
      }
      this.$_ensureTeleport();
      await nextFrame();
      await this.$_computePosition();
      await this.$_applyShowEffect();
      if (!this.positioningDisabled) {
        this.$_registerEventListeners([
          ...getScrollParents(this.$_referenceNode),
          ...getScrollParents(this.$_popperNode)
        ], "scroll", () => {
          this.$_computePosition();
        });
      }
    },
    async $_applyShowEffect() {
      if (this.$_hideInProgress)
        return;
      if (this.computeTransformOrigin) {
        const bounds = this.$_referenceNode.getBoundingClientRect();
        const popperWrapper = this.$_popperNode.querySelector(".v-popper__wrapper");
        const parentBounds = popperWrapper.parentNode.getBoundingClientRect();
        const x = bounds.x + bounds.width / 2 - (parentBounds.left + popperWrapper.offsetLeft);
        const y = bounds.y + bounds.height / 2 - (parentBounds.top + popperWrapper.offsetTop);
        this.result.transformOrigin = `${x}px ${y}px`;
      }
      this.isShown = true;
      this.$_applyAttrsToTarget({
        "aria-describedby": this.popperId,
        "data-popper-shown": ""
      });
      const showGroup = this.showGroup;
      if (showGroup) {
        let popover;
        for (let i = 0; i < shownPoppers.length; i++) {
          popover = shownPoppers[i];
          if (popover.showGroup !== showGroup) {
            popover.hide();
            popover.$emit("close-group");
          }
        }
      }
      shownPoppers.push(this);
      document.body.classList.add("v-popper--some-open");
      for (const theme of getAllParentThemes(this.theme)) {
        getShownPoppersByTheme(theme).push(this);
        document.body.classList.add(`v-popper--some-open--${theme}`);
      }
      this.$emit("apply-show");
      this.classes.showFrom = true;
      this.classes.showTo = false;
      this.classes.hideFrom = false;
      this.classes.hideTo = false;
      await nextFrame();
      this.classes.showFrom = false;
      this.classes.showTo = true;
      if (!this.noAutoFocus)
        this.$_popperNode.focus();
    },
    async $_applyHide(skipTransition = false) {
      if (this.shownChildren.size > 0) {
        this.$_pendingHide = true;
        this.$_hideInProgress = false;
        return;
      }
      clearTimeout(this.$_scheduleTimer);
      if (!this.isShown) {
        return;
      }
      this.skipTransition = skipTransition;
      removeFromArray(shownPoppers, this);
      if (shownPoppers.length === 0) {
        document.body.classList.remove("v-popper--some-open");
      }
      for (const theme of getAllParentThemes(this.theme)) {
        const list = getShownPoppersByTheme(theme);
        removeFromArray(list, this);
        if (list.length === 0) {
          document.body.classList.remove(`v-popper--some-open--${theme}`);
        }
      }
      if (hidingPopper === this) {
        hidingPopper = null;
      }
      this.isShown = false;
      this.$_applyAttrsToTarget({
        "aria-describedby": void 0,
        "data-popper-shown": void 0
      });
      clearTimeout(this.$_disposeTimer);
      const disposeTime = getDefaultConfig(this.theme, "disposeTimeout");
      if (disposeTime !== null) {
        this.$_disposeTimer = setTimeout(() => {
          if (this.$_popperNode) {
            this.$_detachPopperNode();
            this.isMounted = false;
          }
        }, disposeTime);
      }
      this.$_removeEventListeners("scroll");
      this.$emit("apply-hide");
      this.classes.showFrom = false;
      this.classes.showTo = false;
      this.classes.hideFrom = true;
      this.classes.hideTo = false;
      await nextFrame();
      this.classes.hideFrom = false;
      this.classes.hideTo = true;
    },
    $_autoShowHide() {
      if (this.shown) {
        this.show();
      } else {
        this.hide();
      }
    },
    $_ensureTeleport() {
      if (this.$_isDisposed)
        return;
      let container = this.container;
      if (typeof container === "string") {
        container = window.document.querySelector(container);
      } else if (container === false) {
        container = this.$_targetNodes[0].parentNode;
      }
      if (!container) {
        throw new Error("No container for popover: " + this.container);
      }
      container.appendChild(this.$_popperNode);
      this.isMounted = true;
    },
    $_addEventListeners() {
      const handleShow = (event) => {
        if (this.isShown && !this.$_hideInProgress) {
          return;
        }
        event.usedByTooltip = true;
        !this.$_preventShow && this.show({ event });
      };
      this.$_registerTriggerListeners(this.$_targetNodes, SHOW_EVENT_MAP, this.triggers, this.showTriggers, handleShow);
      this.$_registerTriggerListeners([this.$_popperNode], SHOW_EVENT_MAP, this.popperTriggers, this.popperShowTriggers, handleShow);
      const handleHide = (skipAiming) => (event) => {
        if (event.usedByTooltip) {
          return;
        }
        this.hide({ event, skipAiming });
      };
      this.$_registerTriggerListeners(this.$_targetNodes, HIDE_EVENT_MAP, this.triggers, this.hideTriggers, handleHide(false));
      this.$_registerTriggerListeners([this.$_popperNode], HIDE_EVENT_MAP, this.popperTriggers, this.popperHideTriggers, handleHide(true));
    },
    $_registerEventListeners(targetNodes, eventType, handler) {
      this.$_events.push({ targetNodes, eventType, handler });
      targetNodes.forEach((node) => node.addEventListener(eventType, handler, supportsPassive ? {
        passive: true
      } : void 0));
    },
    $_registerTriggerListeners(targetNodes, eventMap, commonTriggers, customTrigger, handler) {
      let triggers = commonTriggers;
      if (customTrigger != null) {
        triggers = typeof customTrigger === "function" ? customTrigger(triggers) : customTrigger;
      }
      triggers.forEach((trigger2) => {
        const eventType = eventMap[trigger2];
        if (eventType) {
          this.$_registerEventListeners(targetNodes, eventType, handler);
        }
      });
    },
    $_removeEventListeners(filterEventType) {
      const newList = [];
      this.$_events.forEach((listener) => {
        const { targetNodes, eventType, handler } = listener;
        if (!filterEventType || filterEventType === eventType) {
          targetNodes.forEach((node) => node.removeEventListener(eventType, handler));
        } else {
          newList.push(listener);
        }
      });
      this.$_events = newList;
    },
    $_refreshListeners() {
      if (!this.$_isDisposed) {
        this.$_removeEventListeners();
        this.$_addEventListeners();
      }
    },
    $_handleGlobalClose(event, touch = false) {
      if (this.$_showFrameLocked)
        return;
      this.hide({ event });
      if (event.closePopover) {
        this.$emit("close-directive");
      } else {
        this.$emit("auto-hide");
      }
      if (touch) {
        this.$_preventShow = true;
        setTimeout(() => {
          this.$_preventShow = false;
        }, 300);
      }
    },
    $_detachPopperNode() {
      this.$_popperNode.parentNode && this.$_popperNode.parentNode.removeChild(this.$_popperNode);
    },
    $_swapTargetAttrs(attrFrom, attrTo) {
      for (const el of this.$_targetNodes) {
        const value = el.getAttribute(attrFrom);
        if (value) {
          el.removeAttribute(attrFrom);
          el.setAttribute(attrTo, value);
        }
      }
    },
    $_applyAttrsToTarget(attrs2) {
      for (const el of this.$_targetNodes) {
        for (const n2 in attrs2) {
          const value = attrs2[n2];
          if (value == null) {
            el.removeAttribute(n2);
          } else {
            el.setAttribute(n2, value);
          }
        }
      }
    },
    $_updateParentShownChildren(value) {
      let parent = this.parentPopper;
      while (parent) {
        if (value) {
          parent.shownChildren.add(this.randomId);
        } else {
          parent.shownChildren.delete(this.randomId);
          if (parent.$_pendingHide) {
            parent.hide();
          }
        }
        parent = parent.parentPopper;
      }
    },
    $_isAimingPopper() {
      const referenceBounds = this.$el.getBoundingClientRect();
      if (mouseX >= referenceBounds.left && mouseX <= referenceBounds.right && mouseY >= referenceBounds.top && mouseY <= referenceBounds.bottom) {
        const popperBounds = this.$_popperNode.getBoundingClientRect();
        const vectorX = mouseX - mousePreviousX;
        const vectorY = mouseY - mousePreviousY;
        const distance = popperBounds.left + popperBounds.width / 2 - mousePreviousX + (popperBounds.top + popperBounds.height / 2) - mousePreviousY;
        const newVectorLength = distance + popperBounds.width + popperBounds.height;
        const edgeX = mousePreviousX + vectorX * newVectorLength;
        const edgeY = mousePreviousY + vectorY * newVectorLength;
        return lineIntersectsLine(mousePreviousX, mousePreviousY, edgeX, edgeY, popperBounds.left, popperBounds.top, popperBounds.left, popperBounds.bottom) || lineIntersectsLine(mousePreviousX, mousePreviousY, edgeX, edgeY, popperBounds.left, popperBounds.top, popperBounds.right, popperBounds.top) || lineIntersectsLine(mousePreviousX, mousePreviousY, edgeX, edgeY, popperBounds.right, popperBounds.top, popperBounds.right, popperBounds.bottom) || lineIntersectsLine(mousePreviousX, mousePreviousY, edgeX, edgeY, popperBounds.left, popperBounds.bottom, popperBounds.right, popperBounds.bottom);
      }
      return false;
    }
  },
  render() {
    return this.$scopedSlots.default(this.slotData)[0];
  }
});
if (typeof document !== "undefined" && typeof window !== "undefined") {
  if (isIOS) {
    document.addEventListener("touchstart", handleGlobalMousedown, supportsPassive ? {
      passive: true,
      capture: true
    } : true);
    document.addEventListener("touchend", handleGlobalTouchend, supportsPassive ? {
      passive: true,
      capture: true
    } : true);
  } else {
    window.addEventListener("mousedown", handleGlobalMousedown, true);
    window.addEventListener("click", handleGlobalClick, true);
  }
  window.addEventListener("resize", computePositionAllShownPoppers);
}
function handleGlobalMousedown(event) {
  for (let i = 0; i < shownPoppers.length; i++) {
    const popper = shownPoppers[i];
    try {
      const popperContent = popper.popperNode();
      popper.$_mouseDownContains = popperContent.contains(event.target);
    } catch (e) {
    }
  }
}
function handleGlobalClick(event) {
  handleGlobalClose(event);
}
function handleGlobalTouchend(event) {
  handleGlobalClose(event, true);
}
function handleGlobalClose(event, touch = false) {
  const preventClose = {};
  for (let i = shownPoppers.length - 1; i >= 0; i--) {
    const popper = shownPoppers[i];
    try {
      const contains2 = popper.$_containsGlobalTarget = isContainingEventTarget(popper, event);
      popper.$_pendingHide = false;
      requestAnimationFrame(() => {
        popper.$_pendingHide = false;
        if (preventClose[popper.randomId])
          return;
        if (shouldAutoHide(popper, contains2, event)) {
          popper.$_handleGlobalClose(event, touch);
          if (!event.closeAllPopover && event.closePopover && contains2) {
            let parent2 = popper.parentPopper;
            while (parent2) {
              preventClose[parent2.randomId] = true;
              parent2 = parent2.parentPopper;
            }
            return;
          }
          let parent = popper.parentPopper;
          while (parent) {
            if (shouldAutoHide(parent, parent.$_containsGlobalTarget, event)) {
              parent.$_handleGlobalClose(event, touch);
            } else {
              break;
            }
            parent = parent.parentPopper;
          }
        }
      });
    } catch (e) {
    }
  }
}
function isContainingEventTarget(popper, event) {
  const popperContent = popper.popperNode();
  return popper.$_mouseDownContains || popperContent.contains(event.target);
}
function shouldAutoHide(popper, contains2, event) {
  return event.closeAllPopover || event.closePopover && contains2 || getAutoHideResult(popper, event) && !contains2;
}
function getAutoHideResult(popper, event) {
  if (typeof popper.autoHide === "function") {
    const result = popper.autoHide(event);
    popper.lastAutoHide = result;
    return result;
  }
  return popper.autoHide;
}
function computePositionAllShownPoppers(event) {
  for (let i = 0; i < shownPoppers.length; i++) {
    const popper = shownPoppers[i];
    popper.$_computePosition(event);
  }
}
let mousePreviousX = 0;
let mousePreviousY = 0;
let mouseX = 0;
let mouseY = 0;
if (typeof window !== "undefined") {
  window.addEventListener("mousemove", (event) => {
    mousePreviousX = mouseX;
    mousePreviousY = mouseY;
    mouseX = event.clientX;
    mouseY = event.clientY;
  }, supportsPassive ? {
    passive: true
  } : void 0);
}
function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
  const uA = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
  const uB = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
  return uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1;
}
function getInternetExplorerVersion() {
  var ua = window.navigator.userAgent;
  var msie = ua.indexOf("MSIE ");
  if (msie > 0) {
    return parseInt(ua.substring(msie + 5, ua.indexOf(".", msie)), 10);
  }
  var trident = ua.indexOf("Trident/");
  if (trident > 0) {
    var rv = ua.indexOf("rv:");
    return parseInt(ua.substring(rv + 3, ua.indexOf(".", rv)), 10);
  }
  var edge = ua.indexOf("Edge/");
  if (edge > 0) {
    return parseInt(ua.substring(edge + 5, ua.indexOf(".", edge)), 10);
  }
  return -1;
}
var isIE;
function initCompat() {
  if (!initCompat.init) {
    initCompat.init = true;
    isIE = getInternetExplorerVersion() !== -1;
  }
}
var script = {
  name: "ResizeObserver",
  props: {
    emitOnMount: {
      type: Boolean,
      default: false
    },
    ignoreWidth: {
      type: Boolean,
      default: false
    },
    ignoreHeight: {
      type: Boolean,
      default: false
    }
  },
  mounted: function mounted() {
    var _this = this;
    initCompat();
    this.$nextTick(function() {
      _this._w = _this.$el.offsetWidth;
      _this._h = _this.$el.offsetHeight;
      if (_this.emitOnMount) {
        _this.emitSize();
      }
    });
    var object = document.createElement("object");
    this._resizeObject = object;
    object.setAttribute("aria-hidden", "true");
    object.setAttribute("tabindex", -1);
    object.onload = this.addResizeHandlers;
    object.type = "text/html";
    if (isIE) {
      this.$el.appendChild(object);
    }
    object.data = "about:blank";
    if (!isIE) {
      this.$el.appendChild(object);
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.removeResizeHandlers();
  },
  methods: {
    compareAndNotify: function compareAndNotify() {
      if (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) {
        this._w = this.$el.offsetWidth;
        this._h = this.$el.offsetHeight;
        this.emitSize();
      }
    },
    emitSize: function emitSize() {
      this.$emit("notify", {
        width: this._w,
        height: this._h
      });
    },
    addResizeHandlers: function addResizeHandlers() {
      this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify);
      this.compareAndNotify();
    },
    removeResizeHandlers: function removeResizeHandlers() {
      if (this._resizeObject && this._resizeObject.onload) {
        if (!isIE && this._resizeObject.contentDocument) {
          this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify);
        }
        this.$el.removeChild(this._resizeObject);
        this._resizeObject.onload = null;
        this._resizeObject = null;
      }
    }
  }
};
function normalizeComponent$1(template, style2, script2, scopeId, isFunctionalTemplate, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  var options2 = typeof script2 === "function" ? script2.options : script2;
  if (template && template.render) {
    options2.render = template.render;
    options2.staticRenderFns = template.staticRenderFns;
    options2._compiled = true;
  }
  {
    options2._scopeId = scopeId;
  }
  return script2;
}
var __vue_script__ = script;
var __vue_render__ = function __vue_render__2() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", {
    staticClass: "resize-observer",
    attrs: {
      tabindex: "-1"
    }
  });
};
var __vue_staticRenderFns__ = [];
__vue_render__._withStripped = true;
var __vue_inject_styles__ = void 0;
var __vue_scope_id__ = "data-v-8859cc6c";
var __vue_component__ = /* @__PURE__ */ normalizeComponent$1({
  render: __vue_render__,
  staticRenderFns: __vue_staticRenderFns__
}, __vue_inject_styles__, __vue_script__, __vue_scope_id__);
function install$1(Vue2) {
  Vue2.component("resize-observer", __vue_component__);
  Vue2.component("ResizeObserver", __vue_component__);
}
var plugin$1 = {
  version: "1.0.1",
  install: install$1
};
var GlobalVue$1 = null;
if (typeof window !== "undefined") {
  GlobalVue$1 = window.Vue;
} else if (typeof global$1 !== "undefined") {
  GlobalVue$1 = global$1.Vue;
}
if (GlobalVue$1) {
  GlobalVue$1.use(plugin$1);
}
var PrivateThemeClass = {
  computed: {
    themeClass() {
      return getThemeClasses(this.theme);
    }
  }
};
var __vue2_script$5 = {
  name: "VPopperContent",
  components: {
    ResizeObserver: __vue_component__
  },
  mixins: [
    PrivateThemeClass
  ],
  props: {
    popperId: String,
    theme: String,
    shown: Boolean,
    mounted: Boolean,
    skipTransition: Boolean,
    autoHide: Boolean,
    handleResize: Boolean,
    classes: Object,
    result: Object
  },
  methods: {
    toPx(value) {
      if (value != null && !isNaN(value)) {
        return `${value}px`;
      }
      return null;
    }
  }
};
var render$2 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { ref: "popover", staticClass: "v-popper__popper", class: [
    _vm.themeClass,
    _vm.classes.popperClass,
    {
      "v-popper__popper--shown": _vm.shown,
      "v-popper__popper--hidden": !_vm.shown,
      "v-popper__popper--show-from": _vm.classes.showFrom,
      "v-popper__popper--show-to": _vm.classes.showTo,
      "v-popper__popper--hide-from": _vm.classes.hideFrom,
      "v-popper__popper--hide-to": _vm.classes.hideTo,
      "v-popper__popper--skip-transition": _vm.skipTransition,
      "v-popper__popper--arrow-overflow": _vm.result && _vm.result.arrow.overflow,
      "v-popper__popper--no-positioning": !_vm.result
    }
  ], style: _vm.result ? {
    position: _vm.result.strategy,
    transform: "translate3d(" + Math.round(_vm.result.x) + "px," + Math.round(_vm.result.y) + "px,0)"
  } : void 0, attrs: { "id": _vm.popperId, "aria-hidden": _vm.shown ? "false" : "true", "tabindex": _vm.autoHide ? 0 : void 0, "data-popper-placement": _vm.result ? _vm.result.placement : void 0 }, on: { "keyup": function($event) {
    if (!$event.type.indexOf("key") && _vm._k($event.keyCode, "esc", 27, $event.key, ["Esc", "Escape"])) {
      return null;
    }
    _vm.autoHide && _vm.$emit("hide");
  } } }, [_c("div", { staticClass: "v-popper__backdrop", on: { "click": function($event) {
    _vm.autoHide && _vm.$emit("hide");
  } } }), _c("div", { staticClass: "v-popper__wrapper", style: _vm.result ? {
    transformOrigin: _vm.result.transformOrigin
  } : void 0 }, [_c("div", { ref: "inner", staticClass: "v-popper__inner" }, [_vm.mounted ? [_c("div", [_vm._t("default")], 2), _vm.handleResize ? _c("ResizeObserver", { on: { "notify": function($event) {
    return _vm.$emit("resize", $event);
  } } }) : _vm._e()] : _vm._e()], 2), _c("div", { ref: "arrow", staticClass: "v-popper__arrow-container", style: _vm.result ? {
    left: _vm.toPx(_vm.result.arrow.x),
    top: _vm.toPx(_vm.result.arrow.y)
  } : void 0 }, [_c("div", { staticClass: "v-popper__arrow-outer" }), _c("div", { staticClass: "v-popper__arrow-inner" })])])]);
};
var staticRenderFns$2 = [];
function normalizeComponent(scriptExports, render211, staticRenderFns2, functionalTemplate, injectStyles, scopeId, moduleIdentifier, shadowMode) {
  var options2 = typeof scriptExports === "function" ? scriptExports.options : scriptExports;
  if (render211) {
    options2.render = render211;
    options2.staticRenderFns = staticRenderFns2;
    options2._compiled = true;
  }
  var hook;
  if (injectStyles) {
    hook = injectStyles;
  }
  if (hook) {
    if (options2.functional) {
      options2._injectStyles = hook;
      var originalRender = options2.render;
      options2.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      var existing = options2.beforeCreate;
      options2.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }
  return {
    exports: scriptExports,
    options: options2
  };
}
const __cssModules$5 = {};
var __component__$5$1 = /* @__PURE__ */ normalizeComponent(__vue2_script$5, render$2, staticRenderFns$2, false, __vue2_injectStyles$5);
function __vue2_injectStyles$5(context) {
  for (let o in __cssModules$5) {
    this[o] = __cssModules$5[o];
  }
}
var PrivatePopperContent = /* @__PURE__ */ function() {
  return __component__$5$1.exports;
}();
var PrivatePopperMethods = {
  methods: {
    show(...args) {
      return this.$refs.popper.show(...args);
    },
    hide(...args) {
      return this.$refs.popper.hide(...args);
    },
    dispose(...args) {
      return this.$refs.popper.dispose(...args);
    },
    onResize(...args) {
      return this.$refs.popper.onResize(...args);
    }
  }
};
var __vue2_script$4 = {
  name: "VPopperWrapper",
  components: {
    Popper: PrivatePopper(),
    PopperContent: PrivatePopperContent
  },
  mixins: [
    PrivatePopperMethods,
    PrivateThemeClass
  ],
  inheritAttrs: false,
  props: {
    theme: {
      type: String,
      default() {
        return this.$options.vPopperTheme;
      }
    }
  },
  methods: {
    getTargetNodes() {
      return Array.from(this.$refs.reference.children).filter((node) => node !== this.$refs.popperContent.$el);
    }
  }
};
var render$1 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("Popper", _vm._g(_vm._b({ ref: "popper", attrs: { "theme": _vm.theme, "target-nodes": _vm.getTargetNodes, "reference-node": function() {
    return _vm.$refs.reference;
  }, "popper-node": function() {
    return _vm.$refs.popperContent.$el;
  } }, scopedSlots: _vm._u([{ key: "default", fn: function(ref2) {
    var popperId = ref2.popperId;
    var isShown = ref2.isShown;
    var shouldMountContent = ref2.shouldMountContent;
    var skipTransition = ref2.skipTransition;
    var autoHide = ref2.autoHide;
    var show2 = ref2.show;
    var hide = ref2.hide;
    var handleResize = ref2.handleResize;
    var onResize = ref2.onResize;
    var classes = ref2.classes;
    var result = ref2.result;
    return [_c("div", { ref: "reference", staticClass: "v-popper", class: [
      _vm.themeClass,
      {
        "v-popper--shown": isShown
      }
    ] }, [_vm._t("default", null, { "shown": isShown, "show": show2, "hide": hide }), _c("PopperContent", { ref: "popperContent", attrs: { "popper-id": popperId, "theme": _vm.theme, "shown": isShown, "mounted": shouldMountContent, "skip-transition": skipTransition, "auto-hide": autoHide, "handle-resize": handleResize, "classes": classes, "result": result }, on: { "hide": hide, "resize": onResize } }, [_vm._t("popper", null, { "shown": isShown, "hide": hide })], 2)], 2)];
  } }], null, true) }, "Popper", _vm.$attrs, false), _vm.$listeners));
};
var staticRenderFns$1 = [];
const __cssModules$4 = {};
var __component__$4$1 = /* @__PURE__ */ normalizeComponent(__vue2_script$4, render$1, staticRenderFns$1, false, __vue2_injectStyles$4);
function __vue2_injectStyles$4(context) {
  for (let o in __cssModules$4) {
    this[o] = __cssModules$4[o];
  }
}
var PrivatePopperWrapper = /* @__PURE__ */ function() {
  return __component__$4$1.exports;
}();
var __vue2_script$3 = __spreadProps(__spreadValues({}, PrivatePopperWrapper), {
  name: "VDropdown",
  vPopperTheme: "dropdown"
});
let __vue2_render$2, __vue2_staticRenderFns$2;
const __cssModules$3 = {};
var __component__$3$1 = /* @__PURE__ */ normalizeComponent(__vue2_script$3, __vue2_render$2, __vue2_staticRenderFns$2, false, __vue2_injectStyles$3);
function __vue2_injectStyles$3(context) {
  for (let o in __cssModules$3) {
    this[o] = __cssModules$3[o];
  }
}
var PrivateDropdown = /* @__PURE__ */ function() {
  return __component__$3$1.exports;
}();
var __vue2_script$2 = __spreadProps(__spreadValues({}, PrivatePopperWrapper), {
  name: "VMenu",
  vPopperTheme: "menu"
});
let __vue2_render$1, __vue2_staticRenderFns$1;
const __cssModules$2 = {};
var __component__$2$2 = /* @__PURE__ */ normalizeComponent(__vue2_script$2, __vue2_render$1, __vue2_staticRenderFns$1, false, __vue2_injectStyles$2);
function __vue2_injectStyles$2(context) {
  for (let o in __cssModules$2) {
    this[o] = __cssModules$2[o];
  }
}
var PrivateMenu = /* @__PURE__ */ function() {
  return __component__$2$2.exports;
}();
var __vue2_script$1 = __spreadProps(__spreadValues({}, PrivatePopperWrapper), {
  name: "VTooltip",
  vPopperTheme: "tooltip"
});
let __vue2_render, __vue2_staticRenderFns;
const __cssModules$1 = {};
var __component__$1$3 = /* @__PURE__ */ normalizeComponent(__vue2_script$1, __vue2_render, __vue2_staticRenderFns, false, __vue2_injectStyles$1);
function __vue2_injectStyles$1(context) {
  for (let o in __cssModules$1) {
    this[o] = __cssModules$1[o];
  }
}
var PrivateTooltip = /* @__PURE__ */ function() {
  return __component__$1$3.exports;
}();
var __vue2_script = {
  name: "VTooltipDirective",
  components: {
    Popper: PrivatePopper(),
    PopperContent: PrivatePopperContent
  },
  mixins: [
    PrivatePopperMethods
  ],
  inheritAttrs: false,
  props: {
    theme: {
      type: String,
      default: "tooltip"
    },
    html: {
      type: Boolean,
      default() {
        return getDefaultConfig(this.theme, "html");
      }
    },
    content: {
      type: [String, Number, Function],
      default: null
    },
    loadingContent: {
      type: String,
      default() {
        return getDefaultConfig(this.theme, "loadingContent");
      }
    }
  },
  data() {
    return {
      asyncContent: null
    };
  },
  computed: {
    isContentAsync() {
      return typeof this.content === "function";
    },
    loading() {
      return this.isContentAsync && this.asyncContent == null;
    },
    finalContent() {
      if (this.isContentAsync) {
        return this.loading ? this.loadingContent : this.asyncContent;
      }
      return this.content;
    }
  },
  watch: {
    content: {
      handler() {
        this.fetchContent(true);
      },
      immediate: true
    },
    async finalContent(value) {
      await this.$nextTick();
      this.$refs.popper.onResize();
    }
  },
  created() {
    this.$_fetchId = 0;
  },
  methods: {
    fetchContent(force) {
      if (typeof this.content === "function" && this.$_isShown && (force || !this.$_loading && this.asyncContent == null)) {
        this.asyncContent = null;
        this.$_loading = true;
        const fetchId = ++this.$_fetchId;
        const result = this.content(this);
        if (result.then) {
          result.then((res) => this.onResult(fetchId, res));
        } else {
          this.onResult(fetchId, result);
        }
      }
    },
    onResult(fetchId, result) {
      if (fetchId !== this.$_fetchId)
        return;
      this.$_loading = false;
      this.asyncContent = result;
    },
    onShow() {
      this.$_isShown = true;
      this.fetchContent();
    },
    onHide() {
      this.$_isShown = false;
    }
  }
};
var render38 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("Popper", _vm._g(_vm._b({ ref: "popper", attrs: { "theme": _vm.theme, "popper-node": function() {
    return _vm.$refs.popperContent.$el;
  } }, on: { "apply-show": _vm.onShow, "apply-hide": _vm.onHide }, scopedSlots: _vm._u([{ key: "default", fn: function(ref2) {
    var popperId = ref2.popperId;
    var isShown = ref2.isShown;
    var shouldMountContent = ref2.shouldMountContent;
    var skipTransition = ref2.skipTransition;
    var autoHide = ref2.autoHide;
    var hide = ref2.hide;
    var handleResize = ref2.handleResize;
    var onResize = ref2.onResize;
    var classes = ref2.classes;
    var result = ref2.result;
    return [_c("PopperContent", { ref: "popperContent", class: {
      "v-popper--tooltip-loading": _vm.loading
    }, attrs: { "popper-id": popperId, "theme": _vm.theme, "shown": isShown, "mounted": shouldMountContent, "skip-transition": skipTransition, "auto-hide": autoHide, "handle-resize": handleResize, "classes": classes, "result": result }, on: { "hide": hide, "resize": onResize } }, [_vm.html ? _c("div", { domProps: { "innerHTML": _vm._s(_vm.finalContent) } }) : _c("div", { domProps: { "textContent": _vm._s(_vm.finalContent) } })])];
  } }]) }, "Popper", _vm.$attrs, false), _vm.$listeners));
};
var staticRenderFns = [];
const __cssModules = {};
var __component__$s = /* @__PURE__ */ normalizeComponent(__vue2_script, render38, staticRenderFns, false, __vue2_injectStyles);
function __vue2_injectStyles(context) {
  for (let o in __cssModules) {
    this[o] = __cssModules[o];
  }
}
var PrivateTooltipDirective = /* @__PURE__ */ function() {
  return __component__$s.exports;
}();
const TARGET_CLASS = "v-popper--has-tooltip";
function getPlacement(options2, modifiers) {
  let result = options2.placement;
  if (!result && modifiers) {
    for (const pos of placements) {
      if (modifiers[pos]) {
        result = pos;
      }
    }
  }
  if (!result) {
    result = getDefaultConfig(options2.theme || "tooltip", "placement");
  }
  return result;
}
function getOptions(el, value, modifiers) {
  let options2;
  const type = typeof value;
  if (type === "string") {
    options2 = { content: value };
  } else if (value && type === "object") {
    options2 = value;
  } else {
    options2 = { content: false };
  }
  options2.placement = getPlacement(options2, modifiers);
  options2.targetNodes = () => [el];
  options2.referenceNode = () => el;
  return options2;
}
function createTooltip(el, value, modifiers) {
  const options2 = getOptions(el, value, modifiers);
  const tooltipApp = el.$_popper = new Vue({
    mixins: [
      PrivatePopperMethods
    ],
    data() {
      return {
        options: options2
      };
    },
    render(h) {
      const _a2 = this.options, {
        theme,
        html: html2,
        content,
        loadingContent
      } = _a2, otherOptions = __objRest(_a2, [
        "theme",
        "html",
        "content",
        "loadingContent"
      ]);
      return h(PrivateTooltipDirective, {
        props: {
          theme,
          html: html2,
          content,
          loadingContent
        },
        attrs: otherOptions,
        ref: "popper"
      });
    },
    devtools: {
      hide: true
    }
  });
  const mountTarget = document.createElement("div");
  document.body.appendChild(mountTarget);
  tooltipApp.$mount(mountTarget);
  if (el.classList) {
    el.classList.add(TARGET_CLASS);
  }
  return tooltipApp;
}
function destroyTooltip(el) {
  if (el.$_popper) {
    el.$_popper.$destroy();
    delete el.$_popper;
    delete el.$_popperOldShown;
  }
  if (el.classList) {
    el.classList.remove(TARGET_CLASS);
  }
}
function bind(el, { value, oldValue, modifiers }) {
  const options2 = getOptions(el, value, modifiers);
  if (!options2.content || getDefaultConfig(options2.theme || "tooltip", "disabled")) {
    destroyTooltip(el);
  } else {
    let tooltipApp;
    if (el.$_popper) {
      tooltipApp = el.$_popper;
      tooltipApp.options = options2;
    } else {
      tooltipApp = createTooltip(el, value, modifiers);
    }
    if (typeof value.shown !== "undefined" && value.shown !== el.$_popperOldShown) {
      el.$_popperOldShown = value.shown;
      value.shown ? tooltipApp.show() : tooltipApp.hide();
    }
  }
}
var PrivateVTooltip = {
  bind,
  update: bind,
  unbind(el) {
    destroyTooltip(el);
  }
};
function addListeners(el) {
  el.addEventListener("click", onClick);
  el.addEventListener("touchstart", onTouchStart, supportsPassive ? {
    passive: true
  } : false);
}
function removeListeners(el) {
  el.removeEventListener("click", onClick);
  el.removeEventListener("touchstart", onTouchStart);
  el.removeEventListener("touchend", onTouchEnd);
  el.removeEventListener("touchcancel", onTouchCancel);
}
function onClick(event) {
  const el = event.currentTarget;
  event.closePopover = !el.$_vclosepopover_touch;
  event.closeAllPopover = el.$_closePopoverModifiers && !!el.$_closePopoverModifiers.all;
}
function onTouchStart(event) {
  if (event.changedTouches.length === 1) {
    const el = event.currentTarget;
    el.$_vclosepopover_touch = true;
    const touch = event.changedTouches[0];
    el.$_vclosepopover_touchPoint = touch;
    el.addEventListener("touchend", onTouchEnd);
    el.addEventListener("touchcancel", onTouchCancel);
  }
}
function onTouchEnd(event) {
  const el = event.currentTarget;
  el.$_vclosepopover_touch = false;
  if (event.changedTouches.length === 1) {
    const touch = event.changedTouches[0];
    const firstTouch = el.$_vclosepopover_touchPoint;
    event.closePopover = Math.abs(touch.screenY - firstTouch.screenY) < 20 && Math.abs(touch.screenX - firstTouch.screenX) < 20;
    event.closeAllPopover = el.$_closePopoverModifiers && !!el.$_closePopoverModifiers.all;
  }
}
function onTouchCancel(event) {
  const el = event.currentTarget;
  el.$_vclosepopover_touch = false;
}
var PrivateVClosePopper = {
  bind(el, { value, modifiers }) {
    el.$_closePopoverModifiers = modifiers;
    if (typeof value === "undefined" || value) {
      addListeners(el);
    }
  },
  update(el, { value, oldValue, modifiers }) {
    el.$_closePopoverModifiers = modifiers;
    if (value !== oldValue) {
      if (typeof value === "undefined" || value) {
        addListeners(el);
      } else {
        removeListeners(el);
      }
    }
  },
  unbind(el) {
    removeListeners(el);
  }
};
const Dropdown = PrivateDropdown;
function install(app, options2 = {}) {
  if (app.$_vTooltipInstalled)
    return;
  app.$_vTooltipInstalled = true;
  assign(config, options2);
  app.directive("tooltip", PrivateVTooltip);
  app.directive("close-popper", PrivateVClosePopper);
  app.component("v-tooltip", PrivateTooltip);
  app.component("VTooltip", PrivateTooltip);
  app.component("v-dropdown", PrivateDropdown);
  app.component("VDropdown", PrivateDropdown);
  app.component("v-menu", PrivateMenu);
  app.component("VMenu", PrivateMenu);
}
const plugin = {
  version: "1.0.0-beta.19",
  install,
  options: config
};
let GlobalVue = null;
if (typeof window !== "undefined") {
  GlobalVue = window.Vue;
} else if (typeof global$1 !== "undefined") {
  GlobalVue = global$1.Vue;
}
if (GlobalVue) {
  GlobalVue.use(plugin);
}
const _sfc_main$1$2 = defineComponent({
  name: "NcPopoverTriggerProvider",
  provide() {
    return {
      "NcPopover:trigger:shown": () => this.shown,
      "NcPopover:trigger:attrs": () => this.triggerAttrs
    };
  },
  props: {
    shown: {
      type: Boolean,
      required: true
    },
    popupRole: {
      type: String,
      default: void 0
    }
  },
  computed: {
    triggerAttrs() {
      return {
        "aria-haspopup": this.popupRole,
        "aria-expanded": this.shown.toString()
      };
    }
  },
  render() {
    return this.$scopedSlots.default?.({
      attrs: this.triggerAttrs
    });
  }
});
const _sfc_render$1$2 = null;
const _sfc_staticRenderFns$1$2 = null;
var __component__$1$2 = /* @__PURE__ */ normalizeComponent$3(
  _sfc_main$1$2,
  _sfc_render$1$2,
  _sfc_staticRenderFns$1$2,
  false,
  null,
  null
);
const NcPopoverTriggerProvider = __component__$1$2.exports;
const _sfc_main$r = {
  name: "NcPopover",
  components: {
    Dropdown,
    NcPopoverTriggerProvider
  },
  inheritAttrs: false,
  props: {
    /**
     * Show or hide the popper
     * @see https://floating-vue.starpad.dev/api/#shown
     */
    shown: {
      type: Boolean,
      default: false
    },
    /**
     * Popup role
     * @see https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-haspopup#values
     */
    popupRole: {
      type: String,
      default: void 0,
      validator: (value) => ["menu", "listbox", "tree", "grid", "dialog", "true"].includes(value)
    },
    popoverBaseClass: {
      type: String,
      default: ""
    },
    /**
     * Enable popover focus trap
     *
     * @deprecated use noFocusTrap instead
     */
    focusTrap: {
      type: Boolean,
      default: true
    },
    /**
     * Disable the popover focus trap.
     */
    noFocusTrap: {
      type: Boolean,
      default: false
    },
    /**
     * Set element to return focus to after focus trap deactivation
     *
     * @type {SetReturnFocus}
     */
    setReturnFocus: {
      default: void 0,
      type: [HTMLElement, SVGElement, String, Boolean, Function]
    }
  },
  emits: [
    "after-show",
    "after-hide",
    /**
     * @see https://floating-vue.starpad.dev/api/#update-shown
     */
    "update:shown"
  ],
  data() {
    return {
      internalShown: this.shown
    };
  },
  watch: {
    shown(value) {
      this.internalShown = value;
    },
    internalShown(value) {
      this.$emit("update:shown", value);
    }
  },
  mounted() {
    this.checkTriggerA11y();
  },
  beforeDestroy() {
    this.clearFocusTrap();
    this.clearEscapeStopPropagation();
  },
  methods: {
    /**
     * Check if the trigger has all required a11y attributes.
     * Important to check custom trigger button.
     */
    checkTriggerA11y() {
      if (window.OC?.debug) {
        const triggerContainer = this.getPopoverTriggerContainerElement();
        const requiredTriggerButton = triggerContainer.querySelector("[aria-expanded]");
        if (!requiredTriggerButton) {
          Vue.util.warn("It looks like you are using a custom button as a <NcPopover> or other popover #trigger. If you are not using <NcButton> as a trigger, you need to bind attrs from the #trigger slot props to your custom button. See <NcPopover> docs for an example.");
        }
      }
    },
    /**
     * Remove incorrect aria-describedby attribute from the trigger.
     * @see https://github.com/Akryum/floating-vue/blob/8d4f7125aae0e3ea00ba4093d6d2001ab15058f1/packages/floating-vue/src/components/Popper.ts#L734
     */
    removeFloatingVueAriaDescribedBy() {
      const triggerContainer = this.getPopoverTriggerContainerElement();
      const triggerElements = triggerContainer.querySelectorAll("[data-popper-shown]");
      for (const el of triggerElements) {
        el.removeAttribute("aria-describedby");
      }
    },
    /**
     * @return {HTMLElement|undefined}
     */
    getPopoverContentElement() {
      return this.$refs.popover?.$refs.popperContent?.$el;
    },
    /**
     * @return {HTMLElement|undefined}
     */
    getPopoverTriggerContainerElement() {
      return this.$refs.popover.$refs.reference;
    },
    /**
     * Add focus trap for accessibility.
     */
    async useFocusTrap() {
      await this.$nextTick();
      if (this.noFocusTrap || !this.focusTrap) {
        return;
      }
      const el = this.getPopoverContentElement();
      el.tabIndex = -1;
      if (!el) {
        return;
      }
      this.$focusTrap = createFocusTrap(el, {
        // Prevents to lose focus using esc key
        // Focus will be release when popover be hide
        escapeDeactivates: false,
        allowOutsideClick: true,
        setReturnFocus: this.setReturnFocus,
        trapStack: getTrapStack(),
        fallBackFocus: el
      });
      this.$focusTrap.activate();
    },
    /**
     * Remove focus trap
     *
     * @param {object} options The configuration options for focusTrap
     */
    clearFocusTrap(options = {}) {
      try {
        this.$focusTrap?.deactivate(options);
        this.$focusTrap = null;
      } catch (err) {
        console.warn(err);
      }
    },
    /**
     * Add stopPropagation for Escape.
     * It prevents global Escape handling after closing popover.
     *
     * Manual event handling is used here instead of v-on because there is no direct access to the node.
     * Alternative - wrap <template #popover> in a div wrapper.
     */
    addEscapeStopPropagation() {
      const el = this.getPopoverContentElement();
      el?.addEventListener("keydown", this.stopKeydownEscapeHandler);
    },
    /**
     * Remove stop Escape handler
     */
    clearEscapeStopPropagation() {
      const el = this.getPopoverContentElement();
      el?.removeEventListener("keydown", this.stopKeydownEscapeHandler);
    },
    /**
     * @param {KeyboardEvent} event - native keydown event
     */
    stopKeydownEscapeHandler(event) {
      if (event.type === "keydown" && event.key === "Escape") {
        event.stopPropagation();
      }
    },
    async afterShow() {
      this.getPopoverContentElement().addEventListener("transitionend", () => {
        this.$emit("after-show");
      }, { once: true, passive: true });
      this.removeFloatingVueAriaDescribedBy();
      await this.$nextTick();
      await this.useFocusTrap();
      this.addEscapeStopPropagation();
    },
    afterHide() {
      this.getPopoverContentElement().addEventListener("transitionend", () => {
        this.$emit("after-hide");
      }, { once: true, passive: true });
      this.clearFocusTrap();
      this.clearEscapeStopPropagation();
    }
  }
};
var _sfc_render$r = function render39() {
  var _vm = this, _c = _vm._self._c;
  return _c("Dropdown", _vm._g(_vm._b({ ref: "popover", attrs: { "distance": 10, "arrow-padding": 10, "no-auto-focus": true, "popper-class": _vm.popoverBaseClass, "shown": _vm.internalShown }, on: { "update:shown": function($event) {
    _vm.internalShown = $event;
  }, "apply-show": _vm.afterShow, "apply-hide": _vm.afterHide }, scopedSlots: _vm._u([{ key: "popper", fn: function(slotProps) {
    return [_vm._t("default", null, null, slotProps)];
  } }], null, true) }, "Dropdown", _vm.$attrs, false), _vm.$listeners), [_c("NcPopoverTriggerProvider", { attrs: { "shown": _vm.internalShown, "popup-role": _vm.popupRole }, scopedSlots: _vm._u([{ key: "default", fn: function(slotProps) {
    return [_vm._t("trigger", null, null, slotProps)];
  } }], null, true) })], 1);
};
var _sfc_staticRenderFns$r = [];
var __component__$r = /* @__PURE__ */ normalizeComponent$3(
  _sfc_main$r,
  _sfc_render$r,
  _sfc_staticRenderFns$r,
  false,
  null,
  null
);
const NcPopover = __component__$r.exports;
function useTrapStackControl(shouldPause, options = {}) {
  const trapStackController = createTrapStackController();
  watch(shouldPause, () => {
    if (toValue(options.disabled)) {
      return;
    }
    if (toValue(shouldPause)) {
      trapStackController.pause();
    } else {
      trapStackController.unpause();
    }
  });
  onUnmounted(() => {
    trapStackController.unpause();
  });
}
const _sfc_main$q = {
  name: "DotsHorizontalIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$q = function render40() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon dots-horizontal-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M16,12A2,2 0 0,1 18,10A2,2 0 0,1 20,12A2,2 0 0,1 18,14A2,2 0 0,1 16,12M10,12A2,2 0 0,1 12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12M4,12A2,2 0 0,1 6,10A2,2 0 0,1 8,12A2,2 0 0,1 6,14A2,2 0 0,1 4,12Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$q = [];
var __component__$q = /* @__PURE__ */ normalizeComponent$3(
  _sfc_main$q,
  _sfc_render$q,
  _sfc_staticRenderFns$q,
  false,
  null,
  null
);
const DotsHorizontal = __component__$q.exports;
register(t4);
const focusableSelector = ".focusable";
const _sfc_main$p = {
  name: "NcActions",
  components: {
    NcButton,
    NcPopover
  },
  provide() {
    return {
      /**
       * NcActions can be used as:
       * - Application menu (has menu role)
       * - Expanded block (has no specific role, should be used an element with expanded role)
       * - Popover with plain text or text inputs (has no specific role)
       * Depending on the usage (used items), the menu and its items should have different roles for a11y.
       * Provide the role for NcAction* components in the NcActions content.
       * @type {import('vue').ComputedRef<boolean>}
       */
      "NcActions:isSemanticMenu": computed(() => this.actionsMenuSemanticType === "menu")
    };
  },
  props: {
    /**
     * Specify the open state of the popover menu
     */
    open: {
      type: Boolean,
      default: false
    },
    /**
     * This disables the internal open management,
     * so the actions menu only respects the `open` prop.
     * This is e.g. necessary for the NcAvatar component
     * to only open the actions menu after loading it's entries has finished.
     */
    manualOpen: {
      type: Boolean,
      default: false
    },
    /**
     * Force the actions to display in a three dot menu
     */
    forceMenu: {
      type: Boolean,
      default: false
    },
    /**
     * Force the name to show for single actions
     */
    forceName: {
      type: Boolean,
      default: false
    },
    /**
     * Specify the menu name
     */
    menuName: {
      type: String,
      default: null
    },
    /**
     * NcActions can be used as:
     *
     * - Application menu (has menu role)
     * - Navigation (has no specific role, should be used an element with expanded role)
     * - Popover with plain text or text inputs (has no specific role)
     *
     * By default the used type is automatically detected by components used in the default slot.#
     *
     * With Vue this is limited to direct children of the NcActions component.
     * So if you use a wrapper, you have to provide the semantic type yourself (see Example)
     *
     * Choose:
     *
     * - 'dialog' if you use any of these components: NcActionInput', 'NcActionTextEditable'
     * - 'menu' if you use any of these components: 'NcActionButton', 'NcActionButtonGroup', 'NcActionCheckbox', 'NcActionRadio'
     * - 'expanded' if using one of these: 'NcActionLink', 'NcActionRouter'. This represents an expanded block.
     * - 'tooltip' only to be used when a text without any interactive elements is used.
     * - Leave this property unset otherwise
     */
    forceSemanticType: {
      type: String,
      default: null,
      validator(value) {
        return ["dialog", "menu", "expanded", "tooltip"].includes(value);
      }
    },
    /**
     * Apply primary styling for this menu
     */
    primary: {
      type: Boolean,
      default: false
    },
    /**
     * Specifies the button variant used for trigger and single actions buttons.
     *
     * Accepted values: primary, secondary, tertiary, tertiary-no-background, tertiary-on-primary, error, warning, success. If left empty,
     * the default button style will be applied.
     * @deprecated use `variant` instead - will be removed with v9
     */
    type: {
      type: String,
      validator(value) {
        return ["primary", "secondary", "tertiary", "tertiary-no-background", "tertiary-on-primary", "error", "warning", "success"].includes(value);
      },
      default: null
    },
    /**
     * Icon to show for the toggle menu button
     * when more than one action is inside the actions component.
     * Only replace the default three-dot icon if really necessary.
     */
    defaultIcon: {
      type: String,
      default: ""
    },
    /**
     * Aria label for the actions menu.
     *
     * If `menuName` is defined this will not be used to prevent
     * any accessible name conflicts. This ensures that the
     * element can be activated via voice input.
     */
    ariaLabel: {
      type: String,
      default: t$1("Actions")
    },
    /**
     * @deprecated To be removed in @nextcloud/vue 9. Migration guide: remove ariaHidden prop from NcAction* components.
     * @todo Add a check in @nextcloud/vue 9 that this prop is not provided,
     * otherwise root element will inherit incorrect aria-hidden.
     */
    ariaHidden: {
      type: Boolean,
      default: null
    },
    /**
     * Wanted direction of the menu
     */
    placement: {
      type: String,
      default: "bottom"
    },
    /**
     * DOM element for the actions' popover boundaries
     */
    boundariesElement: {
      type: Element,
      default: () => document.querySelector("#content-vue") ?? document.querySelector("body")
    },
    /**
     * Selector for the actions' popover container
     */
    container: {
      type: [String, Object, Element, Boolean],
      default: "body"
    },
    /**
     * Disabled state of the main button (single action or menu toggle)
     */
    disabled: {
      type: Boolean,
      default: false
    },
    /**
     * Display x items inline out of the dropdown menu
     * Will be ignored if `forceMenu` is set
     */
    inline: {
      type: Number,
      default: 0
    },
    /**
     * Specifies the button variant used for trigger and single actions buttons.
     *
     * Accepted values: primary, secondary, tertiary, tertiary-no-background, tertiary-on-primary, error, warning, success.
     * If left empty, the default button style will be applied.
     *
     * @since 8.24.0
     */
    variant: {
      type: String,
      validator(value) {
        return ["primary", "secondary", "tertiary", "tertiary-no-background", "tertiary-on-primary", "error", "warning", "success"].includes(value);
      },
      default: null
    }
  },
  emits: [
    "click",
    "blur",
    "focus",
    "close",
    "closed",
    "open",
    "opened",
    "update:open"
  ],
  setup(props2) {
    const randomId = `menu-${GenRandomId()}`;
    const triggerRandomId = `trigger-${randomId}`;
    const triggerButton = ref$1();
    const { top, bottom } = useElementBounding(triggerButton);
    const { top: boundaryTop, bottom: boundaryBottom } = useElementBounding(toRef(props2, "boundariesElement"));
    const { height: windowHeight } = useWindowSize();
    const maxMenuHeight = computed(() => Math.max(
      // Either expand to the top
      Math.min(
        // max height is the top position of the trigger minus the header height minus the wedge and the padding
        top.value - 84,
        // and also limited to the space in the boundary
        top.value - boundaryTop.value
      ),
      // or expand to the bottom
      Math.min(
        // the max height is the window height minus current position of the trigger minus the wedge and padding
        windowHeight.value - bottom.value - 34,
        // and limit to the available space in the boundary
        boundaryBottom.value - bottom.value
      )
    ));
    return {
      triggerButton,
      maxMenuHeight,
      randomId,
      triggerRandomId
    };
  },
  data() {
    return {
      opened: this.open,
      focusIndex: 0,
      /**
       * @type {'menu'|'expanded'|'dialog'|'tooltip'|'unknown'}
       */
      actionsMenuSemanticType: "unknown"
    };
  },
  computed: {
    triggerButtonVariant() {
      return (this.type ?? this.variant) || (this.primary ? "primary" : this.menuName ? "secondary" : "tertiary");
    },
    /**
     * A11y roles and keyboard navigation configuration depending on the semantic type
     */
    config() {
      const configs = {
        menu: {
          popupRole: "menu",
          withArrowNavigation: true,
          withTabNavigation: false,
          withFocusTrap: false,
          triggerA11yAttr: {
            "aria-controls": this.opened ? this.randomId : null
          },
          popoverContainerA11yAttrs: {},
          popoverUlA11yAttrs: {
            "aria-labelledby": this.triggerRandomId,
            id: this.randomId,
            role: "menu"
          }
        },
        expanded: {
          popupRole: void 0,
          withArrowNavigation: false,
          withTabNavigation: true,
          withFocusTrap: false,
          triggerA11yAttr: {},
          popoverContainerA11yAttrs: {},
          popoverUlA11yAttrs: {}
        },
        dialog: {
          popupRole: "dialog",
          withArrowNavigation: false,
          withTabNavigation: true,
          withFocusTrap: true,
          triggerA11yAttr: {
            "aria-controls": this.opened ? this.randomId : null
          },
          popoverContainerA11yAttrs: {
            id: this.randomId,
            role: "dialog",
            // Dialog must have a label
            "aria-labelledby": this.triggerRandomId,
            "aria-modal": "true"
          },
          popoverUlA11yAttrs: {}
        },
        tooltip: {
          popupRole: void 0,
          withArrowNavigation: false,
          withTabNavigation: false,
          withFocusTrap: false,
          triggerA11yAttr: {},
          popoverContainerA11yAttrs: {},
          popoverUlA11yAttrs: {}
        },
        // Due to Vue limitations, we sometimes cannot determine the true type
        // As a fallback use both arrow navigation and focus trap
        unknown: {
          popupRole: void 0,
          role: void 0,
          withArrowNavigation: true,
          withTabNavigation: false,
          withFocusTrap: true,
          triggerA11yAttr: {},
          popoverContainerA11yAttrs: {},
          popoverUlA11yAttrs: {
            // there is nothing against labelling a list, it is mostly recommended
            // so as we do not know the dialog type lets include the label
            "aria-labelledby": this.triggerRandomId
          }
        }
      };
      return configs[this.actionsMenuSemanticType];
    }
  },
  watch: {
    // Watch parent prop
    open(state) {
      if (state === this.opened) {
        return;
      }
      this.opened = state;
    },
    opened() {
      if (this.opened) {
        document.body.addEventListener("keydown", this.handleEscapePressed);
      } else {
        document.body.removeEventListener("keydown", this.handleEscapePressed);
      }
    }
  },
  created() {
    useTrapStackControl(() => this.opened, {
      disabled: () => this.config.withFocusTrap
    });
  },
  methods: {
    /**
     * Get the name of the action component
     *
     * @param {import('vue').VNode} action - a vnode with a NcAction* component instance
     * @return {string} the name of the action component
     */
    getActionName(action) {
      return action?.componentOptions?.Ctor?.extendOptions?.name ?? action?.componentOptions?.tag;
    },
    /**
     * Do we have exactly one Action and
     * is it allowed as a standalone element?
     *
     * @param {import('vue').VNode} action The action to check
     * @return {boolean}
     */
    isValidSingleAction(action) {
      return ["NcActionButton", "NcActionLink", "NcActionRouter"].includes(this.getActionName(action));
    },
    /**
     * Check whether a icon prop value is an URL or not
     * @param {string} url The icon prop value
     */
    isIconUrl(url) {
      try {
        return !!new URL(url, url.startsWith("/") ? window.location.origin : void 0);
      } catch (error) {
        return false;
      }
    },
    // MENU STATE MANAGEMENT
    openMenu(e) {
      if (this.opened) {
        return;
      }
      this.opened = true;
      this.$emit("update:open", true);
      this.$emit("open");
    },
    async closeMenu(returnFocus = true) {
      if (!this.opened) {
        return;
      }
      await this.$nextTick();
      this.opened = false;
      this.$refs.popover?.clearFocusTrap({ returnFocus });
      this.$emit("update:open", false);
      this.$emit("close");
      this.focusIndex = 0;
      if (returnFocus) {
        this.$refs.triggerButton?.$el.focus();
      }
    },
    onClosed() {
      this.$emit("closed");
    },
    /**
     * Called when popover is shown after the show delay
     */
    onOpened() {
      this.$nextTick(() => {
        this.focusFirstAction(null);
        this.resizePopover();
        this.$emit("opened");
      });
    },
    /**
     * Handle resizing the popover to make sure users can discover there is more to scroll
     */
    resizePopover() {
      const inner = this.$refs.menu.closest(".v-popper__inner");
      const height = this.$refs.menu.clientHeight;
      if (height > this.maxMenuHeight) {
        let currentHeight = 0;
        let actionHeight = 0;
        for (const action of this.$refs.menuList.children) {
          if (currentHeight + action.clientHeight / 2 > this.maxMenuHeight) {
            inner.style.height = `${currentHeight - actionHeight / 2}px`;
            break;
          }
          actionHeight = action.clientHeight;
          currentHeight += actionHeight;
        }
      } else {
        inner.style.height = "fit-content";
      }
    },
    // MENU KEYS & FOCUS MANAGEMENT
    /**
     * @return {HTMLElement|null}
     */
    getCurrentActiveMenuItemElement() {
      return this.$refs.menu.querySelector("li.active");
    },
    /**
     * @return {NodeListOf<HTMLElement>}
     */
    getFocusableMenuItemElements() {
      return this.$refs.menu.querySelectorAll(focusableSelector);
    },
    /**
     * Dispatches the keydown listener to different handlers
     *
     * @param {object} event The keydown event
     */
    onKeydown(event) {
      if (event.key === "Tab") {
        if (this.config.withFocusTrap) {
          return;
        }
        if (!this.config.withTabNavigation) {
          this.closeMenu(true);
          return;
        }
        event.preventDefault();
        const focusList = this.getFocusableMenuItemElements();
        const focusIndex = [...focusList].indexOf(document.activeElement);
        if (focusIndex === -1) {
          return;
        }
        const newFocusIndex = event.shiftKey ? focusIndex - 1 : focusIndex + 1;
        if (newFocusIndex < 0 || newFocusIndex === focusList.length) {
          this.closeMenu(true);
        }
        this.focusIndex = newFocusIndex;
        this.focusAction();
        return;
      }
      if (this.config.withArrowNavigation) {
        if (event.key === "ArrowUp") {
          this.focusPreviousAction(event);
        }
        if (event.key === "ArrowDown") {
          this.focusNextAction(event);
        }
        if (event.key === "PageUp") {
          this.focusFirstAction(event);
        }
        if (event.key === "PageDown") {
          this.focusLastAction(event);
        }
      }
      this.handleEscapePressed(event);
    },
    onTriggerKeydown(event) {
      if (event.key === "Escape") {
        if (this.actionsMenuSemanticType === "tooltip") {
          this.closeMenu();
        }
      }
    },
    handleEscapePressed(event) {
      if (event.key === "Escape") {
        this.closeMenu();
        event.preventDefault();
      }
    },
    removeCurrentActive() {
      const currentActiveElement = this.$refs.menu.querySelector("li.active");
      if (currentActiveElement) {
        currentActiveElement.classList.remove("active");
      }
    },
    focusAction() {
      const focusElement = this.getFocusableMenuItemElements()[this.focusIndex];
      if (focusElement) {
        this.removeCurrentActive();
        const liMenuParent = focusElement.closest("li.action");
        focusElement.focus();
        if (liMenuParent) {
          liMenuParent.classList.add("active");
        }
      }
    },
    focusPreviousAction(event) {
      if (this.opened) {
        if (this.focusIndex === 0) {
          this.focusLastAction(event);
        } else {
          this.preventIfEvent(event);
          this.focusIndex = this.focusIndex - 1;
        }
        this.focusAction();
      }
    },
    focusNextAction(event) {
      if (this.opened) {
        const indexLength = this.getFocusableMenuItemElements().length - 1;
        if (this.focusIndex === indexLength) {
          this.focusFirstAction(event);
        } else {
          this.preventIfEvent(event);
          this.focusIndex = this.focusIndex + 1;
        }
        this.focusAction();
      }
    },
    focusFirstAction(event) {
      if (this.opened) {
        this.preventIfEvent(event);
        const firstCheckedIndex = [...this.getFocusableMenuItemElements()].findIndex((button) => {
          return button.getAttribute("aria-checked") === "true" && button.getAttribute("role") === "menuitemradio";
        });
        this.focusIndex = firstCheckedIndex > -1 ? firstCheckedIndex : 0;
        this.focusAction();
      }
    },
    focusLastAction(event) {
      if (this.opened) {
        this.preventIfEvent(event);
        this.focusIndex = this.getFocusableMenuItemElements().length - 1;
        this.focusAction();
      }
    },
    preventIfEvent(event) {
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }
    },
    onFocus(event) {
      this.$emit("focus", event);
    },
    onBlur(event) {
      this.$emit("blur", event);
      if (this.actionsMenuSemanticType === "tooltip") {
        if (this.$refs.menu && this.getFocusableMenuItemElements().length === 0) {
          this.closeMenu(false);
        }
      }
    },
    onClick(event) {
      this.$emit("click", event);
    }
  },
  /**
   * The render function to display the component
   *
   * @param {Function} h The function to create VNodes
   * @return {object|undefined} The created VNode
   */
  render(h) {
    const actions = (this.$slots.default || []).filter((action) => this.getActionName(action));
    if (actions.length === 0) {
      return;
    }
    let validInlineActions = actions.filter(this.isValidSingleAction);
    if (this.forceMenu && validInlineActions.length > 0 && this.inline > 0) {
      Vue.util.warn("Specifying forceMenu will ignore any inline actions rendering.");
      validInlineActions = [];
    }
    const inlineActions = validInlineActions.slice(0, this.inline);
    const menuActions = actions.filter((action) => !inlineActions.includes(action));
    if (this.forceSemanticType) {
      this.actionsMenuSemanticType = this.forceSemanticType;
    } else {
      const textInputActions = ["NcActionInput", "NcActionTextEditable"];
      const menuItemsActions = ["NcActionButton", "NcActionButtonGroup", "NcActionCheckbox", "NcActionRadio"];
      const linkActions = ["NcActionLink", "NcActionRouter"];
      const hasTextInputAction = menuActions.some((action) => textInputActions.includes(this.getActionName(action)));
      const hasMenuItemAction = menuActions.some((action) => menuItemsActions.includes(this.getActionName(action)));
      const hasLinkAction = menuActions.some((action) => linkActions.includes(this.getActionName(action)));
      if (hasTextInputAction) {
        this.actionsMenuSemanticType = "dialog";
      } else if (hasMenuItemAction) {
        this.actionsMenuSemanticType = "menu";
      } else if (hasLinkAction) {
        this.actionsMenuSemanticType = "expanded";
      } else {
        const ncActions = actions.filter((action) => this.getActionName(action).startsWith("NcAction"));
        if (ncActions.length === actions.length) {
          this.actionsMenuSemanticType = "tooltip";
        } else {
          this.actionsMenuSemanticType = "unknown";
        }
      }
    }
    const renderInlineAction = (action) => {
      const iconProp = action?.componentOptions?.propsData?.icon;
      const icon = action?.data?.scopedSlots?.icon()?.[0] ?? (this.isIconUrl(iconProp) ? h("img", { class: "action-item__menutoggle__icon", attrs: { src: iconProp, alt: "" } }) : h("span", { class: ["icon", iconProp] }));
      const attrs2 = action?.data?.attrs || {};
      const clickListener = action?.componentOptions?.listeners?.click;
      const text2 = action?.componentOptions?.children?.[0]?.text?.trim?.();
      const ariaLabel = action?.componentOptions?.propsData?.ariaLabel || text2;
      const buttonText = this.forceName ? text2 : "";
      let title = action?.componentOptions?.propsData?.title;
      if (!(this.forceName || title)) {
        title = text2;
      }
      const propsToForward = { ...action?.componentOptions?.propsData ?? {} };
      const nativeType = ["submit", "reset"].includes(propsToForward.type) ? propsToForward.modelValue : "button";
      delete propsToForward.modelValue;
      delete propsToForward.type;
      return h(
        "NcButton",
        {
          class: [
            "action-item action-item--single",
            action?.data?.staticClass,
            action?.data?.class
          ],
          attrs: {
            ...attrs2,
            "aria-label": ariaLabel,
            title
          },
          ref: action?.data?.ref,
          props: {
            ...propsToForward,
            disabled: this.disabled || action?.componentOptions?.propsData?.disabled,
            pressed: action?.componentOptions?.propsData?.modelValue,
            type: nativeType,
            // If it has a menuName, we use a secondary button
            variant: (this.type ?? this.variant) || (buttonText ? "secondary" : "tertiary")
          },
          on: {
            focus: this.onFocus,
            blur: this.onBlur,
            // forward any pressed state from NcButton just like NcActionButton does
            "update:pressed": action?.componentOptions?.listeners?.["update:modelValue"] ?? (() => {
            }),
            // If we have a click listener,
            // we bind it to execute on click and forward the click event
            ...!!clickListener && {
              click: (event) => {
                if (clickListener) {
                  clickListener(event);
                }
              }
            }
          }
        },
        [
          h("template", { slot: "icon" }, [icon]),
          buttonText
        ]
      );
    };
    const renderActionsPopover = (actions2) => {
      const triggerIcon = this.$slots.icon?.[0] || (this.defaultIcon ? h("span", { class: ["icon", this.defaultIcon] }) : h(DotsHorizontal, {
        props: {
          size: 20
        }
      }));
      return h(
        "NcPopover",
        {
          ref: "popover",
          props: {
            delay: 0,
            handleResize: true,
            shown: this.opened,
            placement: this.placement,
            boundary: this.boundariesElement,
            container: this.container,
            popoverBaseClass: "action-item__popper",
            popupRole: this.config.popupRole,
            setReturnFocus: this.config.withFocusTrap ? this.$refs.triggerButton?.$el : null,
            focusTrap: this.config.withFocusTrap
          },
          // For some reason the popover component
          // does not react to props given under the 'props' key,
          // so we use both 'attrs' and 'props'
          attrs: {
            delay: 0,
            handleResize: true,
            shown: this.opened,
            placement: this.placement,
            boundary: this.boundariesElement,
            container: this.container,
            ...this.manualOpen && { triggers: [] }
          },
          on: {
            show: this.openMenu,
            "after-show": this.onOpened,
            hide: this.closeMenu,
            "after-hide": this.onClosed
          }
        },
        [
          h("NcButton", {
            class: "action-item__menutoggle",
            props: {
              variant: this.triggerButtonVariant,
              disabled: this.disabled
            },
            slot: "trigger",
            ref: "triggerButton",
            attrs: {
              id: this.triggerRandomId,
              "aria-label": this.menuName ? null : this.ariaLabel,
              ...this.config.triggerA11yAttr
            },
            on: {
              focus: this.onFocus,
              blur: this.onBlur,
              click: this.onClick,
              keydown: this.onTriggerKeydown
            }
          }, [
            h("template", { slot: "icon" }, [triggerIcon]),
            this.menuName
          ]),
          h("div", {
            class: {
              open: this.opened
            },
            attrs: {
              tabindex: "-1",
              ...this.config.popoverContainerA11yAttrs
            },
            on: {
              keydown: this.onKeydown
            },
            ref: "menu"
          }, [
            h("ul", {
              attrs: {
                tabindex: "-1",
                ...this.config.popoverUlA11yAttrs
              },
              ref: "menuList"
            }, [
              actions2
            ])
          ])
        ]
      );
    };
    if (actions.length === 1 && validInlineActions.length === 1 && !this.forceMenu) {
      return renderInlineAction(actions[0]);
    }
    this.$nextTick(() => {
      if (this.opened && this.$refs.menu) {
        this.resizePopover();
        const isAnyActive = this.$refs.menu.querySelector("li.active") || [];
        if (isAnyActive.length === 0) {
          this.focusFirstAction();
        }
      }
    });
    if (inlineActions.length > 0 && this.inline > 0) {
      return h(
        "div",
        {
          class: [
            "action-items",
            `action-item--${this.triggerButtonVariant}`
          ]
        },
        [
          // Render inline actions
          ...inlineActions.map(renderInlineAction),
          // render the rest within the popover menu
          menuActions.length > 0 ? h(
            "div",
            {
              class: [
                "action-item",
                {
                  "action-item--open": this.opened
                }
              ]
            },
            [
              renderActionsPopover(menuActions)
            ]
          ) : null
        ]
      );
    }
    return h(
      "div",
      {
        class: [
          "action-item action-item--default-popover",
          `action-item--${this.triggerButtonVariant}`,
          {
            "action-item--open": this.opened
          }
        ]
      },
      [
        renderActionsPopover(actions)
      ]
    );
  }
};
const _sfc_render$p = null;
const _sfc_staticRenderFns$p = null;
var __component__$p = /* @__PURE__ */ normalizeComponent$3(
  _sfc_main$p,
  _sfc_render$p,
  _sfc_staticRenderFns$p,
  false,
  null,
  "d11b605b"
);
const NcActions = __component__$p.exports;
const __default__$1 = {
  name: "NcIconSvgWrapper",
  props: {
    /**
     * Make the icon directional, meaning it is langauge direction aware.
     * If the icon is placed in a right-to-left context it will be mirrored vertically.
     */
    directional: {
      type: Boolean,
      default: false
    },
    /**
     * Set if the icon should be used as inline content e.g. within text.
     * By default the icon is made a block element for use inside `icon`-slots.
     */
    inline: {
      type: Boolean,
      default: false
    },
    /**
     * Raw SVG string to render
     */
    svg: {
      type: String,
      default: ""
    },
    /**
     * Label of the icon, used in aria-label
     */
    name: {
      type: String,
      default: ""
    },
    /**
     * Raw SVG path to render. Takes precedence over the SVG string in the `svg` prop.
     */
    path: {
      type: String,
      default: ""
    },
    /**
     * Size of the icon to show. Only use if not using within an icon slot.
     * Defaults to 20px which is the Nextcloud icon size for all icon slots.
     * @default 20
     */
    size: {
      type: [Number, String],
      default: 20,
      validator: (value) => typeof value === "number" || value === "auto"
    }
  },
  computed: {
    /**
     * Icon size used in CSS
     */
    iconSize() {
      return typeof this.size === "number" ? `${this.size}px` : this.size;
    },
    cleanSvg() {
      if (!this.svg || this.path) {
        return;
      }
      const svg2 = purify.sanitize(this.svg);
      const svgDocument = new DOMParser().parseFromString(svg2, "image/svg+xml");
      if (svgDocument.querySelector("parsererror")) {
        Vue.util.warn("SVG is not valid");
        return "";
      }
      if (svgDocument.documentElement.id) {
        svgDocument.documentElement.removeAttribute("id");
      }
      return svgDocument.documentElement.outerHTML;
    }
  }
};
const __injectCSSVars__$1 = () => {
  useCssVars((_vm, _setup) => ({
    "adec40c8": _vm.iconSize
  }));
};
const __setup__$1 = __default__$1.setup;
__default__$1.setup = __setup__$1 ? (props2, ctx) => {
  __injectCSSVars__$1();
  return __setup__$1(props2, ctx);
} : __injectCSSVars__$1;
const _sfc_main$o = __default__$1;
var _sfc_render$o = function render41() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", { staticClass: "icon-vue", class: {
    "icon-vue--directional": _vm.directional,
    "icon-vue--inline": _vm.inline
  }, attrs: { "aria-hidden": _vm.name ? void 0 : "true", "aria-label": _vm.name || void 0, "role": "img" } }, [!_vm.cleanSvg ? _c("svg", { attrs: { "viewBox": "0 0 24 24", "xmlns": "http://www.w3.org/2000/svg" } }, [_c("path", { attrs: { "d": _vm.path } })]) : _c("span", { domProps: { "innerHTML": _vm._s(_vm.cleanSvg) } })]);
};
var _sfc_staticRenderFns$o = [];
var __component__$o = /* @__PURE__ */ normalizeComponent$3(
  _sfc_main$o,
  _sfc_render$o,
  _sfc_staticRenderFns$o,
  false,
  null,
  "a4f5b92e"
);
const NcIconSvgWrapper = __component__$o.exports;
const _sfc_main$n = {
  name: "CloseIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$n = function render42() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon close-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$n = [];
var __component__$n = /* @__PURE__ */ normalizeComponent$3(
  _sfc_main$n,
  _sfc_render$n,
  _sfc_staticRenderFns$n,
  false,
  null,
  null
);
const Close = __component__$n.exports;
register(t17, t33);
function timer(callback, delay3) {
  let id;
  let started;
  let remaining = delay3;
  let running;
  this.start = function() {
    running = true;
    started = /* @__PURE__ */ new Date();
    id = setTimeout(callback, remaining);
  };
  this.pause = function() {
    running = false;
    clearTimeout(id);
    remaining -= /* @__PURE__ */ new Date() - started;
  };
  this.clear = function() {
    running = false;
    clearTimeout(id);
    remaining = 0;
  };
  this.getTimeLeft = function() {
    if (running) {
      this.pause();
      this.start();
    }
    return remaining;
  };
  this.getStateRunning = function() {
    return running;
  };
  this.start();
}
const _sfc_main$2$1 = {
  name: "PauseIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$2$1 = function render43() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon pause-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M14,19H18V5H14M6,19H10V5H6V19Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$2$1 = [];
var __component__$2$1 = /* @__PURE__ */ normalizeComponent$3(
  _sfc_main$2$1,
  _sfc_render$2$1,
  _sfc_staticRenderFns$2$1,
  false,
  null,
  null
);
const Pause = __component__$2$1.exports;
const _sfc_main$1$1 = {
  name: "PlayIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$1$1 = function render210() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon play-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M8,5.14V19.14L19,12.14L8,5.14Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$1$1 = [];
var __component__$1$1 = /* @__PURE__ */ normalizeComponent$3(
  _sfc_main$1$1,
  _sfc_render$1$1,
  _sfc_staticRenderFns$1$1,
  false,
  null,
  null
);
const Play = __component__$1$1.exports;
const __default__ = {
  name: "NcModal",
  components: {
    Close,
    Pause,
    Play,
    NcActions,
    NcButton,
    NcIconSvgWrapper
  },
  props: {
    /**
     * Name to be shown with the modal
     */
    name: {
      type: String,
      default: ""
    },
    /**
     * Declare if a previous slide is available
     */
    hasPrevious: {
      type: Boolean,
      default: false
    },
    /**
     * Declare if a next slide is available
     */
    hasNext: {
      type: Boolean,
      default: false
    },
    /**
     * Declare if hiding the modal should be animated
     */
    outTransition: {
      type: Boolean,
      default: false
    },
    /**
     * Declare if the slideshow functionality should be enabled
     */
    enableSlideshow: {
      type: Boolean,
      default: false
    },
    /**
     * Declare the slide interval
     */
    slideshowDelay: {
      type: Number,
      default: 5e3
    },
    /**
     * Allow to pause an ongoing slideshow
     */
    slideshowPaused: {
      type: Boolean,
      default: false
    },
    /**
     * Enable swipe between slides
     * @deprecated Will be removed in next version - use `disableSwipe` instead
     */
    enableSwipe: {
      type: Boolean,
      default: true
    },
    /**
     * Disable swipe between slides
     */
    disableSwipe: {
      type: Boolean,
      default: false
    },
    spreadNavigation: {
      type: Boolean,
      default: false
    },
    /**
     * Defines the modal size.
     * Default is 'normal'.
     * Available are 'small', 'normal', 'large' and 'full'.
     * All sizes except 'small' change automatically to full-screen on mobile.
     */
    size: {
      type: String,
      default: "normal",
      validator: (size2) => {
        return ["small", "normal", "large", "full"].includes(size2);
      }
    },
    /**
     * Do not show the close button for the dialog.
     * @default false
     */
    noClose: {
      type: Boolean,
      default: false
    },
    /**
     * Set to false to no show a close button on the dialog
     * @deprecated - Use `noClose` instead. Will be removed in v9.
     * @default true
     */
    canClose: {
      type: Boolean,
      default: true
    },
    /**
     * Close the modal if the user clicked outside the modal
     * Only relevant if `canClose` is set to true.
     */
    closeOnClickOutside: {
      type: Boolean,
      default: true
    },
    /**
     * Makes the modal backdrop opaque if true.
     * Will be overwritten if some buttons are shown outside.
     */
    dark: {
      type: Boolean,
      default: false
    },
    /**
     * Set light backdrop. Makes the modal header appear light.
     */
    lightBackdrop: {
      type: Boolean,
      default: false
    },
    /**
     * Selector for the modal container, pass `null` to prevent automatic container mounting
     */
    container: {
      type: [String, null],
      default: "body"
    },
    /**
     * Pass in false if you want the modal 'close' button to be displayed
     * outside the modal boundaries, in the top right corner of the window
     */
    closeButtonContained: {
      type: Boolean,
      default: true
    },
    /**
     * Additional elements to add to the focus trap
     */
    additionalTrapElements: {
      type: Array,
      default: () => []
    },
    /**
     * Display x items inline
     *
     * @see Actions component usage
     */
    inlineActions: {
      type: Number,
      default: 0
    },
    show: {
      type: Boolean,
      default: void 0
    },
    /**
     * Id of the element that labels the dialog (the name)
     * Not needed if the `name` prop is set, but if no name is set you need to provide the ID of an element to label the dialog for accessibility.
     */
    labelId: {
      type: String,
      default: ""
    },
    /**
     * Set element to return focus to after focus trap deactivation
     *
     * @type {import('focus-trap').FocusTargetValueOrFalse}
     */
    setReturnFocus: {
      default: void 0,
      type: [HTMLElement, SVGElement, String, Boolean]
    }
  },
  emits: [
    "previous",
    "next",
    "close",
    "update:show"
  ],
  setup() {
    return {
      mdiChevronLeft,
      mdiChevronRight
    };
  },
  data() {
    return {
      mc: null,
      playing: false,
      slideshowTimeout: null,
      focusTrap: null,
      externalFocusTrapStack: [],
      randId: GenRandomId(),
      internalShow: true
    };
  },
  computed: {
    /**
     * slide show delay to set to CSS
     */
    cssSlideshowDelay() {
      return `${this.slideshowDelay}ms`;
    },
    /**
     * True if there are any buttons shown on the backdrop or a name (for accessibility)
     */
    forceDarkBackdrop() {
      return !this.noClose && this.canClose && !this.closeButtonContained || this.hasNext || this.hasPrevious || this.modalName !== "" || Boolean(this.$slots.actions);
    },
    /**
     * Trimmed modal name
     */
    modalName() {
      return this.name.trim();
    },
    /**
     * ID of the element to label the modal
     */
    modalLabelId() {
      return this.labelId || `modal-name-${this.randId}`;
    },
    showModal() {
      return this.show === void 0 ? this.internalShow : this.show;
    },
    modalTransitionName() {
      return `modal-${this.outTransition ? "out" : "in"}`;
    },
    playPauseName() {
      return this.playing ? t$1("Pause slideshow") : t$1("Start slideshow");
    },
    closeButtonAriaLabel() {
      return t$1("Close");
    },
    prevButtonAriaLabel() {
      return t$1("Previous");
    },
    nextButtonAriaLabel() {
      return t$1("Next");
    }
  },
  watch: {
    /**
     * Handle play/pause of an ongoing slideshow
     *
     * @param {boolean} paused is the player paused
     */
    slideshowPaused(paused) {
      if (this.slideshowTimeout) {
        if (paused) {
          this.slideshowTimeout.pause();
        } else {
          this.slideshowTimeout.start();
        }
      }
    },
    additionalTrapElements(elements) {
      if (this.focusTrap) {
        const contentContainer = this.$refs.mask;
        this.focusTrap.updateContainerElements([contentContainer, ...elements]);
      }
    }
  },
  beforeMount() {
    window.addEventListener("keydown", this.handleKeydown);
  },
  beforeDestroy() {
    window.removeEventListener("keydown", this.handleKeydown);
    this.mc.stop();
  },
  mounted() {
    if (!this.name && !this.labelId) {
      Vue.util.warn("[NcModal] You need either set the name or set a `labelId` for accessibility.");
    }
    this.useFocusTrap();
    this.mc = useSwipe(this.$refs.mask, {
      onSwipeEnd: this.handleSwipe
    });
    if (this.container) {
      if (this.container === "body") {
        document.body.insertBefore(this.$el, document.body.lastChild);
      } else {
        const container = document.querySelector(this.container);
        container.appendChild(this.$el);
      }
    }
  },
  destroyed() {
    this.clearFocusTrap();
    this.$el.remove();
  },
  methods: {
    t: t$1,
    // Events emitters
    previous(event) {
      if (this.hasPrevious) {
        if (event) {
          this.resetSlideshow();
        }
        this.$emit("previous", event);
      }
    },
    next(event) {
      if (this.hasNext) {
        if (event) {
          this.resetSlideshow();
        }
        this.$emit("next", event);
      }
    },
    close(data) {
      if (!this.noClose && this.canClose) {
        this.internalShow = false;
        this.$emit("update:show", false);
        setTimeout(() => {
          this.$emit("close", data);
        }, 300);
      }
    },
    /**
     * Handle click on modal wrapper
     * If `closeOnClickOutside` is set the modal will be closed
     *
     * @param {MouseEvent} event The click event
     */
    handleClickModalWrapper(event) {
      if (this.closeOnClickOutside) {
        this.close(event);
      }
    },
    /**
     * @param {KeyboardEvent} event - keyboard event
     */
    handleKeydown(event) {
      if (event.key === "Escape") {
        const trapStack = getTrapStack();
        if (trapStack.length > 0 && trapStack[trapStack.length - 1] !== this.focusTrap) {
          return;
        }
        return this.close(event);
      }
      const arrowHandlers = {
        ArrowLeft: this.previous,
        ArrowRight: this.next
      };
      if (arrowHandlers[event.key]) {
        if (document.activeElement && !this.$el.contains(document.activeElement)) {
          return;
        }
        return arrowHandlers[event.key](event);
      }
    },
    /**
     * handle the swipe event
     *
     * @param {TouchEvent} e The touch event
     * @param {import('@vueuse/core').SwipeDirection} direction Swipe direction
     */
    handleSwipe(e, direction) {
      if (this.enableSwipe && !this.disableSwipe) {
        if (direction === "left") {
          this.next(e);
        } else if (direction === "right") {
          this.previous(e);
        }
      }
    },
    /**
     * Toggle the slideshow state
     */
    togglePlayPause() {
      this.playing = !this.playing;
      if (this.playing) {
        this.handleSlideshow();
      } else {
        this.clearSlideshowTimeout();
      }
    },
    /**
     * Reset the slideshow timer and keep going if it was on
     */
    resetSlideshow() {
      this.playing = !this.playing;
      this.clearSlideshowTimeout();
      this.$nextTick(function() {
        this.togglePlayPause();
      });
    },
    /**
     * Handle the slideshow timer and next event
     */
    handleSlideshow() {
      this.playing = true;
      if (this.hasNext) {
        this.slideshowTimeout = new timer(() => {
          this.next();
          this.handleSlideshow();
        }, this.slideshowDelay);
      } else {
        this.playing = false;
        this.clearSlideshowTimeout();
      }
    },
    /**
     * Clear slideshowTimeout if ongoing
     */
    clearSlideshowTimeout() {
      if (this.slideshowTimeout) {
        this.slideshowTimeout.clear();
      }
    },
    /**
     * Add focus trap for accessibility.
     */
    async useFocusTrap() {
      if (!this.showModal || this.focusTrap) {
        return;
      }
      const contentContainer = this.$refs.mask;
      await this.$nextTick();
      const options = {
        allowOutsideClick: true,
        fallbackFocus: contentContainer,
        trapStack: getTrapStack(),
        // Esc can be used without stop in content or additionalTrapElements where it should not deactivate modal's focus trap.
        // Focus trap is deactivated on modal close anyway.
        escapeDeactivates: false,
        setReturnFocus: this.setReturnFocus
      };
      this.externalFocusTrapStack = [...options.trapStack];
      for (const trap of this.externalFocusTrapStack) {
        trap.deactivate();
      }
      this.focusTrap = createFocusTrap([contentContainer, ...this.additionalTrapElements], options);
      this.focusTrap.activate();
    },
    clearFocusTrap() {
      if (!this.focusTrap) {
        return;
      }
      this.focusTrap?.deactivate();
      this.focusTrap = null;
      for (const trap of this.externalFocusTrapStack) {
        trap.activate();
      }
      this.externalFocusTrapStack = [];
    }
  }
};
const __injectCSSVars__ = () => {
  useCssVars((_vm, _setup) => ({
    "189d6f6a": _vm.cssSlideshowDelay
  }));
};
const __setup__ = __default__.setup;
__default__.setup = __setup__ ? (props2, ctx) => {
  __injectCSSVars__();
  return __setup__(props2, ctx);
} : __injectCSSVars__;
const _sfc_main$m = __default__;
var _sfc_render$m = function render310() {
  var _vm = this, _c = _vm._self._c;
  return _c("transition", { attrs: { "name": "fade", "appear": "" }, on: { "after-enter": _vm.useFocusTrap, "before-leave": _vm.clearFocusTrap } }, [_c("div", { directives: [{ name: "show", rawName: "v-show", value: _vm.showModal, expression: "showModal" }], ref: "mask", staticClass: "modal-mask", class: {
    "modal-mask--opaque": _vm.dark || _vm.forceDarkBackdrop,
    "modal-mask--light": _vm.lightBackdrop
  }, attrs: { "role": "dialog", "aria-modal": "true", "aria-labelledby": _vm.modalLabelId, "aria-describedby": "modal-description-" + _vm.randId, "tabindex": "-1" } }, [_c("transition", { attrs: { "name": "fade-visibility", "appear": "" } }, [_c("div", { staticClass: "modal-header", attrs: { "data-theme-light": _vm.lightBackdrop, "data-theme-dark": !_vm.lightBackdrop } }, [_vm.modalName ? _c("h2", { staticClass: "modal-header__name", attrs: { "id": "modal-name-" + _vm.randId } }, [_vm._v(" " + _vm._s(_vm.modalName) + " ")]) : _vm._e(), _c("div", { staticClass: "icons-menu" }, [_vm.hasNext && _vm.enableSlideshow ? _c("button", { staticClass: "play-pause-icons", class: { "play-pause-icons--paused": _vm.slideshowPaused }, attrs: { "title": _vm.playPauseName, "type": "button" }, on: { "click": _vm.togglePlayPause } }, [!_vm.playing ? _c("Play", { staticClass: "play-pause-icons__play", attrs: { "size": 20 } }) : _c("Pause", { staticClass: "play-pause-icons__pause", attrs: { "size": 20 } }), _c("span", { staticClass: "hidden-visually" }, [_vm._v(" " + _vm._s(_vm.playPauseName) + " ")]), _vm.playing ? _c("svg", { staticClass: "progress-ring", attrs: { "height": "50", "width": "50" } }, [_c("circle", { staticClass: "progress-ring__circle", attrs: { "stroke": "white", "stroke-width": "2", "fill": "transparent", "r": "15", "cx": "25", "cy": "25" } })]) : _vm._e()], 1) : _vm._e(), _c("NcActions", { staticClass: "header-actions", attrs: { "inline": _vm.inlineActions } }, [_vm._t("actions")], 2), !_vm.noClose && _vm.canClose && !_vm.closeButtonContained ? _c("NcButton", { staticClass: "header-close", attrs: { "aria-label": _vm.closeButtonAriaLabel, "variant": "tertiary" }, on: { "click": _vm.close }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("Close", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 2121748766) }) : _vm._e()], 1)])]), _c("transition", { attrs: { "name": _vm.modalTransitionName, "appear": "" } }, [_c("div", { directives: [{ name: "show", rawName: "v-show", value: _vm.showModal, expression: "showModal" }], staticClass: "modal-wrapper", class: [
    `modal-wrapper--${_vm.size}`,
    { "modal-wrapper--spread-navigation": _vm.spreadNavigation }
  ], on: { "mousedown": function($event) {
    if ($event.target !== $event.currentTarget) return null;
    return _vm.handleClickModalWrapper.apply(null, arguments);
  } } }, [_c("transition", { attrs: { "name": "fade-visibility", "appear": "" } }, [_c("NcButton", { directives: [{ name: "show", rawName: "v-show", value: _vm.hasPrevious, expression: "hasPrevious" }], staticClass: "prev", attrs: { "aria-label": _vm.prevButtonAriaLabel, "variant": "tertiary-no-background" }, on: { "click": _vm.previous }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("NcIconSvgWrapper", { attrs: { "directional": "", "path": _vm.mdiChevronLeft, "size": 40 } })];
  }, proxy: true }]) })], 1), _c("div", { staticClass: "modal-container", attrs: { "id": "modal-description-" + _vm.randId } }, [_c("div", { staticClass: "modal-container__content" }, [_vm._t("default")], 2), !_vm.noClose && _vm.canClose && _vm.closeButtonContained ? _c("NcButton", { staticClass: "modal-container__close", attrs: { "aria-label": _vm.closeButtonAriaLabel, "variant": "tertiary" }, on: { "click": _vm.close }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("Close", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 2121748766) }) : _vm._e()], 1), _c("transition", { attrs: { "name": "fade-visibility", "appear": "" } }, [_c("NcButton", { directives: [{ name: "show", rawName: "v-show", value: _vm.hasNext, expression: "hasNext" }], staticClass: "next", attrs: { "aria-label": _vm.nextButtonAriaLabel, "variant": "tertiary-no-background" }, on: { "click": _vm.next }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("NcIconSvgWrapper", { attrs: { "directional": "", "path": _vm.mdiChevronRight, "size": 40 } })];
  }, proxy: true }]) })], 1)], 1)])], 1)]);
};
var _sfc_staticRenderFns$m = [];
var __component__$m = /* @__PURE__ */ normalizeComponent$3(
  _sfc_main$m,
  _sfc_render$m,
  _sfc_staticRenderFns$m,
  false,
  null,
  "0fc6c354"
);
const NcModal = __component__$m.exports;
ScopeComponent(NcModal);
register(t30);
const _sfc_main$l = {
  __name: "NcDialogButton",
  props: {
    /**
     * The function that will be called when the button is pressed.
     * If the function returns `false` the click is ignored and the dialog will not be closed,
     * which is the default behavior of "reset"-buttons.
     *
     * @type {() => unknown|false|Promise<unknown|false>}
     */
    callback: {
      type: Function,
      required: false,
      default: () => {
      }
    },
    /**
     * The label of the button
     */
    label: {
      type: String,
      required: true
    },
    /**
     * Optional inline SVG icon for the button
     */
    icon: {
      type: String,
      required: false,
      default: void 0
    },
    /**
     * The button type, see NcButton.
     *
     * @deprecated The usage for setting the color variant is deprecated and will be removed with v9.
     * @type {'button'|'submit'|'reset'|'primary'|'secondary'|'error'|'warning'|'success'}
     */
    type: {
      type: String,
      required: false,
      default: "secondary",
      validator: (type) => typeof type === "string" && ["button", "submit", "reset", "primary", "secondary", "tertiary", "error", "warning", "success"].includes(type)
    },
    /**
     * See `nativeType` of `NcButton`.
     * @deprecated use `type` instead - will removed with v9
     */
    nativeType: {
      type: String,
      required: false,
      default: "button",
      validator(value) {
        return ["submit", "reset", "button"].includes(value);
      }
    },
    /**
     * If the button should be shown as disabled
     */
    disabled: {
      type: Boolean,
      default: false
    },
    /**
     * The button variant, see NcButton.
     *
     * @type {'primary'|'secondary'|'tertiary'|'error'|'warning'|'success'}
     * @since 8.24.0
     */
    variant: {
      type: String,
      required: false,
      default: "secondary",
      validator: (type) => typeof type === "string" && ["primary", "secondary", "tertiary", "error", "warning", "success"].includes(type)
    }
  },
  emits: ["click"],
  setup(__props, { emit: emit2 }) {
    const props2 = __props;
    const isLoading = ref$1(false);
    const handleClick = async (e) => {
      if (isLoading.value) {
        return;
      }
      isLoading.value = true;
      try {
        const fallback = props2.nativeType === "reset" ? false : void 0;
        const result = await props2.callback?.() ?? fallback;
        if (result !== false) {
          emit2("click", e, result);
        }
      } finally {
        isLoading.value = false;
      }
    };
    return { __sfc: true, props: props2, emit: emit2, isLoading, handleClick, t: t$1, NcButton, NcIconSvgWrapper, NcLoadingIcon };
  }
};
var _sfc_render$l = function render44() {
  var _vm = this, _c = _vm._self._c, _setup = _vm._self._setupProxy;
  return _c(_setup.NcButton, { attrs: { "aria-label": _vm.label, "disabled": _vm.disabled, "type": _vm.type, "native-type": _vm.nativeType, "variant": _vm.variant }, on: { "click": _setup.handleClick }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_vm._t("icon", function() {
      return [_setup.isLoading ? _c(_setup.NcLoadingIcon, { attrs: {
        "name": _setup.t("Loading …")
        /* TRANSLATORS: The button is in a loading state*/
      } }) : _vm.icon !== void 0 ? _c(_setup.NcIconSvgWrapper, { attrs: { "svg": _vm.icon } }) : _vm._e()];
    })];
  }, proxy: true }], null, true) }, [_vm._v(" " + _vm._s(_vm.label) + " ")]);
};
var _sfc_staticRenderFns$l = [];
var __component__$l = /* @__PURE__ */ normalizeComponent$3(
  _sfc_main$l,
  _sfc_render$l,
  _sfc_staticRenderFns$l,
  false,
  null,
  null
);
const NcDialogButton = __component__$l.exports;
const _sfc_main$k = defineComponent({
  name: "NcDialog",
  components: {
    NcDialogButton,
    NcModal
  },
  props: {
    /** Name of the dialog (the heading) */
    name: {
      type: String,
      required: true
    },
    /** Text of the dialog */
    message: {
      type: String,
      default: ""
    },
    /** Additional elements to add to the focus trap */
    additionalTrapElements: {
      type: Array,
      validator: (arr) => {
        return Array.isArray(arr) && arr.every(
          (element) => typeof element === "string" || element instanceof HTMLElement
        );
      },
      default: () => []
    },
    /**
     * The element where to mount the dialog, if `null` is passed the dialog is mounted in place
     * @default 'body'
     */
    container: {
      type: String,
      required: false,
      default: "body"
    },
    /**
     * Whether the dialog should be shown
     * @default true
     */
    open: {
      type: Boolean,
      default: true
    },
    /**
     * Size of the underlying NcModal
     * @default 'small'
     * @type {'small'|'normal'|'large'|'full'}
     */
    size: {
      type: String,
      required: false,
      default: "small",
      validator: (value) => typeof value === "string" && ["small", "normal", "large", "full"].includes(value)
    },
    /**
     * Buttons to display
     * @default []
     */
    buttons: {
      type: Array,
      required: false,
      default: () => [],
      validator: (value) => Array.isArray(value) && value.every((element) => typeof element === "object")
    },
    /**
     * Do not show the close button for the dialog.
     * @default false
     */
    noClose: {
      type: Boolean,
      default: false
    },
    /**
     * Set to false to no show a close button on the dialog
     * @deprecated - Use `noClose` instead. Will be removed in v9.
     * @default true
     */
    canClose: {
      type: Boolean,
      default: true
    },
    /**
     * Close the dialog if the user clicked outside of the dialog
     * Only relevant if `canClose` is set to true.
     */
    closeOnClickOutside: {
      type: Boolean,
      default: false
    },
    /**
     * Make the dialog wrapper a HTML form element.
     * The buttons will be wrapped within the form so they can be used as submit / reset buttons.
     * Please note that when using the property the `navigation` should not be used.
     */
    isForm: {
      type: Boolean,
      default: false
    },
    /**
     * Declare if hiding the modal should be animated
     * @default false
     */
    outTransition: {
      type: Boolean,
      default: false
    },
    /**
     * Optionally pass additional classes which will be set on the navigation for custom styling
     * @default ''
     * @example
     * ```html
     * <DialogBase :navigation-classes="['mydialog-navigation']"><!-- --></DialogBase>
     * <!-- ... -->
     * <style lang="scss">
     * :deep(.mydialog-navigation) {
     *     flex-direction: row-reverse;
     * }
     * </style>
     * ```
     */
    navigationClasses: {
      type: [String, Array, Object],
      required: false,
      default: ""
    },
    /**
     * aria-label for the dialog navigation.
     * Use it when you want to provide a more meaningful label than the dialog name.
     *
     * By default, navigation is labeled by the dialog name.
     */
    navigationAriaLabel: {
      type: String,
      required: false,
      default: ""
    },
    /**
     * aria-labelledby for the dialog navigation.
     * Use it when you have an implicit navigation label (e.g. a heading).
     *
     * By default, navigation is labeled by the dialog name.
     */
    navigationAriaLabelledby: {
      type: String,
      required: false,
      default: ""
    },
    /**
     * Optionally pass additional classes which will be set on the content wrapper for custom styling
     * @default ''
     */
    contentClasses: {
      type: [String, Array, Object],
      required: false,
      default: ""
    },
    /**
     * Optionally pass additional classes which will be set on the dialog itself
     * (the default `class` attribute will be set on the modal wrapper)
     * @default ''
     */
    dialogClasses: {
      type: [String, Array, Object],
      required: false,
      default: ""
    }
  },
  emits: ["closing", "update:open", "submit"],
  setup(props2, { emit: emit2, slots }) {
    const wrapper = ref$1();
    const { width: dialogWidth } = useElementSize(wrapper, { width: 900 });
    const isNavigationCollapsed = computed(() => dialogWidth.value < 876);
    const hasNavigation = computed(() => slots?.navigation !== void 0);
    const navigationId = GenRandomId();
    const navigationAriaLabelAttr = computed(() => props2.navigationAriaLabel || void 0);
    const navigationAriaLabelledbyAttr = computed(() => {
      if (props2.navigationAriaLabel) {
        return void 0;
      }
      return props2.navigationAriaLabelledby || navigationId;
    });
    const dialogElement = ref$1();
    const dialogTagName = computed(() => props2.isForm && !hasNavigation.value ? "form" : "div");
    const dialogListeners = computed(
      () => dialogTagName.value === "form" ? {
        /**
         * @param {SubmitEvent} event Form submit event
         */
        submit(event) {
          event.preventDefault();
          emit2("submit", event);
        },
        /**
         * @param {Event} event Form submit event
         */
        reset(event) {
          event.preventDefault();
          emit2("reset", event);
        }
      } : {}
    );
    const showModal = ref$1(true);
    function handleButtonClose(button, result) {
      if (button.nativeType === "submit" && dialogTagName.value === "form" && !dialogElement.value.reportValidity()) {
        return;
      }
      handleClosing(result);
      window.setTimeout(() => handleClosed(), 300);
    }
    const handleClosing = (result) => {
      showModal.value = false;
      emit2("closing", result);
    };
    const handleClosed = () => {
      showModal.value = true;
      emit2("update:open", false);
    };
    const modalProps = computed(() => ({
      noClose: props2.noClose || !props2.canClose,
      container: props2.container === void 0 ? "body" : props2.container,
      // we do not pass the name as we already have the name as the headline
      // name: props.name,
      // But we need to set the correct label id so the dialog is labelled
      labelId: navigationId,
      size: props2.size,
      show: props2.open && showModal.value,
      outTransition: props2.outTransition,
      closeOnClickOutside: props2.closeOnClickOutside,
      additionalTrapElements: props2.additionalTrapElements
    }));
    return {
      dialogElement,
      dialogListeners,
      dialogTagName,
      handleButtonClose,
      handleClosing,
      handleClosed,
      hasNavigation,
      navigationId,
      navigationAriaLabelAttr,
      navigationAriaLabelledbyAttr,
      isNavigationCollapsed,
      modalProps,
      wrapper
    };
  }
});
var _sfc_render$k = function render45() {
  var _vm = this, _c = _vm._self._c;
  _vm._self._setupProxy;
  return _vm.open ? _c("NcModal", _vm._b({ staticClass: "dialog__modal", attrs: { "enable-slideshow": false, "enable-swipe": false }, on: { "close": _vm.handleClosed, "update:show": function($event) {
    return _vm.handleClosing();
  } } }, "NcModal", _vm.modalProps, false), [_c("h2", { staticClass: "dialog__name", attrs: { "id": _vm.navigationId }, domProps: { "textContent": _vm._s(_vm.name) } }), _c(_vm.dialogTagName, _vm._g({ ref: "dialogElement", tag: "component", staticClass: "dialog", class: _vm.dialogClasses }, _vm.dialogListeners), [_c("div", { ref: "wrapper", class: ["dialog__wrapper", { "dialog__wrapper--collapsed": _vm.isNavigationCollapsed }] }, [_vm.hasNavigation ? _c("nav", { staticClass: "dialog__navigation", class: _vm.navigationClasses, attrs: { "aria-label": _vm.navigationAriaLabelAttr, "aria-labelledby": _vm.navigationAriaLabelledbyAttr } }, [_vm._t("navigation", null, { "isCollapsed": _vm.isNavigationCollapsed })], 2) : _vm._e(), _c("div", { staticClass: "dialog__content", class: _vm.contentClasses }, [_vm._t("default", function() {
    return [_c("p", { staticClass: "dialog__text" }, [_vm._v(" " + _vm._s(_vm.message) + " ")])];
  })], 2)]), _c("div", { staticClass: "dialog__actions" }, [_vm._t("actions", function() {
    return _vm._l(_vm.buttons, function(button, idx) {
      return _c("NcDialogButton", _vm._b({ key: idx, on: { "click": (_2, result) => _vm.handleButtonClose(button, result) } }, "NcDialogButton", button, false));
    });
  })], 2)])], 1) : _vm._e();
};
var _sfc_staticRenderFns$k = [];
var __component__$k = /* @__PURE__ */ normalizeComponent$3(
  _sfc_main$k,
  _sfc_render$k,
  _sfc_staticRenderFns$k,
  false,
  null,
  "1aa5fbdd"
);
const NcDialog = __component__$k.exports;
const _sfc_main$j = {
  name: "BookmarkIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$j = function render46() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon bookmark-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M17,3H7A2,2 0 0,0 5,5V21L12,18L19,21V5C19,3.89 18.1,3 17,3Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$j = [];
var __component__$j = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$j,
  _sfc_render$j,
  _sfc_staticRenderFns$j,
  false,
  null,
  null
);
const BookmarkIcon = __component__$j.exports;
const _sfc_main$i = {
  name: "ContentCopyIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$i = function render47() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon content-copy-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$i = [];
var __component__$i = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$i,
  _sfc_render$i,
  _sfc_staticRenderFns$i,
  false,
  null,
  null
);
const ContentCopyIcon = __component__$i.exports;
const _sfc_main$h = {
  name: "BookmarksWidget",
  components: {
    NcButton,
    NcDialog,
    NcLoadingIcon,
    BookmarkIcon,
    AlertCircleIcon,
    OpenInNewIcon,
    RefreshIcon,
    PlusIcon,
    ContentCopyIcon
  },
  props: {
    widget: {
      type: Object,
      required: true
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    return {
      bookmarks: [],
      loading: true,
      error: null,
      searchQuery: "",
      showAddBookmark: false,
      newBookmark: {
        title: "",
        url: "",
        description: ""
      }
    };
  },
  computed: {
    displayMode() {
      if (this.widget.w <= 2 || this.widget.h <= 2) {
        return "compact";
      }
      return "full";
    },
    recentBookmarks() {
      return [...this.bookmarks].sort((a, b) => {
        if (a.lastAccessed && b.lastAccessed) {
          return b.lastAccessed - a.lastAccessed;
        }
        return b.added - a.added;
      });
    },
    filteredBookmarks() {
      if (!this.searchQuery) {
        return this.recentBookmarks;
      }
      const query2 = this.searchQuery.toLowerCase();
      return this.bookmarks.filter(
        (bookmark) => bookmark.title.toLowerCase().includes(query2) || bookmark.url.toLowerCase().includes(query2) || bookmark.description && bookmark.description.toLowerCase().includes(query2)
      );
    }
  },
  async mounted() {
    await this.loadBookmarks();
  },
  methods: {
    t: translate,
    async loadBookmarks() {
      try {
        this.loading = true;
        this.error = null;
        const response = await cancelableClient.get(_("/apps/dashy/api/bookmarks"));
        this.bookmarks = response.data.bookmarks || [];
      } catch (error) {
        console.error("Failed to load bookmarks:", error);
        if (error.response?.status === 404) {
          this.error = translate("dashy", "Bookmarks app not found or not accessible");
        } else {
          this.error = translate("dashy", "Failed to load bookmarks");
        }
      } finally {
        this.loading = false;
      }
    },
    openBookmark(bookmark) {
      this.trackBookmarkAccess(bookmark.id);
      window.open(bookmark.url, "_blank");
    },
    async trackBookmarkAccess(bookmarkId) {
      try {
        await cancelableClient.post(_(`/apps/dashy/api/bookmarks/${bookmarkId}/access`));
      } catch (error) {
        console.debug("Failed to track bookmark access:", error);
      }
    },
    openBookmarksApp() {
      if (this.isBookmarksAppAvailable()) {
        window.open(_("/apps/bookmarks"), "_blank");
      } else {
        this.showAddBookmark = true;
      }
    },
    copyBookmark(bookmark) {
      navigator.clipboard.writeText(bookmark.url).then(() => {
      }).catch((err) => {
        console.error("Failed to copy bookmark URL:", err);
      });
    },
    closeAddBookmark() {
      this.showAddBookmark = false;
      this.newBookmark = { title: "", url: "", description: "" };
    },
    async saveBookmark() {
      try {
        if (!this.newBookmark.url) return;
        const bookmarkData = {
          title: this.newBookmark.title || this.newBookmark.url,
          url: this.newBookmark.url,
          description: this.newBookmark.description
        };
        await cancelableClient.post(_("/apps/dashy/api/bookmarks"), bookmarkData);
        await this.loadBookmarks();
        this.closeAddBookmark();
      } catch (error) {
        console.error("Failed to save bookmark:", error);
      }
    },
    isBookmarksAppAvailable() {
      return document.querySelector('a[href*="/apps/bookmarks"]') !== null;
    }
  }
};
var _sfc_render$h = function render48() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "bookmarks-widget" }, [_vm.loading ? _c("div", { staticClass: "loading" }, [_c("NcLoadingIcon", { attrs: { "size": 24 } }), _c("p", [_vm._v(_vm._s(_vm.t("dashy", "Loading bookmarks...")))])], 1) : _vm.error ? _c("div", { staticClass: "error" }, [_c("AlertCircleIcon", { attrs: { "size": 24 } }), _c("p", [_vm._v(_vm._s(_vm.error))])], 1) : _c("div", [_vm.displayMode === "compact" ? _c("div", { staticClass: "bookmarks-compact" }, [_c("div", { staticClass: "bookmarks-count" }, [_c("BookmarkIcon", { attrs: { "size": 20 } }), _c("span", [_vm._v(_vm._s(_vm.bookmarks.length) + " " + _vm._s(_vm.t("dashy", "bookmarks")))])], 1), _vm.recentBookmarks.length > 0 ? _c("div", { staticClass: "recent-bookmarks" }, _vm._l(_vm.recentBookmarks.slice(0, 3), function(bookmark) {
    return _c("div", { key: bookmark.id, staticClass: "bookmark-item compact", on: { "click": function($event) {
      return _vm.openBookmark(bookmark);
    } } }, [bookmark.favicon ? _c("img", { staticClass: "bookmark-favicon", attrs: { "src": bookmark.favicon, "alt": bookmark.title } }) : _c("BookmarkIcon", { attrs: { "size": 16 } }), _c("span", { staticClass: "bookmark-title" }, [_vm._v(_vm._s(bookmark.title))])], 1);
  }), 0) : _vm._e()]) : _c("div", { staticClass: "bookmarks-list" }, [_c("div", { staticClass: "bookmarks-header" }, [_c("h4", [_vm._v(_vm._s(_vm.t("dashy", "Bookmarks")))]), _c("div", { staticClass: "header-actions" }, [_c("NcButton", { attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Add bookmark") }, on: { "click": function($event) {
    _vm.showAddBookmark = true;
  } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("PlusIcon", { attrs: { "size": 16 } })];
  }, proxy: true }]) }), _c("NcButton", { attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Refresh") }, on: { "click": _vm.loadBookmarks }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("RefreshIcon", { attrs: { "size": 16 } })];
  }, proxy: true }]) }), _c("NcButton", { attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Open Bookmarks app") }, on: { "click": _vm.openBookmarksApp }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("OpenInNewIcon", { attrs: { "size": 16 } })];
  }, proxy: true }]) })], 1)]), _vm.bookmarks.length > 5 ? _c("div", { staticClass: "bookmarks-search" }, [_c("input", { directives: [{ name: "model", rawName: "v-model", value: _vm.searchQuery, expression: "searchQuery" }], staticClass: "search-input", attrs: { "type": "text", "placeholder": _vm.t("dashy", "Search bookmarks...") }, domProps: { "value": _vm.searchQuery }, on: { "input": function($event) {
    if ($event.target.composing) return;
    _vm.searchQuery = $event.target.value;
  } } })]) : _vm._e(), _c("div", { staticClass: "bookmark-list" }, _vm._l(_vm.filteredBookmarks.slice(0, _vm.settings.maxBookmarks || 15), function(bookmark) {
    return _c("div", { key: bookmark.id, staticClass: "bookmark-item", on: { "click": function($event) {
      return _vm.openBookmark(bookmark);
    } } }, [_c("div", { staticClass: "bookmark-icon" }, [bookmark.favicon ? _c("img", { staticClass: "bookmark-favicon", attrs: { "src": bookmark.favicon, "alt": bookmark.title } }) : _c("BookmarkIcon", { attrs: { "size": 20 } })], 1), _c("div", { staticClass: "bookmark-info" }, [_c("div", { staticClass: "bookmark-title" }, [_vm._v(_vm._s(bookmark.title))]), _c("div", { staticClass: "bookmark-url" }, [_vm._v(_vm._s(bookmark.url))]), bookmark.description ? _c("div", { staticClass: "bookmark-description" }, [_vm._v(_vm._s(bookmark.description))]) : _vm._e()]), _c("div", { staticClass: "bookmark-actions" }, [_c("NcButton", { attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Copy link") }, on: { "click": function($event) {
      $event.stopPropagation();
      return _vm.copyBookmark(bookmark);
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("ContentCopyIcon", { attrs: { "size": 16 } })];
    }, proxy: true }], null, true) })], 1)]);
  }), 0)])]), _vm.showAddBookmark ? _c("NcDialog", { attrs: { "name": _vm.t("dashy", "Add Bookmark") }, on: { "closing": _vm.closeAddBookmark }, scopedSlots: _vm._u([{ key: "actions", fn: function() {
    return [_c("NcButton", { on: { "click": _vm.closeAddBookmark } }, [_vm._v(" " + _vm._s(_vm.t("dashy", "Cancel")) + " ")]), _c("NcButton", { attrs: { "type": "primary" }, on: { "click": _vm.saveBookmark } }, [_vm._v(" " + _vm._s(_vm.t("dashy", "Add Bookmark")) + " ")])];
  }, proxy: true }], null, false, 2433082951) }, [_c("div", { staticClass: "add-bookmark-content" }, [_c("input", { directives: [{ name: "model", rawName: "v-model", value: _vm.newBookmark.title, expression: "newBookmark.title" }], staticClass: "bookmark-input", attrs: { "type": "text", "placeholder": _vm.t("dashy", "Bookmark title...") }, domProps: { "value": _vm.newBookmark.title }, on: { "input": function($event) {
    if ($event.target.composing) return;
    _vm.$set(_vm.newBookmark, "title", $event.target.value);
  } } }), _c("input", { directives: [{ name: "model", rawName: "v-model", value: _vm.newBookmark.url, expression: "newBookmark.url" }], staticClass: "bookmark-input", attrs: { "type": "url", "placeholder": _vm.t("dashy", "https://example.com") }, domProps: { "value": _vm.newBookmark.url }, on: { "input": function($event) {
    if ($event.target.composing) return;
    _vm.$set(_vm.newBookmark, "url", $event.target.value);
  } } }), _c("textarea", { directives: [{ name: "model", rawName: "v-model", value: _vm.newBookmark.description, expression: "newBookmark.description" }], staticClass: "bookmark-textarea", attrs: { "placeholder": _vm.t("dashy", "Description (optional)..."), "rows": "3" }, domProps: { "value": _vm.newBookmark.description }, on: { "input": function($event) {
    if ($event.target.composing) return;
    _vm.$set(_vm.newBookmark, "description", $event.target.value);
  } } })])]) : _vm._e()], 1);
};
var _sfc_staticRenderFns$h = [];
var __component__$h = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$h,
  _sfc_render$h,
  _sfc_staticRenderFns$h,
  false,
  null,
  "4d9cc55c"
);
const BookmarksWidget = __component__$h.exports;
const _sfc_main$g = {
  name: "AiChatWidget",
  props: {
    widget: Object,
    settings: Object
  },
  data() {
    return {
      userInput: "",
      messages: [],
      loading: false,
      error: ""
    };
  },
  methods: {
    t: translate,
    async sendMessage() {
      if (!this.settings.geminiApiKey) {
        this.error = "API-Key fehlt!";
        return;
      }
      const userText = this.userInput.trim();
      if (!userText) return;
      this.messages.push({ role: "user", text: userText });
      this.userInput = "";
      this.loading = true;
      this.error = "";
      try {
        const res = await fetch("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-goog-api-key": this.settings.geminiApiKey
          },
          body: JSON.stringify({
            contents: [
              { parts: [{ text: userText }] }
            ]
          })
        });
        const data = await res.json();
        const aiText = data?.candidates?.[0]?.content?.parts?.[0]?.text || "Keine Antwort.";
        this.messages.push({ role: "ai", text: aiText });
      } catch (e) {
        this.error = "Fehler bei der Anfrage.";
      } finally {
        this.loading = false;
      }
    }
  }
};
var _sfc_render$g = function render49() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "ai-chat-widget" }, [_c("div", { staticClass: "chat-history" }, _vm._l(_vm.messages, function(msg, idx) {
    return _c("div", { key: idx, class: ["chat-row", msg.role] }, [_c("div", { staticClass: "bubble" }, [_c("span", { staticClass: "text" }, [_vm._v(_vm._s(msg.text))])])]);
  }), 0), _c("form", { on: { "submit": function($event) {
    $event.preventDefault();
    return _vm.sendMessage.apply(null, arguments);
  } } }, [_c("input", { directives: [{ name: "model", rawName: "v-model", value: _vm.userInput, expression: "userInput" }], attrs: { "placeholder": _vm.t("dashy", "Nachricht an die KI...") }, domProps: { "value": _vm.userInput }, on: { "input": function($event) {
    if ($event.target.composing) return;
    _vm.userInput = $event.target.value;
  } } }), _c("button", { attrs: { "disabled": _vm.loading || !_vm.userInput } }, [_vm._v("Senden")])]), _vm.error ? _c("div", { staticClass: "error" }, [_vm._v(_vm._s(_vm.error))]) : _vm._e()]);
};
var _sfc_staticRenderFns$g = [];
var __component__$g = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$g,
  _sfc_render$g,
  _sfc_staticRenderFns$g,
  false,
  null,
  "04983bef"
);
const AiChatWidget = __component__$g.exports;
const _sfc_main$f = {
  name: "CalendarSettings",
  props: {
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    return {
      localSettings: {
        maxEvents: 5,
        displayMode: "",
        ...this.settings
      },
      showModal: false,
      modalElement: null
    };
  },
  beforeDestroy() {
    document.removeEventListener("keydown", this.handleEscapeKey);
    this.removeModal();
  },
  methods: {
    t: translate,
    updateSettings() {
      this.$emit("update", this.localSettings);
    },
    openSettings() {
      this.showModal = true;
      this.createModal();
    },
    closeSettings() {
      this.showModal = false;
      this.removeModal();
    },
    handleEscapeKey(event) {
      if (event.key === "Escape" && this.showModal) {
        this.closeSettings();
      }
    },
    createModal() {
      if (this.modalElement) return;
      document.addEventListener("keydown", this.handleEscapeKey);
      this.modalElement = document.createElement("div");
      this.modalElement.className = "calendar-settings-overlay";
      this.modalElement.addEventListener("click", this.handleOverlayClick);
      const modalContent = document.createElement("div");
      modalContent.className = "calendar-settings-modal";
      modalContent.addEventListener("click", (e) => e.stopPropagation());
      modalContent.innerHTML = this.getModalHTML();
      this.modalElement.appendChild(modalContent);
      document.body.appendChild(this.modalElement);
      this.bindModalEvents();
    },
    removeModal() {
      if (this.modalElement) {
        document.removeEventListener("keydown", this.handleEscapeKey);
        this.modalElement.removeEventListener("click", this.handleOverlayClick);
        document.body.removeChild(this.modalElement);
        this.modalElement = null;
      }
    },
    handleOverlayClick() {
      this.closeSettings();
    },
    getModalHTML() {
      return `
				<div class="modal-header">
					<h3>${translate("dashy", "Calendar Settings")}</h3>
					<button class="close-btn" type="button" title="Close">✕</button>
				</div>
				<form class="settings-form">
					<div class="form-group">
						<label for="maxEvents">${translate("dashy", "Maximum events to show")}</label>
						<input 
							type="number" 
							id="maxEvents" 
							min="1" 
							max="20" 
							value="${this.localSettings.maxEvents}"
						>
					</div>
					<div class="form-group">
						<label for="displayMode">${translate("dashy", "Display mode")}</label>
						<select id="displayMode">
							<option value="" ${this.localSettings.displayMode === "" ? "selected" : ""}>${translate("dashy", "Auto (based on widget size)")}</option>
							<option value="compact" ${this.localSettings.displayMode === "compact" ? "selected" : ""}>${translate("dashy", "Compact list")}</option>
							<option value="list" ${this.localSettings.displayMode === "list" ? "selected" : ""}>${translate("dashy", "Simple list")}</option>
							<option value="detailed" ${this.localSettings.displayMode === "detailed" ? "selected" : ""}>${translate("dashy", "Detailed list")}</option>
							<option value="calendar" ${this.localSettings.displayMode === "calendar" ? "selected" : ""}>${translate("dashy", "Calendar grid")}</option>
						</select>
					</div>
					<div class="form-actions">
						<button type="button" class="btn-cancel">${translate("dashy", "Cancel")}</button>
						<button type="submit" class="btn-save">${translate("dashy", "Save")}</button>
					</div>
				</form>
			`;
    },
    bindModalEvents() {
      if (!this.modalElement) return;
      const form = this.modalElement.querySelector(".settings-form");
      form.addEventListener("submit", (e) => {
        e.preventDefault();
        this.saveSettings();
      });
      const closeBtn = this.modalElement.querySelector(".close-btn");
      if (closeBtn) {
        closeBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.closeSettings();
        });
      }
      const cancelBtn = this.modalElement.querySelector(".btn-cancel");
      if (cancelBtn) {
        cancelBtn.addEventListener("click", (e) => {
          e.preventDefault();
          this.closeSettings();
        });
      }
      const maxEventsInput = this.modalElement.querySelector("#maxEvents");
      const displayModeSelect = this.modalElement.querySelector("#displayMode");
      maxEventsInput?.addEventListener("input", (e) => {
        this.localSettings.maxEvents = parseInt(e.target.value) || 5;
      });
      displayModeSelect?.addEventListener("change", (e) => {
        this.localSettings.displayMode = e.target.value;
      });
    },
    saveSettings() {
      const maxEventsInput = this.modalElement.querySelector("#maxEvents");
      const displayModeSelect = this.modalElement.querySelector("#displayMode");
      this.localSettings.maxEvents = parseInt(maxEventsInput.value) || 5;
      this.localSettings.displayMode = displayModeSelect.value;
      this.updateSettings();
      this.closeSettings();
    }
  }
};
var _sfc_render$f = function render50() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "calendar-settings" });
};
var _sfc_staticRenderFns$f = [];
var __component__$f = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$f,
  _sfc_render$f,
  _sfc_staticRenderFns$f,
  false,
  null,
  "1e5411cd"
);
const CalendarSettings = __component__$f.exports;
const _sfc_main$e = {
  name: "TodoSettings",
  props: {
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    return {
      localSettings: {
        maxTasks: 10,
        displayMode: "",
        showCompleted: true,
        showHighPriority: true,
        showMediumPriority: true,
        showLowPriority: true,
        refreshInterval: 5,
        ...this.settings
      },
      showModal: false,
      modalElement: null
    };
  },
  mounted() {
    console.log("TodoSettings component mounted", this);
  },
  beforeDestroy() {
    document.removeEventListener("keydown", this.handleEscapeKey);
    this.removeModal();
  },
  methods: {
    t: translate,
    updateSettings() {
      this.$emit("update", this.localSettings);
    },
    openSettings() {
      this.showModal = true;
      this.createModal();
    },
    closeSettings() {
      this.showModal = false;
      this.removeModal();
    },
    handleEscapeKey(event) {
      if (event.key === "Escape" && this.showModal) {
        this.closeSettings();
      }
    },
    createModal() {
      if (this.modalElement) return;
      document.addEventListener("keydown", this.handleEscapeKey);
      this.modalElement = document.createElement("div");
      this.modalElement.className = "todo-settings-overlay";
      this.modalElement.addEventListener("click", this.handleOverlayClick);
      const modalContent = document.createElement("div");
      modalContent.className = "todo-settings-modal";
      modalContent.addEventListener("click", (e) => e.stopPropagation());
      modalContent.innerHTML = this.getModalHTML();
      this.modalElement.appendChild(modalContent);
      document.body.appendChild(this.modalElement);
      this.bindModalEvents();
    },
    removeModal() {
      if (this.modalElement) {
        document.removeEventListener("keydown", this.handleEscapeKey);
        this.modalElement.removeEventListener("click", this.handleOverlayClick);
        document.body.removeChild(this.modalElement);
        this.modalElement = null;
      }
    },
    handleOverlayClick() {
      this.closeSettings();
    },
    getModalHTML() {
      return `
				<div class="modal-header">
					<h3>${translate("dashy", "Todo Settings")}</h3>
					<button class="close-btn" type="button" title="Close">✕</button>
				</div>
				<form class="settings-form">
					<div class="form-group">
						<label for="maxTasks">${translate("dashy", "Maximum tasks to show")}</label>
						<input 
							type="number" 
							id="maxTasks" 
							min="1" 
							max="50" 
							value="${this.localSettings.maxTasks}"
						>
					</div>
					<div class="form-group">
						<label for="displayMode">${translate("dashy", "Display mode")}</label>
						<select id="displayMode">
							<option value="" ${this.localSettings.displayMode === "" ? "selected" : ""}>${translate("dashy", "Auto (based on widget size)")}</option>
							<option value="compact" ${this.localSettings.displayMode === "compact" ? "selected" : ""}>${translate("dashy", "Compact")}</option>
							<option value="list" ${this.localSettings.displayMode === "list" ? "selected" : ""}>${translate("dashy", "List")}</option>
							<option value="detailed" ${this.localSettings.displayMode === "detailed" ? "selected" : ""}>${translate("dashy", "Detailed")}</option>
						</select>
					</div>
					<div class="form-group">
						<label for="refreshInterval">${translate("dashy", "Refresh interval (minutes)")}</label>
						<select id="refreshInterval">
							<option value="1" ${this.localSettings.refreshInterval === 1 ? "selected" : ""}>${translate("dashy", "1 minute")}</option>
							<option value="5" ${this.localSettings.refreshInterval === 5 ? "selected" : ""}>${translate("dashy", "5 minutes")}</option>
							<option value="10" ${this.localSettings.refreshInterval === 10 ? "selected" : ""}>${translate("dashy", "10 minutes")}</option>
							<option value="30" ${this.localSettings.refreshInterval === 30 ? "selected" : ""}>${translate("dashy", "30 minutes")}</option>
							<option value="60" ${this.localSettings.refreshInterval === 60 ? "selected" : ""}>${translate("dashy", "1 hour")}</option>
						</select>
					</div>
					<div class="form-group">
						<label class="checkbox-label">
							<input type="checkbox" id="showCompleted" ${this.localSettings.showCompleted ? "checked" : ""}>
							<span>${translate("dashy", "Include completed tasks in the list")}</span>
						</label>
					</div>
					<div class="form-group">
						<label>${translate("dashy", "Priority filter")}</label>
						<div class="priority-filters">
							<label class="checkbox-label priority-option">
								<input type="checkbox" id="showHighPriority" ${this.localSettings.showHighPriority ? "checked" : ""}>
								<span>🔴 ${translate("dashy", "High priority")}</span>
							</label>
							<label class="checkbox-label priority-option">
								<input type="checkbox" id="showMediumPriority" ${this.localSettings.showMediumPriority ? "checked" : ""}>
								<span>🟡 ${translate("dashy", "Medium priority")}</span>
							</label>
							<label class="checkbox-label priority-option">
								<input type="checkbox" id="showLowPriority" ${this.localSettings.showLowPriority ? "checked" : ""}>
								<span>🔵 ${translate("dashy", "Low priority")}</span>
							</label>
						</div>
					</div>
					<div class="form-actions">
						<button type="button" class="btn-cancel">${translate("dashy", "Cancel")}</button>
						<button type="submit" class="btn-save">${translate("dashy", "Save")}</button>
					</div>
				</form>
			`;
    },
    bindModalEvents() {
      if (!this.modalElement) return;
      const form = this.modalElement.querySelector(".settings-form");
      form.addEventListener("submit", (e) => {
        e.preventDefault();
        this.saveSettings();
      });
      const closeBtn = this.modalElement.querySelector(".close-btn");
      if (closeBtn) {
        closeBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.closeSettings();
        });
      }
      const cancelBtn = this.modalElement.querySelector(".btn-cancel");
      if (cancelBtn) {
        cancelBtn.addEventListener("click", (e) => {
          e.preventDefault();
          this.closeSettings();
        });
      }
      const maxTasksInput = this.modalElement.querySelector("#maxTasks");
      const displayModeSelect = this.modalElement.querySelector("#displayMode");
      const refreshIntervalSelect = this.modalElement.querySelector("#refreshInterval");
      const showCompletedInput = this.modalElement.querySelector("#showCompleted");
      const showHighPriorityInput = this.modalElement.querySelector("#showHighPriority");
      const showMediumPriorityInput = this.modalElement.querySelector("#showMediumPriority");
      const showLowPriorityInput = this.modalElement.querySelector("#showLowPriority");
      maxTasksInput?.addEventListener("input", (e) => {
        this.localSettings.maxTasks = parseInt(e.target.value) || 10;
      });
      displayModeSelect?.addEventListener("change", (e) => {
        this.localSettings.displayMode = e.target.value;
      });
      refreshIntervalSelect?.addEventListener("change", (e) => {
        this.localSettings.refreshInterval = parseInt(e.target.value) || 5;
      });
      showCompletedInput?.addEventListener("change", (e) => {
        this.localSettings.showCompleted = e.target.checked;
      });
      showHighPriorityInput?.addEventListener("change", (e) => {
        this.localSettings.showHighPriority = e.target.checked;
      });
      showMediumPriorityInput?.addEventListener("change", (e) => {
        this.localSettings.showMediumPriority = e.target.checked;
      });
      showLowPriorityInput?.addEventListener("change", (e) => {
        this.localSettings.showLowPriority = e.target.checked;
      });
    },
    saveSettings() {
      const maxTasksInput = this.modalElement.querySelector("#maxTasks");
      const displayModeSelect = this.modalElement.querySelector("#displayMode");
      const refreshIntervalSelect = this.modalElement.querySelector("#refreshInterval");
      const showCompletedInput = this.modalElement.querySelector("#showCompleted");
      const showHighPriorityInput = this.modalElement.querySelector("#showHighPriority");
      const showMediumPriorityInput = this.modalElement.querySelector("#showMediumPriority");
      const showLowPriorityInput = this.modalElement.querySelector("#showLowPriority");
      this.localSettings.maxTasks = parseInt(maxTasksInput.value) || 10;
      this.localSettings.displayMode = displayModeSelect.value;
      this.localSettings.refreshInterval = parseInt(refreshIntervalSelect.value) || 5;
      this.localSettings.showCompleted = showCompletedInput.checked;
      this.localSettings.showHighPriority = showHighPriorityInput.checked;
      this.localSettings.showMediumPriority = showMediumPriorityInput.checked;
      this.localSettings.showLowPriority = showLowPriorityInput.checked;
      this.updateSettings();
      this.closeSettings();
    }
  }
};
var _sfc_render$e = function render51() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "todo-settings" });
};
var _sfc_staticRenderFns$e = [];
var __component__$e = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$e,
  _sfc_render$e,
  _sfc_staticRenderFns$e,
  false,
  null,
  "15b08459"
);
const TodoSettings = __component__$e.exports;
const _sfc_main$d = {
  name: "ClockSettings",
  props: {
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    return {
      localSettings: {
        format24h: false,
        showSeconds: false,
        showTimezone: false,
        ...this.settings
      },
      showModal: false,
      modalElement: null
    };
  },
  beforeDestroy() {
    document.removeEventListener("keydown", this.handleEscapeKey);
    this.removeModal();
  },
  methods: {
    t: translate,
    updateSettings() {
      this.$emit("update", this.localSettings);
    },
    openSettings() {
      this.showModal = true;
      this.createModal();
    },
    closeSettings() {
      this.showModal = false;
      this.removeModal();
    },
    handleEscapeKey(event) {
      if (event.key === "Escape" && this.showModal) {
        this.closeSettings();
      }
    },
    createModal() {
      if (this.modalElement) return;
      document.addEventListener("keydown", this.handleEscapeKey);
      this.modalElement = document.createElement("div");
      this.modalElement.className = "clock-settings-overlay";
      this.modalElement.addEventListener("click", this.handleOverlayClick);
      const modalContent = document.createElement("div");
      modalContent.className = "clock-settings-modal";
      modalContent.addEventListener("click", (e) => e.stopPropagation());
      modalContent.innerHTML = this.getModalHTML();
      this.modalElement.appendChild(modalContent);
      document.body.appendChild(this.modalElement);
      this.bindModalEvents();
    },
    removeModal() {
      if (this.modalElement) {
        document.removeEventListener("keydown", this.handleEscapeKey);
        this.modalElement.removeEventListener("click", this.handleOverlayClick);
        document.body.removeChild(this.modalElement);
        this.modalElement = null;
      }
    },
    handleOverlayClick() {
      this.closeSettings();
    },
    getModalHTML() {
      return `
				<div class="modal-header">
					<h3>${translate("dashy", "Clock Settings")}</h3>
					<button class="close-btn" type="button" title="Close">✕</button>
				</div>
				<form class="settings-form">
					<div class="form-group">
						<label class="checkbox-label">
							<input type="checkbox" id="format24h" ${this.localSettings.format24h ? "checked" : ""}>
							<span>${translate("dashy", "Use 24-hour format")}</span>
						</label>
					</div>
					<div class="form-group">
						<label class="checkbox-label">
							<input type="checkbox" id="showSeconds" ${this.localSettings.showSeconds ? "checked" : ""}>
							<span>${translate("dashy", "Show seconds")}</span>
						</label>
					</div>
					<div class="form-group">
						<label class="checkbox-label">
							<input type="checkbox" id="showTimezone" ${this.localSettings.showTimezone ? "checked" : ""}>
							<span>${translate("dashy", "Show timezone")}</span>
						</label>
					</div>
					<div class="form-actions">
						<button type="button" class="btn-cancel">${translate("dashy", "Cancel")}</button>
						<button type="submit" class="btn-save">${translate("dashy", "Save")}</button>
					</div>
				</form>
			`;
    },
    bindModalEvents() {
      if (!this.modalElement) return;
      const form = this.modalElement.querySelector(".settings-form");
      form.addEventListener("submit", (e) => {
        e.preventDefault();
        this.saveSettings();
      });
      const closeBtn = this.modalElement.querySelector(".close-btn");
      if (closeBtn) {
        closeBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.closeSettings();
        });
      }
      const cancelBtn = this.modalElement.querySelector(".btn-cancel");
      if (cancelBtn) {
        cancelBtn.addEventListener("click", (e) => {
          e.preventDefault();
          this.closeSettings();
        });
      }
      const format24hInput = this.modalElement.querySelector("#format24h");
      const showSecondsInput = this.modalElement.querySelector("#showSeconds");
      const showTimezoneInput = this.modalElement.querySelector("#showTimezone");
      format24hInput?.addEventListener("change", (e) => {
        this.localSettings.format24h = e.target.checked;
      });
      showSecondsInput?.addEventListener("change", (e) => {
        this.localSettings.showSeconds = e.target.checked;
      });
      showTimezoneInput?.addEventListener("change", (e) => {
        this.localSettings.showTimezone = e.target.checked;
      });
    },
    saveSettings() {
      const format24hInput = this.modalElement.querySelector("#format24h");
      const showSecondsInput = this.modalElement.querySelector("#showSeconds");
      const showTimezoneInput = this.modalElement.querySelector("#showTimezone");
      this.localSettings.format24h = format24hInput.checked;
      this.localSettings.showSeconds = showSecondsInput.checked;
      this.localSettings.showTimezone = showTimezoneInput.checked;
      this.updateSettings();
      this.closeSettings();
    }
  }
};
var _sfc_render$d = function render52() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "clock-settings" });
};
var _sfc_staticRenderFns$d = [];
var __component__$d = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$d,
  _sfc_render$d,
  _sfc_staticRenderFns$d,
  false,
  null,
  "e9f8e914"
);
const ClockSettings = __component__$d.exports;
const _sfc_main$c = {
  name: "WeatherSettings",
  props: {
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    return {
      localSettings: {
        location: "",
        unit: "C",
        showDetails: true,
        ...this.settings
      },
      showModal: false,
      modalElement: null
    };
  },
  beforeDestroy() {
    document.removeEventListener("keydown", this.handleEscapeKey);
    this.removeModal();
  },
  methods: {
    t: translate,
    updateSettings() {
      this.$emit("update", this.localSettings);
    },
    openSettings() {
      this.showModal = true;
      this.createModal();
    },
    closeSettings() {
      this.showModal = false;
      this.removeModal();
    },
    handleEscapeKey(event) {
      if (event.key === "Escape" && this.showModal) {
        this.closeSettings();
      }
    },
    createModal() {
      if (this.modalElement) return;
      document.addEventListener("keydown", this.handleEscapeKey);
      this.modalElement = document.createElement("div");
      this.modalElement.className = "weather-settings-overlay";
      this.modalElement.addEventListener("click", this.handleOverlayClick);
      const modalContent = document.createElement("div");
      modalContent.className = "weather-settings-modal";
      modalContent.addEventListener("click", (e) => e.stopPropagation());
      modalContent.innerHTML = this.getModalHTML();
      this.modalElement.appendChild(modalContent);
      document.body.appendChild(this.modalElement);
      this.bindModalEvents();
    },
    removeModal() {
      if (this.modalElement) {
        document.removeEventListener("keydown", this.handleEscapeKey);
        this.modalElement.removeEventListener("click", this.handleOverlayClick);
        document.body.removeChild(this.modalElement);
        this.modalElement = null;
      }
    },
    handleOverlayClick() {
      this.closeSettings();
    },
    getModalHTML() {
      return `
				<div class="modal-header">
					<h3>${translate("dashy", "Weather Settings")}</h3>
					<button class="close-btn" type="button" title="Close">✕</button>
				</div>
				<form class="settings-form">
					<div class="form-group">
						<label for="location">${translate("dashy", "Location")}</label>
						<input 
							type="text" 
							id="location" 
							placeholder="${translate("dashy", "Enter location...")}"
							value="${this.localSettings.location}"
						>
					</div>
					<div class="form-group">
						<label for="unit">${translate("dashy", "Temperature unit")}</label>
						<select id="unit">
							<option value="C" ${this.localSettings.unit === "C" ? "selected" : ""}>${translate("dashy", "Celsius (°C)")}</option>
							<option value="F" ${this.localSettings.unit === "F" ? "selected" : ""}>${translate("dashy", "Fahrenheit (°F)")}</option>
						</select>
					</div>
					<div class="form-group">
						<label class="checkbox-label">
							<input type="checkbox" id="showDetails" ${this.localSettings.showDetails ? "checked" : ""}>
							<span>${translate("dashy", "Show detailed information")}</span>
						</label>
					</div>
					<div class="form-actions">
						<button type="button" class="btn-cancel">${translate("dashy", "Cancel")}</button>
						<button type="submit" class="btn-save">${translate("dashy", "Save")}</button>
					</div>
				</form>
			`;
    },
    bindModalEvents() {
      if (!this.modalElement) return;
      const form = this.modalElement.querySelector(".settings-form");
      form.addEventListener("submit", (e) => {
        e.preventDefault();
        this.saveSettings();
      });
      const closeBtn = this.modalElement.querySelector(".close-btn");
      if (closeBtn) {
        closeBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.closeSettings();
        });
      }
      const cancelBtn = this.modalElement.querySelector(".btn-cancel");
      if (cancelBtn) {
        cancelBtn.addEventListener("click", (e) => {
          e.preventDefault();
          this.closeSettings();
        });
      }
      const locationInput = this.modalElement.querySelector("#location");
      const unitSelect = this.modalElement.querySelector("#unit");
      const showDetailsInput = this.modalElement.querySelector("#showDetails");
      locationInput?.addEventListener("input", (e) => {
        this.localSettings.location = e.target.value;
      });
      unitSelect?.addEventListener("change", (e) => {
        this.localSettings.unit = e.target.value;
      });
      showDetailsInput?.addEventListener("change", (e) => {
        this.localSettings.showDetails = e.target.checked;
      });
    },
    saveSettings() {
      const locationInput = this.modalElement.querySelector("#location");
      const unitSelect = this.modalElement.querySelector("#unit");
      const showDetailsInput = this.modalElement.querySelector("#showDetails");
      this.localSettings.location = locationInput.value;
      this.localSettings.unit = unitSelect.value;
      this.localSettings.showDetails = showDetailsInput.checked;
      this.updateSettings();
      this.closeSettings();
    }
  }
};
var _sfc_render$c = function render53() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "weather-settings" });
};
var _sfc_staticRenderFns$c = [];
var __component__$c = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$c,
  _sfc_render$c,
  _sfc_staticRenderFns$c,
  false,
  null,
  "38b2fc3a"
);
const WeatherSettings = __component__$c.exports;
const _sfc_main$b = {
  name: "FilesSettings",
  props: {
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    return {
      localSettings: {
        maxFiles: 15,
        defaultView: "recent",
        showFileSize: true,
        showModifiedDate: true,
        showDirectories: false,
        ...this.settings
      },
      showModal: false,
      modalElement: null
    };
  },
  mounted() {
    console.log("FilesSettings component mounted", this);
  },
  beforeDestroy() {
    document.removeEventListener("keydown", this.handleEscapeKey);
    this.removeModal();
  },
  methods: {
    t: translate,
    updateSettings() {
      this.$emit("update", this.localSettings);
    },
    openSettings() {
      console.log("Opening files settings modal");
      this.showModal = true;
      this.createModal();
    },
    closeSettings() {
      this.showModal = false;
      this.removeModal();
    },
    handleEscapeKey(event) {
      if (event.key === "Escape" && this.showModal) {
        this.closeSettings();
      }
    },
    createModal() {
      if (this.modalElement) return;
      document.addEventListener("keydown", this.handleEscapeKey);
      this.modalElement = document.createElement("div");
      this.modalElement.className = "files-settings-overlay";
      this.modalElement.addEventListener("click", this.handleOverlayClick);
      const modalContent = document.createElement("div");
      modalContent.className = "files-settings-modal";
      modalContent.addEventListener("click", (e) => e.stopPropagation());
      modalContent.innerHTML = this.getModalHTML();
      this.modalElement.appendChild(modalContent);
      document.body.appendChild(this.modalElement);
      this.bindModalEvents();
    },
    removeModal() {
      if (this.modalElement) {
        document.removeEventListener("keydown", this.handleEscapeKey);
        this.modalElement.removeEventListener("click", this.handleOverlayClick);
        document.body.removeChild(this.modalElement);
        this.modalElement = null;
      }
    },
    handleOverlayClick() {
      this.closeSettings();
    },
    getModalHTML() {
      return `
				<div class="modal-header">
					<h3>${translate("dashy", "Files Settings")}</h3>
					<button class="close-btn" type="button" title="Close">✕</button>
				</div>
				<form class="settings-form">
					<div class="form-group">
						<label for="maxFiles">${translate("dashy", "Maximum files to display")}</label>
						<input 
							type="number" 
							id="maxFiles" 
							min="1" 
							max="50" 
							value="${this.localSettings.maxFiles}"
						>
						<small class="setting-description">${translate("dashy", "Maximum number of files to show in the widget (1-50)")}</small>
					</div>
					<div class="form-group">
						<label for="defaultView">${translate("dashy", "Default view")}</label>
						<select id="defaultView" value="${this.localSettings.defaultView}">
							<option value="recent">${translate("dashy", "Recent files")}</option>
							<option value="favorites">${translate("dashy", "Favorite files")}</option>
						</select>
						<small class="setting-description">${translate("dashy", "Choose which view to show by default")}</small>
					</div>
					<div class="form-group">
						<label class="checkbox-label">
							<input type="checkbox" id="showFileSize" ${this.localSettings.showFileSize ? "checked" : ""}>
							<span>${translate("dashy", "Show file sizes")}</span>
						</label>
						<small class="setting-description">${translate("dashy", "Display file sizes in the file list")}</small>
					</div>
					<div class="form-group">
						<label class="checkbox-label">
							<input type="checkbox" id="showModifiedDate" ${this.localSettings.showModifiedDate ? "checked" : ""}>
							<span>${translate("dashy", "Show modification dates")}</span>
						</label>
						<small class="setting-description">${translate("dashy", "Display when files were last modified")}</small>
					</div>
					<div class="form-group">
						<label class="checkbox-label">
							<input type="checkbox" id="showDirectories" ${this.localSettings.showDirectories ? "checked" : ""}>
							<span>${translate("dashy", "Include directories")}</span>
						</label>
						<small class="setting-description">${translate("dashy", "Show directories/folders in addition to files")}</small>
					</div>
					<div class="form-actions">
						<button type="button" class="btn-cancel">${translate("dashy", "Cancel")}</button>
						<button type="submit" class="btn-save">${translate("dashy", "Save")}</button>
					</div>
				</form>
			`;
    },
    bindModalEvents() {
      if (!this.modalElement) return;
      const form = this.modalElement.querySelector(".settings-form");
      form.addEventListener("submit", (e) => {
        e.preventDefault();
        this.saveSettings();
      });
      const closeBtn = this.modalElement.querySelector(".close-btn");
      if (closeBtn) {
        closeBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.closeSettings();
        });
      }
      const cancelBtn = this.modalElement.querySelector(".btn-cancel");
      if (cancelBtn) {
        cancelBtn.addEventListener("click", (e) => {
          e.preventDefault();
          this.closeSettings();
        });
      }
      const maxFilesInput = this.modalElement.querySelector("#maxFiles");
      const defaultViewSelect = this.modalElement.querySelector("#defaultView");
      const showFileSizeInput = this.modalElement.querySelector("#showFileSize");
      const showModifiedDateInput = this.modalElement.querySelector("#showModifiedDate");
      const showDirectoriesInput = this.modalElement.querySelector("#showDirectories");
      maxFilesInput?.addEventListener("input", (e) => {
        this.localSettings.maxFiles = parseInt(e.target.value) || 15;
      });
      defaultViewSelect?.addEventListener("change", (e) => {
        this.localSettings.defaultView = e.target.value;
      });
      showFileSizeInput?.addEventListener("change", (e) => {
        this.localSettings.showFileSize = e.target.checked;
      });
      showModifiedDateInput?.addEventListener("change", (e) => {
        this.localSettings.showModifiedDate = e.target.checked;
      });
      showDirectoriesInput?.addEventListener("change", (e) => {
        this.localSettings.showDirectories = e.target.checked;
      });
    },
    saveSettings() {
      const maxFilesInput = this.modalElement.querySelector("#maxFiles");
      const defaultViewSelect = this.modalElement.querySelector("#defaultView");
      const showFileSizeInput = this.modalElement.querySelector("#showFileSize");
      const showModifiedDateInput = this.modalElement.querySelector("#showModifiedDate");
      const showDirectoriesInput = this.modalElement.querySelector("#showDirectories");
      this.localSettings.maxFiles = parseInt(maxFilesInput.value) || 15;
      this.localSettings.defaultView = defaultViewSelect.value;
      this.localSettings.showFileSize = showFileSizeInput.checked;
      this.localSettings.showModifiedDate = showModifiedDateInput.checked;
      this.localSettings.showDirectories = showDirectoriesInput.checked;
      console.log("Saving files settings:", this.localSettings);
      this.updateSettings();
      this.closeSettings();
    }
  }
};
var _sfc_render$b = function render54() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "files-settings" });
};
var _sfc_staticRenderFns$b = [];
var __component__$b = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$b,
  _sfc_render$b,
  _sfc_staticRenderFns$b,
  false,
  null,
  null
);
const FilesSettings = __component__$b.exports;
const _sfc_main$a = {
  name: "ChevronUpIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$a = function render55() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon chevron-up-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M7.41,15.41L12,10.83L16.59,15.41L18,14L12,8L6,14L7.41,15.41Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$a = [];
var __component__$a = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$a,
  _sfc_render$a,
  _sfc_staticRenderFns$a,
  false,
  null,
  null
);
const ChevronUpIcon = __component__$a.exports;
const _sfc_main$9 = {
  name: "ChevronRightIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$9 = function render56() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon chevron-right-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$9 = [];
var __component__$9 = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$9,
  _sfc_render$9,
  _sfc_staticRenderFns$9,
  false,
  null,
  null
);
const ChevronRightIcon = __component__$9.exports;
const _sfc_main$8 = {
  name: "FolderBrowser",
  components: {
    NcButton,
    NcLoadingIcon,
    FolderIcon,
    AlertCircleIcon,
    ChevronUpIcon,
    ChevronRightIcon,
    RefreshIcon
  },
  props: {
    initialPath: {
      type: String,
      default: ""
    },
    allowCreateFolder: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      folders: [],
      loading: true,
      error: null,
      currentPath: this.initialPath,
      selectedFolder: null
    };
  },
  computed: {
    pathSegments() {
      const segments = [];
      segments.push({ name: translate("dashy", "Root"), path: "" });
      if (this.currentPath) {
        const pathParts = this.currentPath.split("/").filter((part) => part.length > 0);
        let currentPath = "";
        pathParts.forEach((part) => {
          currentPath += "/" + part;
          segments.push({
            name: part,
            path: currentPath.substring(1)
            // Remove leading slash
          });
        });
      }
      return segments;
    }
  },
  async mounted() {
    await this.loadFolders();
  },
  methods: {
    t: translate,
    async loadFolders() {
      try {
        this.loading = true;
        this.error = null;
        const response = await cancelableClient.get(_("/apps/dashy/api/folders"), {
          params: {
            path: this.currentPath
          }
        });
        this.folders = response.data.folders || [];
      } catch (error) {
        console.error("Failed to load folders:", error);
        this.error = translate("dashy", "Failed to load folders");
      } finally {
        this.loading = false;
      }
    },
    selectFolder(folder) {
      this.selectedFolder = folder;
    },
    async navigateToFolder(folder) {
      this.currentPath = folder.path;
      this.selectedFolder = null;
      await this.loadFolders();
    },
    async navigateToPath(path) {
      this.currentPath = path;
      this.selectedFolder = null;
      await this.loadFolders();
    },
    async goUp() {
      const pathParts = this.currentPath.split("/").filter((part) => part.length > 0);
      pathParts.pop();
      this.currentPath = pathParts.join("/");
      this.selectedFolder = null;
      await this.loadFolders();
    },
    getPathUpTo(index2) {
      if (index2 === 0) return "";
      const segments = this.pathSegments.slice(1, index2 + 1);
      return segments.map((s) => s.name).join("/");
    },
    confirmSelection() {
      if (this.selectedFolder) {
        this.$emit("folderSelected", this.selectedFolder);
      }
    },
    cancelSelection() {
      this.$emit("cancel");
    }
  }
};
var _sfc_render$8 = function render57() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "folder-browser" }, [_c("div", { staticClass: "folder-browser-header" }, [_c("div", { staticClass: "navigation-path" }, _vm._l(_vm.pathSegments, function(segment, index2) {
    return _c("span", { key: index2, staticClass: "path-segment" }, [index2 < _vm.pathSegments.length - 1 ? _c("button", { staticClass: "path-button", on: { "click": function($event) {
      _vm.navigateToPath(_vm.getPathUpTo(index2));
    } } }, [_vm._v(" " + _vm._s(segment.name) + " ")]) : _c("span", { staticClass: "current-segment" }, [_vm._v(_vm._s(segment.name))]), index2 < _vm.pathSegments.length - 1 ? _c("span", { staticClass: "path-separator" }, [_vm._v("/")]) : _vm._e()]);
  }), 0), _c("div", { staticClass: "folder-actions" }, [_vm.currentPath !== "" ? _c("NcButton", { attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Go up one level") }, on: { "click": _vm.goUp }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("ChevronUpIcon", { attrs: { "size": 16 } })];
  }, proxy: true }], null, false, 72223080) }) : _vm._e(), _c("NcButton", { attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Refresh") }, on: { "click": _vm.loadFolders }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("RefreshIcon", { attrs: { "size": 16 } })];
  }, proxy: true }]) })], 1)]), _vm.loading ? _c("div", { staticClass: "loading" }, [_c("NcLoadingIcon", { attrs: { "size": 24 } }), _c("p", [_vm._v(_vm._s(_vm.t("dashy", "Loading folders...")))])], 1) : _vm.error ? _c("div", { staticClass: "error" }, [_c("AlertCircleIcon", { attrs: { "size": 24 } }), _c("p", [_vm._v(_vm._s(_vm.error))])], 1) : _c("div", { staticClass: "folder-list" }, [_vm._l(_vm.folders, function(folder) {
    return _c("div", { key: folder.path, staticClass: "folder-item", class: { "selected": _vm.selectedFolder && _vm.selectedFolder.path === folder.path }, on: { "click": function($event) {
      return _vm.selectFolder(folder);
    }, "dblclick": function($event) {
      return _vm.navigateToFolder(folder);
    } } }, [_c("div", { staticClass: "folder-icon" }, [_c("FolderIcon", { attrs: { "size": 20 } })], 1), _c("div", { staticClass: "folder-info" }, [_c("div", { staticClass: "folder-name" }, [_vm._v(_vm._s(folder.name))]), _c("div", { staticClass: "folder-path" }, [_vm._v(_vm._s(folder.relativePath || "/"))])]), _c("div", { staticClass: "folder-actions" }, [_c("NcButton", { attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Open folder") }, on: { "click": function($event) {
      $event.stopPropagation();
      return _vm.navigateToFolder(folder);
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("ChevronRightIcon", { attrs: { "size": 16 } })];
    }, proxy: true }], null, true) })], 1)]);
  }), _vm.folders.length === 0 ? _c("div", { staticClass: "empty-folder" }, [_c("FolderIcon", { attrs: { "size": 48 } }), _c("p", [_vm._v(_vm._s(_vm.t("dashy", "No folders found")))])], 1) : _vm._e()], 2), _c("div", { staticClass: "folder-browser-footer" }, [_c("div", { staticClass: "current-selection" }, [_c("strong", [_vm._v(_vm._s(_vm.t("dashy", "Selected:")))]), _c("span", [_vm._v(_vm._s(_vm.selectedFolder ? _vm.selectedFolder.path : _vm.t("dashy", "No folder selected")))])]), _c("div", { staticClass: "browser-actions" }, [_c("NcButton", { on: { "click": _vm.cancelSelection } }, [_vm._v(" " + _vm._s(_vm.t("dashy", "Cancel")) + " ")]), _c("NcButton", { attrs: { "type": "primary", "disabled": !_vm.selectedFolder }, on: { "click": _vm.confirmSelection } }, [_vm._v(" " + _vm._s(_vm.t("dashy", "Select Folder")) + " ")])], 1)])]);
};
var _sfc_staticRenderFns$8 = [];
var __component__$8 = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$8,
  _sfc_render$8,
  _sfc_staticRenderFns$8,
  false,
  null,
  "207ad5e6"
);
const FolderBrowser = __component__$8.exports;
const _sfc_main$7 = {
  name: "NotesSettings",
  components: {
    FolderBrowser
  },
  props: {
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    return {
      showModal: false,
      showFolderBrowser: false,
      modalElement: null,
      folderBrowserElement: null,
      localSettings: {
        maxNotes: this.settings.maxNotes || 10,
        showFavorites: this.settings.showFavorites || false,
        sortBy: this.settings.sortBy || "modified",
        notesFolder: this.settings.notesFolder || "",
        ...this.settings
      },
      availableFolders: []
    };
  },
  watch: {
    settings: {
      handler(newSettings) {
        this.localSettings = {
          maxNotes: newSettings.maxNotes || 10,
          showFavorites: newSettings.showFavorites || false,
          sortBy: newSettings.sortBy || "modified",
          notesFolder: newSettings.notesFolder || "",
          ...newSettings
        };
      },
      deep: true
    }
  },
  mounted() {
    this.$el.addEventListener("show-settings", this.showSettings);
    this.loadAvailableFolders();
  },
  beforeDestroy() {
    this.$el.removeEventListener("show-settings", this.showSettings);
    this.removeModal();
    this.closeFolderBrowser();
  },
  methods: {
    t: translate,
    openSettings() {
      console.log("NotesSettings openSettings called");
      this.showSettings();
    },
    showSettings() {
      this.showModal = true;
      this.createModal();
    },
    closeSettings() {
      this.showModal = false;
      this.removeModal();
    },
    handleEscapeKey(event) {
      if (event.key === "Escape" && this.showModal) {
        this.closeSettings();
      }
    },
    createModal() {
      if (this.modalElement) return;
      document.addEventListener("keydown", this.handleEscapeKey);
      this.modalElement = document.createElement("div");
      this.modalElement.className = "notes-settings-overlay";
      this.modalElement.addEventListener("click", this.handleOverlayClick);
      const modalContent = document.createElement("div");
      modalContent.className = "notes-settings-modal";
      modalContent.addEventListener("click", (e) => e.stopPropagation());
      modalContent.innerHTML = this.getModalHTML();
      this.modalElement.appendChild(modalContent);
      document.body.appendChild(this.modalElement);
      this.bindModalEvents();
    },
    removeModal() {
      if (this.modalElement) {
        document.removeEventListener("keydown", this.handleEscapeKey);
        this.modalElement.removeEventListener("click", this.handleOverlayClick);
        document.body.removeChild(this.modalElement);
        this.modalElement = null;
      }
    },
    handleOverlayClick() {
      this.closeSettings();
    },
    getModalHTML() {
      return `
				<div class="modal-header">
					<h3>${translate("dashy", "Notes Settings")}</h3>
					<button class="close-btn" type="button" title="Close">✕</button>
				</div>
				<form class="settings-form">
					<div class="form-group">
						<label for="maxNotes">${translate("dashy", "Maximum notes to display")}</label>
						<input 
							type="number" 
							id="maxNotes" 
							min="1" 
							max="50" 
							value="${this.localSettings.maxNotes}"
						>
						<small class="setting-description">${translate("dashy", "Maximum number of notes to show in the widget (1-50)")}</small>
					</div>
					<div class="form-group">
						<label for="sortBy">${translate("dashy", "Sort notes by")}</label>
						<select id="sortBy">
							<option value="modified" ${this.localSettings.sortBy === "modified" ? "selected" : ""}>${translate("dashy", "Last modified")}</option>
							<option value="created" ${this.localSettings.sortBy === "created" ? "selected" : ""}>${translate("dashy", "Date created")}</option>
							<option value="title" ${this.localSettings.sortBy === "title" ? "selected" : ""}>${translate("dashy", "Title (A-Z)")}</option>
						</select>
					</div>
					<div class="form-group">
						<label for="notesFolder">${translate("dashy", "Notes storage folder")}</label>
						<div class="folder-selection">
							<div class="current-folder">
								<input 
									type="text" 
									id="notesFolderDisplay" 
									readonly
									value="${this.localSettings.notesFolder || translate("dashy", "Default folder")}"
									class="folder-display"
								>
								<button type="button" class="browse-btn" id="browseFolderBtn">
									${translate("dashy", "Browse...")}
								</button>
							</div>
							<input type="hidden" id="notesFolder" value="${this.localSettings.notesFolder}">
						</div>
						<small class="setting-description">${translate("dashy", "Choose the folder where new notes will be saved")}</small>
					</div>
					<div class="form-group">
						<label class="checkbox-label">
							<input type="checkbox" id="showFavorites" ${this.localSettings.showFavorites ? "checked" : ""}>
							<span>${translate("dashy", "Show favorites first")}</span>
						</label>
					</div>
					<div class="form-actions">
						<button type="button" class="btn-cancel">${translate("dashy", "Cancel")}</button>
						<button type="submit" class="btn-save">${translate("dashy", "Save")}</button>
					</div>
				</form>
			`;
    },
    bindModalEvents() {
      if (!this.modalElement) return;
      const form = this.modalElement.querySelector(".settings-form");
      form.addEventListener("submit", (e) => {
        e.preventDefault();
        this.saveSettings();
      });
      const closeBtn = this.modalElement.querySelector(".close-btn");
      if (closeBtn) {
        closeBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.closeSettings();
        });
      }
      const cancelBtn = this.modalElement.querySelector(".btn-cancel");
      if (cancelBtn) {
        cancelBtn.addEventListener("click", (e) => {
          e.preventDefault();
          this.closeSettings();
        });
      }
      const browseFolderBtn = this.modalElement.querySelector("#browseFolderBtn");
      if (browseFolderBtn) {
        browseFolderBtn.addEventListener("click", (e) => {
          e.preventDefault();
          this.openFolderBrowser();
        });
      }
      const maxNotesInput = this.modalElement.querySelector("#maxNotes");
      const sortBySelect = this.modalElement.querySelector("#sortBy");
      const showFavoritesInput = this.modalElement.querySelector("#showFavorites");
      maxNotesInput?.addEventListener("input", (e) => {
        this.localSettings.maxNotes = parseInt(e.target.value) || 10;
      });
      sortBySelect?.addEventListener("change", (e) => {
        this.localSettings.sortBy = e.target.value;
      });
      showFavoritesInput?.addEventListener("change", (e) => {
        this.localSettings.showFavorites = e.target.checked;
      });
    },
    openFolderBrowser() {
      this.showFolderBrowser = true;
      this.createFolderBrowser();
    },
    createFolderBrowser() {
      if (this.folderBrowserElement) return;
      document.addEventListener("keydown", this.handleFolderBrowserEscapeKey);
      this.folderBrowserElement = document.createElement("div");
      this.folderBrowserElement.className = "folder-browser-overlay";
      this.folderBrowserElement.addEventListener("click", this.handleFolderBrowserOverlayClick);
      const browserContent = document.createElement("div");
      browserContent.className = "folder-browser-modal";
      browserContent.addEventListener("click", (e) => e.stopPropagation());
      browserContent.innerHTML = `
				<div class="modal-header">
					<h3>${translate("dashy", "Select Folder")}</h3>
					<button class="close-btn" type="button" title="Close">✕</button>
				</div>
				<div class="modal-content">
					<div class="browser-content" id="folderBrowserContent">
						<!-- Folder browser will be mounted here -->
					</div>
				</div>
			`;
      this.folderBrowserElement.appendChild(browserContent);
      document.body.appendChild(this.folderBrowserElement);
      this.mountFolderBrowser();
      const closeBtn = this.folderBrowserElement.querySelector(".close-btn");
      if (closeBtn) {
        closeBtn.addEventListener("click", () => {
          this.closeFolderBrowser();
        });
      }
    },
    mountFolderBrowser() {
      const container = this.folderBrowserElement.querySelector("#folderBrowserContent");
      if (!container) return;
      const FolderBrowserComponent = this.$options.components.FolderBrowser;
      const browserInstance = new (this.$options._base.extend(FolderBrowserComponent))({
        propsData: {
          initialPath: ""
          // Start at root folder
        }
      });
      browserInstance.$on("folderSelected", this.onFolderSelected);
      browserInstance.$on("cancel", this.closeFolderBrowser);
      browserInstance.$mount();
      container.appendChild(browserInstance.$el);
      this.folderBrowserInstance = browserInstance;
    },
    onFolderSelected(folder) {
      console.log("Folder selected:", folder);
      this.localSettings.notesFolder = folder.path;
      const folderDisplay = this.modalElement.querySelector("#notesFolderDisplay");
      const folderHidden = this.modalElement.querySelector("#notesFolder");
      if (folderDisplay && folderHidden) {
        folderDisplay.value = folder.path || translate("dashy", "Default folder");
        folderHidden.value = folder.path;
      }
      this.closeFolderBrowser();
    },
    closeFolderBrowser() {
      this.showFolderBrowser = false;
      if (this.folderBrowserInstance) {
        this.folderBrowserInstance.$destroy();
        this.folderBrowserInstance = null;
      }
      if (this.folderBrowserElement) {
        document.removeEventListener("keydown", this.handleFolderBrowserEscapeKey);
        this.folderBrowserElement.removeEventListener("click", this.handleFolderBrowserOverlayClick);
        document.body.removeChild(this.folderBrowserElement);
        this.folderBrowserElement = null;
      }
    },
    handleFolderBrowserOverlayClick() {
      this.closeFolderBrowser();
    },
    handleFolderBrowserEscapeKey(event) {
      if (event.key === "Escape" && this.showFolderBrowser) {
        this.closeFolderBrowser();
      }
    },
    updateSettings() {
      this.$emit("update", { ...this.localSettings });
    },
    async loadAvailableFolders() {
      try {
        const response = await cancelableClient.get(_("/apps/dashy/api/notes/folders"));
        if (response.data && response.data.folders) {
          this.availableFolders = response.data.folders;
        } else {
          this.availableFolders = [
            { path: "", name: translate("dashy", "Root folder") },
            { path: "Notes", name: "Notes" },
            { path: "Documents", name: "Documents" },
            { path: "Documents/Notes", name: "Documents/Notes" }
          ];
        }
      } catch (error) {
        console.warn("Failed to load folders:", error);
        this.availableFolders = [
          { path: "", name: translate("dashy", "Root folder") },
          { path: "Notes", name: "Notes" },
          { path: "Documents", name: "Documents" },
          { path: "Documents/Notes", name: "Documents/Notes" }
        ];
      }
    },
    saveSettings() {
      const maxNotesInput = this.modalElement.querySelector("#maxNotes");
      const sortBySelect = this.modalElement.querySelector("#sortBy");
      const showFavoritesInput = this.modalElement.querySelector("#showFavorites");
      const notesFolderHidden = this.modalElement.querySelector("#notesFolder");
      this.localSettings.maxNotes = parseInt(maxNotesInput.value) || 10;
      this.localSettings.sortBy = sortBySelect.value;
      this.localSettings.showFavorites = showFavoritesInput.checked;
      this.localSettings.notesFolder = notesFolderHidden.value;
      this.updateSettings();
      this.closeSettings();
    }
  }
};
var _sfc_render$7 = function render58() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "notes-settings" });
};
var _sfc_staticRenderFns$7 = [];
var __component__$7 = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$7,
  _sfc_render$7,
  _sfc_staticRenderFns$7,
  false,
  null,
  "7e96fcd6"
);
const NotesSettings = __component__$7.exports;
const _sfc_main$6 = {
  name: "BookmarksSettings",
  props: {
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    return {
      localSettings: {
        maxBookmarks: 15,
        showFavicons: true,
        showDescription: true,
        enableQuickAdd: true,
        ...this.settings
      },
      showModal: false,
      modalElement: null
    };
  },
  mounted() {
    console.log("BookmarksSettings component mounted", this);
  },
  beforeDestroy() {
    document.removeEventListener("keydown", this.handleEscapeKey);
    this.removeModal();
  },
  methods: {
    t: translate,
    updateSettings() {
      this.$emit("update", this.localSettings);
    },
    openSettings() {
      console.log("Opening bookmarks settings modal");
      this.showModal = true;
      this.createModal();
    },
    closeSettings() {
      this.showModal = false;
      this.removeModal();
    },
    handleEscapeKey(event) {
      if (event.key === "Escape" && this.showModal) {
        this.closeSettings();
      }
    },
    createModal() {
      if (this.modalElement) return;
      document.addEventListener("keydown", this.handleEscapeKey);
      this.modalElement = document.createElement("div");
      this.modalElement.className = "bookmarks-settings-overlay";
      this.modalElement.addEventListener("click", this.handleOverlayClick);
      const modalContent = document.createElement("div");
      modalContent.className = "bookmarks-settings-modal";
      modalContent.addEventListener("click", (e) => e.stopPropagation());
      modalContent.innerHTML = this.getModalHTML();
      this.modalElement.appendChild(modalContent);
      document.body.appendChild(this.modalElement);
      this.bindModalEvents();
    },
    removeModal() {
      if (this.modalElement) {
        document.removeEventListener("keydown", this.handleEscapeKey);
        this.modalElement.removeEventListener("click", this.handleOverlayClick);
        document.body.removeChild(this.modalElement);
        this.modalElement = null;
      }
    },
    handleOverlayClick() {
      this.closeSettings();
    },
    getModalHTML() {
      return `
				<div class="modal-header">
					<h3>${translate("dashy", "Bookmarks Settings")}</h3>
					<button class="close-btn" type="button" title="Close">✕</button>
				</div>
				<form class="settings-form">
					<div class="form-group">
						<label for="maxBookmarks">${translate("dashy", "Maximum bookmarks to display")}</label>
						<input 
							type="number" 
							id="maxBookmarks" 
							min="1" 
							max="50" 
							value="${this.localSettings.maxBookmarks}"
						>
						<small class="setting-description">${translate("dashy", "Maximum number of bookmarks to show in the widget (1-50)")}</small>
					</div>
					<div class="form-group">
						<label class="checkbox-label">
							<input type="checkbox" id="showFavicons" ${this.localSettings.showFavicons ? "checked" : ""}>
							<span>${translate("dashy", "Show favicons")}</span>
						</label>
						<small class="setting-description">${translate("dashy", "Display website favicons next to bookmark titles")}</small>
					</div>
					<div class="form-group">
						<label class="checkbox-label">
							<input type="checkbox" id="showDescription" ${this.localSettings.showDescription ? "checked" : ""}>
							<span>${translate("dashy", "Show descriptions")}</span>
						</label>
						<small class="setting-description">${translate("dashy", "Display bookmark descriptions when available")}</small>
					</div>
					<div class="form-group">
						<label class="checkbox-label">
							<input type="checkbox" id="enableQuickAdd" ${this.localSettings.enableQuickAdd ? "checked" : ""}>
							<span>${translate("dashy", "Enable quick bookmark creation")}</span>
						</label>
						<small class="setting-description">${translate("dashy", "Allow adding bookmarks directly from the widget")}</small>
					</div>
					<div class="form-actions">
						<button type="button" class="btn-cancel">${translate("dashy", "Cancel")}</button>
						<button type="submit" class="btn-save">${translate("dashy", "Save")}</button>
					</div>
				</form>
			`;
    },
    bindModalEvents() {
      if (!this.modalElement) return;
      const form = this.modalElement.querySelector(".settings-form");
      form.addEventListener("submit", (e) => {
        e.preventDefault();
        this.saveSettings();
      });
      const closeBtn = this.modalElement.querySelector(".close-btn");
      if (closeBtn) {
        closeBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.closeSettings();
        });
      }
      const cancelBtn = this.modalElement.querySelector(".btn-cancel");
      if (cancelBtn) {
        cancelBtn.addEventListener("click", (e) => {
          e.preventDefault();
          this.closeSettings();
        });
      }
      const maxBookmarksInput = this.modalElement.querySelector("#maxBookmarks");
      const showFaviconsInput = this.modalElement.querySelector("#showFavicons");
      const showDescriptionInput = this.modalElement.querySelector("#showDescription");
      const enableQuickAddInput = this.modalElement.querySelector("#enableQuickAdd");
      maxBookmarksInput?.addEventListener("input", (e) => {
        this.localSettings.maxBookmarks = parseInt(e.target.value) || 15;
      });
      showFaviconsInput?.addEventListener("change", (e) => {
        this.localSettings.showFavicons = e.target.checked;
      });
      showDescriptionInput?.addEventListener("change", (e) => {
        this.localSettings.showDescription = e.target.checked;
      });
      enableQuickAddInput?.addEventListener("change", (e) => {
        this.localSettings.enableQuickAdd = e.target.checked;
      });
    },
    saveSettings() {
      const maxBookmarksInput = this.modalElement.querySelector("#maxBookmarks");
      const showFaviconsInput = this.modalElement.querySelector("#showFavicons");
      const showDescriptionInput = this.modalElement.querySelector("#showDescription");
      const enableQuickAddInput = this.modalElement.querySelector("#enableQuickAdd");
      this.localSettings.maxBookmarks = parseInt(maxBookmarksInput.value) || 15;
      this.localSettings.showFavicons = showFaviconsInput.checked;
      this.localSettings.showDescription = showDescriptionInput.checked;
      this.localSettings.enableQuickAdd = enableQuickAddInput.checked;
      console.log("Saving bookmarks settings:", this.localSettings);
      this.updateSettings();
      this.closeSettings();
    }
  }
};
var _sfc_render$6 = function render59() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "bookmarks-settings" });
};
var _sfc_staticRenderFns$6 = [];
var __component__$6 = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$6,
  _sfc_render$6,
  _sfc_staticRenderFns$6,
  false,
  null,
  null
);
const BookmarksSettings = __component__$6.exports;
const _sfc_main$5 = {
  name: "AiChatSettings",
  props: {
    settings: Object
  },
  data() {
    return {
      apiKey: this.settings.geminiApiKey || "",
      showModal: false,
      modalElement: null
    };
  },
  methods: {
    t: translate,
    openSettings() {
      this.showModal = true;
      this.createModal();
    },
    closeSettings() {
      this.showModal = false;
      this.removeModal();
    },
    handleEscapeKey(event) {
      if (event.key === "Escape" && this.showModal) {
        this.closeSettings();
      }
    },
    createModal() {
      if (this.modalElement) return;
      document.addEventListener("keydown", this.handleEscapeKey);
      this.modalElement = document.createElement("div");
      this.modalElement.className = "ai-chat-settings-overlay";
      this.modalElement.addEventListener("click", this.handleOverlayClick);
      const modalContent = document.createElement("div");
      modalContent.className = "ai-chat-settings-modal";
      modalContent.addEventListener("click", (e) => e.stopPropagation());
      modalContent.innerHTML = this.getModalHTML();
      this.modalElement.appendChild(modalContent);
      document.body.appendChild(this.modalElement);
      this.bindModalEvents();
    },
    removeModal() {
      if (this.modalElement) {
        document.removeEventListener("keydown", this.handleEscapeKey);
        this.modalElement.removeEventListener("click", this.handleOverlayClick);
        document.body.removeChild(this.modalElement);
        this.modalElement = null;
      }
    },
    handleOverlayClick() {
      this.closeSettings();
    },
    getModalHTML() {
      return `
        <div class="modal-header">
          <h3>${translate("dashy", "AI Chat Einstellungen")}</h3>
          <button class="close-btn" type="button" title="Close">✕</button>
        </div>
        <form class="settings-form">
          <div class="form-group">
            <label for="apiKey">Gemini API-Key</label>
            <input id="apiKey" type="password" placeholder="GEMINI_API_KEY" value="${this.apiKey}">
            <small>${translate("dashy", "Dein API-Key wird nur lokal im Widget gespeichert.")}</small>
          </div>
          <div class="form-actions">
            <button type="button" class="btn-cancel">${translate("dashy", "Abbrechen")}</button>
            <button type="submit" class="btn-save">${translate("dashy", "Speichern")}</button>
          </div>
        </form>
      `;
    },
    bindModalEvents() {
      if (!this.modalElement) return;
      const form = this.modalElement.querySelector(".settings-form");
      form.addEventListener("submit", (e) => {
        e.preventDefault();
        const input = this.modalElement.querySelector("#apiKey");
        this.apiKey = input.value;
        this.saveSettings();
      });
      const closeBtn = this.modalElement.querySelector(".close-btn");
      if (closeBtn) {
        closeBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.closeSettings();
        });
      }
      const cancelBtn = this.modalElement.querySelector(".btn-cancel");
      if (cancelBtn) {
        cancelBtn.addEventListener("click", (e) => {
          e.preventDefault();
          this.closeSettings();
        });
      }
    },
    saveSettings() {
      this.$emit("update", { ...this.settings, geminiApiKey: this.apiKey });
      this.closeSettings();
    }
  },
  beforeDestroy() {
    this.removeModal();
  }
};
var _sfc_render$5 = function render60() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "ai-chat-settings" });
};
var _sfc_staticRenderFns$5 = [];
var __component__$5 = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$5,
  _sfc_render$5,
  _sfc_staticRenderFns$5,
  false,
  null,
  "38bf8f17"
);
const AiChatSettings = __component__$5.exports;
const _sfc_main$4 = {
  name: "WidgetContainer",
  components: {
    NcButton,
    CogIcon,
    CloseIcon
  },
  props: {
    widget: {
      type: Object,
      required: false,
      default: null
    },
    editMode: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    widgetComponent() {
      if (!this.widget || !this.widget.type) return null;
      const components = {
        calendar: CalendarWidget,
        todo: TodoWidget,
        clock: ClockWidget,
        weather: WeatherWidget,
        files: FilesWidget,
        notes: NotesWidget,
        bookmarks: BookmarksWidget,
        ai: AiChatWidget
      };
      return components[this.widget.type] || null;
    },
    settingsComponent() {
      if (!this.widget || !this.widget.type) return null;
      const components = {
        calendar: CalendarSettings,
        todo: TodoSettings,
        clock: ClockSettings,
        weather: WeatherSettings,
        files: FilesSettings,
        notes: NotesSettings,
        bookmarks: BookmarksSettings,
        ai: AiChatSettings
      };
      return components[this.widget.type] || null;
    },
    appLogo() {
      return appLogo;
    }
  },
  methods: {
    t: translate,
    updateSettings(newSettings) {
      if (this.widget && this.widget.id) {
        this.$emit("update-settings", this.widget.id, newSettings);
      }
    },
    openWidgetSettings() {
      const settingsComponent = this.$refs.settingsComponent;
      console.log("Opening widget settings for:", this.widget.type, settingsComponent);
      if (settingsComponent && settingsComponent.openSettings) {
        settingsComponent.openSettings();
      } else {
        console.warn("Settings component not found or openSettings method missing:", settingsComponent);
      }
    }
  }
};
var _sfc_render$4 = function render61() {
  var _vm = this, _c = _vm._self._c;
  return _vm.widget === null ? _c("div", { staticClass: "dashboard-landing" }, [_c("div", { staticClass: "landing-content" }, [_c("img", { staticClass: "landing-logo", attrs: { "src": _vm.appLogo, "alt": "Dashy" } }), _c("h2", [_vm._v(_vm._s(_vm.t("dashy", "Welcome to your Dashboard!")))]), _c("p", [_vm._v(_vm._s(_vm.t("dashy", "Get started by adding your first widget.")))]), _vm._t("add-widget-cta", function() {
    return [_c("NcButton", { attrs: { "type": "primary" }, on: { "click": function($event) {
      return _vm.$emit("add-widget");
    } } }, [_vm._v(" " + _vm._s(_vm.t("dashy", "Add Widget")) + " ")])];
  })], 2)]) : _vm.widget ? _c("div", { staticClass: "widget-container" }, [_c("div", { staticClass: "widget-header" }, [_c("h3", [_vm._v(_vm._s(_vm.widget.title || _vm.t("dashy", "Untitled Widget")))]), _vm.editMode ? _c("div", { staticClass: "widget-actions" }, [_c("NcButton", { attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Widget settings") }, on: { "click": _vm.openWidgetSettings }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("CogIcon", { attrs: { "size": 16 } })];
  }, proxy: true }], null, false, 2693047469) }), _c("NcButton", { attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Remove widget") }, on: { "click": function($event) {
    return _vm.$emit("remove", _vm.widget.id);
  } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("CloseIcon", { attrs: { "size": 16 } })];
  }, proxy: true }], null, false, 2746485232) })], 1) : _vm._e()]), _c("div", { staticClass: "widget-content" }, [_c(_vm.widgetComponent, { tag: "component", attrs: { "widget": _vm.widget, "settings": _vm.widget.settings || {} }, on: { "update-settings": _vm.updateSettings } })], 1), _c("div", { staticClass: "widget-settings" }, [_c(_vm.settingsComponent, { ref: "settingsComponent", tag: "component", attrs: { "settings": _vm.widget.settings || {} }, on: { "update": _vm.updateSettings } })], 1)]) : _c("div", { staticClass: "widget-container widget-error" }, [_c("div", { staticClass: "widget-header" }, [_c("h3", [_vm._v(_vm._s(_vm.t("dashy", "Widget Error")))]), _c("div", { staticClass: "widget-actions" }, [_c("NcButton", { attrs: { "type": "tertiary", "aria-label": _vm.t("dashy", "Remove widget") }, on: { "click": function($event) {
    return _vm.$emit("remove", "unknown");
  } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("CloseIcon", { attrs: { "size": 16 } })];
  }, proxy: true }]) })], 1)]), _c("div", { staticClass: "widget-content" }, [_c("p", [_vm._v(_vm._s(_vm.t("dashy", "This widget could not be loaded.")))])])]);
};
var _sfc_staticRenderFns$4 = [];
var __component__$4 = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$4,
  _sfc_render$4,
  _sfc_staticRenderFns$4,
  false,
  null,
  "84607da6"
);
const WidgetContainer = __component__$4.exports;
const _sfc_main$3 = {
  name: "CalendarIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$3 = function render62() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon calendar-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M19,19H5V8H19M16,1V3H8V1H6V3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3H18V1M17,12H12V17H17V12Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$3 = [];
var __component__$3 = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$3,
  _sfc_render$3,
  _sfc_staticRenderFns$3,
  false,
  null,
  null
);
const CalendarIcon = __component__$3.exports;
const _sfc_main$2 = {
  name: "ClockIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$2 = function render63() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon clock-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M16.2,16.2L11,13V7H12.5V12.2L17,14.9L16.2,16.2Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$2 = [];
var __component__$2 = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$2,
  _sfc_render$2,
  _sfc_staticRenderFns$2,
  false,
  null,
  null
);
const ClockIcon = __component__$2.exports;
const _sfc_main$1 = {};
var _sfc_render$1 = function render64() {
  var _vm = this, _c = _vm._self._c;
  return _c("svg", { attrs: { "width": "32", "height": "32", "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" } }, [_c("rect", { attrs: { "x": "3", "y": "8", "width": "18", "height": "8", "rx": "4" } }), _c("circle", { attrs: { "cx": "7", "cy": "12", "r": "1.5" } }), _c("circle", { attrs: { "cx": "17", "cy": "12", "r": "1.5" } }), _c("path", { attrs: { "d": "M12 2v4" } }), _c("path", { attrs: { "d": "M8 2h8" } })]);
};
var _sfc_staticRenderFns$1 = [];
var __component__$1 = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main$1,
  _sfc_render$1,
  _sfc_staticRenderFns$1,
  false,
  null,
  null
);
const RobotIcon = __component__$1.exports;
const _sfc_main = {
  name: "App",
  components: {
    NcAppContent,
    NcButton,
    PlusIcon,
    PencilIcon,
    GridLayout: vueGridLayout_commonExports.GridLayout,
    GridItem: vueGridLayout_commonExports.GridItem,
    WidgetContainer
  },
  data() {
    return {
      layout: [],
      widgets: {},
      showAddWidget: false,
      editMode: false,
      showFabMenu: false,
      tooltip: null,
      isDarkMode: false,
      availableWidgets: [
        {
          type: "calendar",
          name: translate("dashy", "Calendar"),
          description: translate("dashy", "View your upcoming events"),
          icon: CalendarIcon
        },
        {
          type: "todo",
          name: translate("dashy", "Tasks"),
          description: translate("dashy", "Manage your tasks"),
          icon: CheckboxMarkedCircleIcon
        },
        {
          type: "clock",
          name: translate("dashy", "Clock"),
          description: translate("dashy", "Display current time"),
          icon: ClockIcon
        },
        {
          type: "weather",
          name: translate("dashy", "Weather"),
          description: translate("dashy", "Current weather information"),
          icon: WeatherPartlyCloudyIcon
        },
        {
          type: "ai",
          name: translate("dashy", "AI Chat"),
          description: translate("dashy", "Chatte mit Gemini AI"),
          icon: RobotIcon
        },
        {
          type: "files",
          name: translate("dashy", "Files"),
          description: translate("dashy", "Recent and favorite files"),
          icon: FolderIcon
        },
        {
          type: "notes",
          name: translate("dashy", "Notes"),
          description: translate("dashy", "Quick notes and reminders"),
          icon: NoteTextIcon
        },
        {
          type: "bookmarks",
          name: translate("dashy", "Bookmarks"),
          description: translate("dashy", "Your saved bookmarks"),
          icon: BookmarkIcon
        }
      ],
      appLogo
    };
  },
  async mounted() {
    await this.loadDashboard();
    this.updateLandingScroll();
  },
  watch: {
    layout: {
      handler() {
        this.updateLandingScroll();
      },
      deep: true
    }
  },
  methods: {
    toggleFabMenu() {
      if (!this.editMode) {
        this.editMode = true;
        this.showFabMenu = true;
      } else {
        this.editMode = false;
        this.showFabMenu = false;
      }
    },
    toggleDarkMode() {
      this.isDarkMode = !this.isDarkMode;
      const root = document.documentElement;
      if (this.isDarkMode) {
        root.classList.add("dashy-dark");
      } else {
        root.classList.remove("dashy-dark");
      }
    },
    showTooltip(type) {
      this.tooltip = type;
    },
    hideTooltip() {
      this.tooltip = null;
    },
    async loadDashboard() {
      try {
        const response = await cancelableClient.get(_("/apps/dashy/api/dashboard"));
        console.log("Dashboard loaded:", response.data);
        this.layout = response.data.layout || [];
        this.widgets = response.data.widgets || {};
        console.log("Layout:", this.layout);
        console.log("Widgets:", this.widgets);
      } catch (error) {
        console.error("Failed to load dashboard:", error);
        this.layout = [];
        this.widgets = {};
      }
    },
    async saveLayout(newLayout) {
      this.layout = newLayout;
      await this.saveDashboard();
    },
    async saveDashboard() {
      try {
        console.log("Saving dashboard:", { layout: this.layout, widgets: this.widgets });
        const response = await cancelableClient.post(_("/apps/dashy/api/dashboard"), {
          layout: this.layout,
          widgets: this.widgets
        });
        console.log("Dashboard saved:", response.data);
      } catch (error) {
        console.error("Failed to save dashboard:", error);
      }
    },
    closeAddWidget() {
      this.showAddWidget = false;
    },
    addWidget(widgetType) {
      const widgetId = "widget_" + Date.now();
      const newWidget = {
        id: widgetId,
        type: widgetType.type,
        title: widgetType.name,
        settings: {}
      };
      this.widgets = {
        ...this.widgets,
        [widgetId]: newWidget
      };
      this.layout.push({
        i: widgetId,
        x: 0,
        y: 0,
        w: 4,
        h: 4
      });
      this.showAddWidget = false;
      this.saveDashboard();
    },
    removeWidget(widgetId) {
      this.$delete(this.widgets, widgetId);
      this.layout = this.layout.filter((item) => item.i !== widgetId);
      this.saveDashboard();
    },
    getWidget(widgetId) {
      return this.widgets[widgetId];
    },
    getWidgetWithLayout(widgetId, layoutItem) {
      const widget = this.widgets[widgetId];
      if (!widget) {
        console.warn("Widget not found for ID:", widgetId, "Available widgets:", Object.keys(this.widgets));
        return null;
      }
      return {
        ...widget,
        w: layoutItem.w,
        h: layoutItem.h
      };
    },
    updateWidgetSettings(widgetId, newSettings) {
      if (this.widgets[widgetId]) {
        this.$set(this.widgets[widgetId], "settings", newSettings);
        this.saveDashboard();
      }
    },
    // toggleEditMode entfernt, da Logik jetzt in toggleFabMenu enthalten ist
    updateLandingScroll() {
      const appContent = document.getElementById("app-content-vue");
      if (appContent) {
        if (this.layout.length === 0) {
          appContent.classList.add("landing-no-scroll");
        } else {
          appContent.classList.remove("landing-no-scroll");
        }
      }
    },
    t: translate
  }
};
var _sfc_render = function render65() {
  var _vm = this, _c = _vm._self._c;
  return _c("NcAppContent", [_c("div", { class: { "landing-no-scroll": _vm.layout.length === 0 }, attrs: { "id": "dashy" } }, [_c("div", { staticClass: "dashboard-bg" }, [_vm.layout.length === 0 ? _c("div", { staticClass: "dashboard-landing" }, [_c("div", { staticClass: "landing-content" }, [_c("img", { staticClass: "landing-logo", attrs: { "src": _vm.appLogo, "alt": "Dashy" } }), _c("h2", { staticClass: "landing-title" }, [_vm._v(_vm._s(_vm.t("dashy", "Welcome!")))]), _c("div", { staticClass: "landing-sub" }, [_c("span", { staticClass: "landing-highlight" }, [_vm._v(_vm._s(_vm.t("dashy", "Create your personal dashboard in seconds.")))]), _c("span", { staticClass: "landing-desc" }, [_vm._v(_vm._s(_vm.t("dashy", "Add widgets for calendar, tasks, weather, AI chat and more – alles individuell anpassbar.")))])]), _c("div", { staticClass: "landing-actions" }, [_c("NcButton", { staticClass: "landing-add-btn", attrs: { "type": "primary" }, on: { "click": function($event) {
    _vm.showAddWidget = true;
  } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("PlusIcon")];
  }, proxy: true }], null, false, 1789392498) }, [_vm._v(" " + _vm._s(_vm.t("dashy", "Add Widget")) + " ")])], 1), _c("ul", { staticClass: "landing-features" }, [_c("li", [_c("span", [_vm._v("🧩")]), _vm._v(" " + _vm._s(_vm.t("dashy", "Drag & drop your widgets anywhere")))]), _c("li", [_c("span", [_vm._v("⚡️")]), _vm._v(" " + _vm._s(_vm.t("dashy", "Instantly customize and resize")))]), _c("li", [_c("span", [_vm._v("🔒")]), _vm._v(" " + _vm._s(_vm.t("dashy", "Your data stays private")))])])])]) : _c("div", [_c("div", { staticClass: "fab-menu", class: { open: _vm.showFabMenu || _vm.editMode } }, [_c("transition-group", { attrs: { "name": "fab-action-fade", "tag": "div" } }, [_vm.editMode ? _c("button", { key: "add-widget", staticClass: "fab-btn fab-action", attrs: { "aria-label": "Add Widget", "tabindex": "0" }, on: { "click": function($event) {
    _vm.showAddWidget = true;
  }, "mouseenter": function($event) {
    return _vm.showTooltip("add");
  }, "mouseleave": _vm.hideTooltip } }, [_c("PlusIcon"), _vm.tooltip === "add" ? _c("span", { staticClass: "fab-tooltip" }, [_vm._v(_vm._s(_vm.t("dashy", "Add Widget")))]) : _vm._e()], 1) : _vm._e(), _c("button", { key: "toggle-dark", staticClass: "fab-btn fab-action dark-toggle-fab", attrs: { "aria-label": "Toggle Dark Mode", "tabindex": "0" }, on: { "click": _vm.toggleDarkMode, "mouseenter": function($event) {
    return _vm.showTooltip("dark");
  }, "mouseleave": _vm.hideTooltip } }, [_c("svg", { attrs: { "width": "22", "height": "22", "viewBox": "0 0 24 24", "fill": "none" } }, [_c("path", { attrs: { "fill": _vm.isDarkMode ? "#ffd600" : "#222", "d": "M12 2a1 1 0 0 1 1 1v1.07A7.001 7.001 0 0 1 19.93 11H21a1 1 0 1 1 0 2h-1.07A7.001 7.001 0 0 1 13 19.93V21a1 1 0 1 1-2 0v-1.07A7.001 7.001 0 0 1 4.07 13H3a1 1 0 1 1 0-2h1.07A7.001 7.001 0 0 1 11 4.07V3a1 1 0 0 1 1-1zm0 4a5 5 0 1 0 0 10A5 5 0 0 0 12 6z" } })]), _vm.tooltip === "dark" ? _c("span", { staticClass: "fab-tooltip" }, [_vm._v(_vm._s(_vm.isDarkMode ? _vm.t("dashy", "Light Mode") : _vm.t("dashy", "Dark Mode")))]) : _vm._e()])]), _c("button", { staticClass: "fab-btn main-fab", attrs: { "aria-label": _vm.editMode ? _vm.t("dashy", "Exit Edit Mode") : _vm.t("dashy", "Edit Dashboard"), "tabindex": "0" }, on: { "click": _vm.toggleFabMenu, "mouseenter": function($event) {
    return _vm.showTooltip("edit");
  }, "mouseleave": _vm.hideTooltip } }, [_c("PencilIcon", { style: _vm.editMode ? "opacity:0.7;" : "" }), _vm.tooltip === "edit" ? _c("span", { staticClass: "fab-tooltip" }, [_vm._v(" " + _vm._s(_vm.editMode ? _vm.t("dashy", "Exit Edit Mode") : _vm.t("dashy", "Edit Dashboard")) + " ")]) : _vm._e()], 1)], 1), _c("div", { staticClass: "dashboard-container" }, [_c("grid-layout", { attrs: { "layout": _vm.layout, "col-num": 12, "row-height": 60, "is-draggable": _vm.editMode, "is-resizable": _vm.editMode, "is-mirrored": false, "vertical-compact": true, "margin": [10, 10], "use-css-transforms": true }, on: { "layout-updated": _vm.saveLayout } }, _vm._l(_vm.layout, function(item) {
    return _c("grid-item", { key: item.i, attrs: { "x": item.x, "y": item.y, "w": item.w, "h": item.h, "i": item.i } }, [_c("widget-container", { attrs: { "widget": _vm.getWidgetWithLayout(item.i, item), "editMode": _vm.editMode }, on: { "remove": _vm.removeWidget, "update-settings": _vm.updateWidgetSettings } })], 1);
  }), 1)], 1)])]), _vm.showAddWidget ? _c("div", { staticClass: "add-widget-overlay", on: { "click": _vm.closeAddWidget } }, [_c("div", { staticClass: "add-widget-modal", on: { "click": function($event) {
    $event.stopPropagation();
  } } }, [_c("div", { staticClass: "modal-header" }, [_c("h3", [_vm._v(_vm._s(_vm.t("dashy", "Add Widget")))]), _c("button", { staticClass: "close-btn", attrs: { "type": "button", "title": "Close" }, on: { "click": _vm.closeAddWidget } }, [_vm._v("✕")])]), _c("div", { staticClass: "modal-content" }, [_c("div", { staticClass: "widget-types" }, _vm._l(_vm.availableWidgets, function(widgetType) {
    return _c("div", { key: widgetType.type, staticClass: "widget-type-card", on: { "click": function($event) {
      return _vm.addWidget(widgetType);
    } } }, [_c(widgetType.icon, { tag: "component", attrs: { "size": 32 } }), _c("h3", [_vm._v(_vm._s(widgetType.name))]), _c("p", [_vm._v(_vm._s(widgetType.description))])], 1);
  }), 0)])])]) : _vm._e()])]);
};
var _sfc_staticRenderFns = [];
var __component__ = /* @__PURE__ */ normalizeComponent$2(
  _sfc_main,
  _sfc_render,
  _sfc_staticRenderFns,
  false,
  null,
  "82b3770e"
);
const App = __component__.exports;
Vue.mixin({ methods: { t, n } });
const View = Vue.extend(App);
new View().$mount("#dashy");
//# sourceMappingURL=dashy-main.mjs.map
